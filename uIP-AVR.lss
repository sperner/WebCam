
uIP-AVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003d04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00003d04  00003d98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000530  00800074  00800074  00003dac  2**0
                  ALLOC
  3 .stab         00000ec4  00000000  00000000  00003dac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000195  00000000  00000000  00004c70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00004e05  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000712  00000000  00000000  00004f45  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00003051  00000000  00000000  00005657  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000db3  00000000  00000000  000086a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002725  00000000  00000000  0000945b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000490  00000000  00000000  0000bb80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000009da  00000000  00000000  0000c010  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000082f  00000000  00000000  0000c9ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000048  00000000  00000000  0000d219  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__ctors_end>
       4:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
       8:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
       c:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      10:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      14:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      18:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      1c:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      20:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      24:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      28:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      2c:	0c 94 c5 07 	jmp	0xf8a	; 0xf8a <__vector_11>
      30:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      34:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      38:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      3c:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      40:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      44:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      48:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      4c:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>
      50:	0c 94 bb 07 	jmp	0xf76	; 0xf76 <__bad_interrupt>

00000054 <index_html>:
      54:	3c 68 65 61 64 3e 3c 74 69 74 6c 65 3e 41 54 6d     <head><title>ATm
      64:	65 67 61 33 32 20 57 65 62 43 61 6d 3c 2f 74 69     ega32 WebCam</ti
      74:	74 6c 65 3e 3c 73 74 79 6c 65 20 74 79 70 65 3d     tle><style type=
      84:	22 74 65 78 74 2f 63 73 73 22 3e 64 69 76 7b 77     "text/css">div{w
      94:	69 64 74 68 3a 20 36 36 30 70 78 3b 62 6f 72 64     idth: 660px;bord
      a4:	65 72 3a 20 31 70 78 20 73 6f 6c 69 64 20 62 6c     er: 1px solid bl
      b4:	61 63 6b 3b 62 61 63 6b 67 72 6f 75 6e 64 3a 20     ack;background: 
      c4:	23 65 30 65 30 65 30 3b 70 61 64 64 69 6e 67 3a     #e0e0e0;padding:
      d4:	20 32 70 78 3b 7d 23 74 7b 66 6f 6e 74 2d 73 69      2px;}#t{font-si
      e4:	7a 65 3a 20 31 38 70 78 3b 20 62 6f 72 64 65 72     ze: 18px; border
      f4:	2d 62 6f 74 74 6f 6d 3a 20 30 3b 20 6d 61 72 67     -bottom: 0; marg
     104:	69 6e 2d 74 6f 70 3a 20 38 70 78 3b 7d 23 63 7b     in-top: 8px;}#c{
     114:	77 69 64 74 68 3a 20 36 36 30 70 78 3b 62 6f 72     width: 660px;bor
     124:	64 65 72 3a 20 31 70 78 20 73 6f 6c 69 64 20 62     der: 1px solid b
     134:	6c 61 63 6b 3b 62 61 63 6b 67 72 6f 75 6e 64 3a     lack;background:
     144:	20 23 65 30 65 30 65 30 3b 20 70 61 64 64 69 6e      #e0e0e0; paddin
     154:	67 3a 20 32 70 78 3b 74 65 78 74 2d 61 6c 69 67     g: 2px;text-alig
     164:	6e 3a 20 63 65 6e 74 65 72 3b 68 65 69 67 68 74     n: center;height
     174:	3a 20 34 38 30 70 78 3b 62 6f 72 64 65 72 2d 74     : 480px;border-t
     184:	6f 70 3a 20 30 3b 62 6f 72 64 65 72 2d 62 6f 74     op: 0;border-bot
     194:	74 6f 6d 3a 20 30 3b 7d 23 64 7b 62 6f 72 64 65     tom: 0;}#d{borde
     1a4:	72 3a 20 31 70 78 20 73 6f 6c 69 64 20 62 6c 61     r: 1px solid bla
     1b4:	63 6b 3b 7d 23 66 7b 66 6f 6e 74 2d 73 69 7a 65     ck;}#f{font-size
     1c4:	3a 20 31 34 70 78 3b 62 6f 72 64 65 72 2d 74 6f     : 14px;border-to
     1d4:	70 3a 20 30 3b 20 74 65 78 74 2d 61 6c 69 67 6e     p: 0; text-align
     1e4:	3a 20 72 69 67 68 74 3b 20 70 61 64 64 69 6e 67     : right; padding
     1f4:	2d 62 6f 74 74 6f 6d 3a 20 35 70 78 3b 7d 23 72     -bottom: 5px;}#r
     204:	7b 20 62 61 63 6b 67 72 6f 75 6e 64 3a 20 23 63     { background: #c
     214:	30 63 30 63 30 3b 20 62 6f 72 64 65 72 3a 20 31     0c0c0; border: 1
     224:	70 78 20 73 6f 6c 69 64 20 62 6c 61 63 6b 3b 20     px solid black; 
     234:	70 61 64 64 69 6e 67 2d 6c 65 66 74 3a 20 31 30     padding-left: 10
     244:	70 78 3b 20 70 61 64 64 69 6e 67 2d 72 69 67 68     px; padding-righ
     254:	74 3a 20 31 30 70 78 3b 74 65 78 74 2d 64 65 63     t: 10px;text-dec
     264:	6f 72 61 74 69 6f 6e 3a 20 6e 6f 6e 65 3b 20 6d     oration: none; m
     274:	61 72 67 69 6e 2d 72 69 67 68 74 3a 20 31 30 70     argin-right: 10p
     284:	78 3b 20 7d 23 72 3a 68 6f 76 65 72 7b 20 62 61     x; }#r:hover{ ba
     294:	63 6b 67 72 6f 75 6e 64 3a 20 23 37 30 37 30 37     ckground: #70707
     2a4:	30 3b 7d 23 77 7b 76 69 73 69 62 69 6c 69 74 79     0;}#w{visibility
     2b4:	3a 20 76 69 73 69 62 6c 65 3b 20 62 6f 72 64 65     : visible; borde
     2c4:	72 3a 20 31 70 78 20 73 6f 6c 69 64 20 77 68 69     r: 1px solid whi
     2d4:	74 65 3b 20 70 6f 73 69 74 69 6f 6e 3a 20 61 62     te; position: ab
     2e4:	73 6f 6c 75 74 65 3b 20 62 61 63 6b 67 72 6f 75     solute; backgrou
     2f4:	6e 64 3a 20 23 30 30 30 30 30 30 3b 20 63 6f 6c     nd: #000000; col
     304:	6f 72 3a 20 23 66 66 66 66 66 66 3b 20 74 6f 70     or: #ffffff; top
     314:	3a 32 30 30 70 78 3b 20 6c 65 66 74 3a 34 33 30     :200px; left:430
     324:	70 78 3b 20 77 69 64 74 68 3a 31 35 30 70 78 3b     px; width:150px;
     334:	20 68 65 69 67 68 74 3a 35 30 70 78 3b 20 7a 2d      height:50px; z-
     344:	69 6e 64 65 78 3a 31 3b 20 7d 3c 2f 73 74 79 6c     index:1; }</styl
     354:	65 3e 3c 73 63 72 69 70 74 20 6c 61 6e 67 75 61     e><script langua
     364:	67 65 3d 22 4a 61 76 61 73 63 72 69 70 74 22 20     ge="Javascript" 
     374:	74 79 70 65 3d 22 74 65 78 74 2f 6a 61 76 61 73     type="text/javas
     384:	63 72 69 70 74 22 3e 66 75 6e 63 74 69 6f 6e 20     cript">function 
     394:	77 61 69 74 28 69 29 7b 69 66 20 28 64 6f 63 75     wait(i){if (docu
     3a4:	6d 65 6e 74 2e 67 65 74 45 6c 65 6d 65 6e 74 42     ment.getElementB
     3b4:	79 49 64 29 20 64 6f 63 75 6d 65 6e 74 2e 67 65     yId) document.ge
     3c4:	74 45 6c 65 6d 65 6e 74 42 79 49 64 28 22 77 22     tElementById("w"
     3d4:	29 2e 73 74 79 6c 65 2e 76 69 73 69 62 69 6c 69     ).style.visibili
     3e4:	74 79 20 3d 20 28 69 3d 3d 31 3f 22 76 69 73 69     ty = (i==1?"visi
     3f4:	62 6c 65 22 3a 22 68 69 64 64 65 6e 22 29 3b 20     ble":"hidden"); 
     404:	7d 0a 66 75 6e 63 74 69 6f 6e 20 63 61 6d 28 29     }.function cam()
     414:	7b 77 61 69 74 28 31 29 3b 69 66 20 28 64 6f 63     {wait(1);if (doc
     424:	75 6d 65 6e 74 2e 67 65 74 45 6c 65 6d 65 6e 74     ument.getElement
     434:	42 79 49 64 29 20 64 6f 63 75 6d 65 6e 74 2e 67     ById) document.g
     444:	65 74 45 6c 65 6d 65 6e 74 42 79 49 64 28 22 64     etElementById("d
     454:	22 29 2e 73 72 63 20 3d 20 22 2f 63 61 6d 3f 74     ").src = "/cam?t
     464:	3d 22 2b 4d 61 74 68 2e 66 6c 6f 6f 72 28 31 30     ="+Math.floor(10
     474:	30 2b 4d 61 74 68 2e 72 61 6e 64 6f 6d 28 29 2a     0+Math.random()*
     484:	38 39 39 29 3b 20 73 65 74 54 69 6d 65 6f 75 74     899); setTimeout
     494:	28 22 77 61 69 74 28 30 29 3b 22 2c 39 30 30 30     ("wait(0);",9000
     4a4:	29 3b 7d 0a 66 75 6e 63 74 69 6f 6e 20 63 61 6d     );}.function cam
     4b4:	32 28 76 61 6c 29 7b 77 61 69 74 28 31 29 3b 69     2(val){wait(1);i
     4c4:	66 20 28 64 6f 63 75 6d 65 6e 74 2e 67 65 74 45     f (document.getE
     4d4:	6c 65 6d 65 6e 74 42 79 49 64 29 20 64 6f 63 75     lementById) docu
     4e4:	6d 65 6e 74 2e 67 65 74 45 6c 65 6d 65 6e 74 42     ment.getElementB
     4f4:	79 49 64 28 22 64 22 29 2e 73 72 63 20 3d 20 22     yId("d").src = "
     504:	2f 63 61 6d 3f 76 3d 22 2b 76 61 6c 2b 22 26 74     /cam?v="+val+"&t
     514:	3d 22 2b 4d 61 74 68 2e 66 6c 6f 6f 72 28 31 30     ="+Math.floor(10
     524:	30 2b 4d 61 74 68 2e 72 61 6e 64 6f 6d 28 29 2a     0+Math.random()*
     534:	38 39 39 29 3b 20 73 65 74 54 69 6d 65 6f 75 74     899); setTimeout
     544:	28 22 77 61 69 74 28 30 29 3b 22 2c 39 35 30 30     ("wait(0);",9500
     554:	29 3b 7d 0a 3c 2f 73 63 72 69 70 74 3e 3c 2f 68     );}.</script></h
     564:	65 61 64 3e 3c 62 6c 6f 63 6b 71 75 6f 74 65 3e     ead><blockquote>
     574:	0d 0a 3c 62 6c 6f 63 6b 71 75 6f 74 65 3e 0d 0a     ..<blockquote>..
     584:	3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d 22 23     <body bgcolor="#
     594:	33 33 36 36 39 39 22 20 76 6c 69 6e 6b 3d 22 23     336699" vlink="#
     5a4:	30 30 30 30 30 30 22 20 61 6c 69 6e 6b 3d 22 23     000000" alink="#
     5b4:	30 30 30 30 30 30 22 20 6c 69 6e 6b 3d 22 23 30     000000" link="#0
     5c4:	30 30 30 30 30 22 20 6f 6e 4c 6f 61 64 3d 22 77     00000" onLoad="w
     5d4:	61 69 74 28 30 29 3b 22 3e 3c 63 65 6e 74 65 72     ait(0);"><center
     5e4:	3e 3c 2f 63 65 6e 74 65 72 3e 3c 63 65 6e 74 65     ></center><cente
     5f4:	72 3e 3c 64 69 76 20 69 64 3d 22 74 22 3e 41 54     r><div id="t">AT
     604:	6d 65 67 61 33 32 20 2b 20 4d 43 41 2d 32 35 20     mega32 + MCA-25 
     614:	2b 20 52 54 4c 38 30 31 39 3c 2f 64 69 76 3e 3c     + RTL8019</div><
     624:	64 69 76 20 69 64 3d 22 63 22 3e 3c 64 69 76 20     div id="c"><div 
     634:	69 64 3d 22 77 22 3e 3c 62 72 3e 6c 6f 61 64 69     id="w"><br>loadi
     644:	6e 67 2e 2e 2e 3c 2f 64 69 76 3e 3c 69 6d 67 20     ng...</div><img 
     654:	69 64 3d 22 64 22 20 6e 61 6d 65 3d 22 63 61 6d     id="d" name="cam
     664:	22 20 73 72 63 3d 22 70 69 63 74 75 72 65 2e 6a     " src="picture.j
     674:	70 67 22 20 68 65 69 67 68 74 3d 22 34 38 30 22     pg" height="480"
     684:	20 77 69 64 74 68 3d 22 36 34 30 22 20 61 6c 74      width="640" alt
     694:	3d 22 6c 6f 61 64 69 6e 67 2e 2e 2e 22 3e 3c 2f     ="loading..."></
     6a4:	64 69 76 3e 3c 64 69 76 20 69 64 3d 22 66 22 3e     div><div id="f">
     6b4:	53 65 72 76 6f 20 3a 20 3c 61 20 69 64 3d 22 72     Servo : <a id="r
     6c4:	22 20 68 72 65 66 3d 22 30 30 30 22 3e 31 32 35     " href="000">125
     6d4:	3c 2f 61 3e 3c 61 20 69 64 3d 22 72 22 20 68 72     </a><a id="r" hr
     6e4:	65 66 3d 22 30 32 35 22 3e 31 30 30 3c 2f 61 3e     ef="025">100</a>
     6f4:	3c 61 20 69 64 3d 22 72 22 20 68 72 65 66 3d 22     <a id="r" href="
     704:	30 35 30 22 3e 37 35 3c 2f 61 3e 3c 61 20 69 64     050">75</a><a id
     714:	3d 22 72 22 20 68 72 65 66 3d 22 30 37 35 22 3e     ="r" href="075">
     724:	35 30 3c 2f 61 3e 3c 61 20 69 64 3d 22 72 22 20     50</a><a id="r" 
     734:	68 72 65 66 3d 22 31 30 30 22 3e 32 35 3c 2f 61     href="100">25</a
     744:	3e 3c 61 20 69 64 3d 22 72 22 20 68 72 65 66 3d     ><a id="r" href=
     754:	22 31 32 35 22 3e 30 3c 2f 61 3e 3c 61 20 69 64     "125">0</a><a id
     764:	3d 22 72 22 20 68 72 65 66 3d 22 31 35 30 22 3e     ="r" href="150">
     774:	32 35 3c 2f 61 3e 3c 61 20 69 64 3d 22 72 22 20     25</a><a id="r" 
     784:	68 72 65 66 3d 22 31 37 35 22 3e 35 30 3c 2f 61     href="175">50</a
     794:	3e 3c 61 20 69 64 3d 22 72 22 20 68 72 65 66 3d     ><a id="r" href=
     7a4:	22 32 30 30 22 3e 37 35 3c 2f 61 3e 3c 61 20 69     "200">75</a><a i
     7b4:	64 3d 22 72 22 20 68 72 65 66 3d 22 32 32 35 22     d="r" href="225"
     7c4:	3e 31 30 30 3c 2f 61 3e 3c 61 20 69 64 3d 22 72     >100</a><a id="r
     7d4:	22 20 68 72 65 66 3d 22 32 35 30 22 3e 31 32 35     " href="250">125
     7e4:	3c 2f 61 3e 20 3a 20 3c 61 20 69 64 3d 22 72 22     </a> : <a id="r"
     7f4:	20 68 72 65 66 3d 22 22 3e 72 65 6c 6f 61 64 3c      href="">reload<
     804:	2f 61 3e 3c 2f 64 69 76 3e 3c 64 69 76 20 69 64     /a></div><div id
     814:	3d 22 66 22 3e 52 65 6c 61 69 73 20 3a 20 3c 61     ="f">Relais : <a
     824:	20 69 64 3d 22 72 22 20 68 72 65 66 3d 22 79 61      id="r" href="ya
     834:	71 77 73 78 22 3e 73 63 68 6c 69 65 73 73 65 6e     qwsx">schliessen
     844:	3c 2f 61 3e 3c 61 20 69 64 3d 22 72 22 20 68 72     </a><a id="r" hr
     854:	65 66 3d 22 63 64 65 72 66 76 22 3e 6f 65 66 66     ef="cderfv">oeff
     864:	6e 65 6e 3c 2f 61 3e 3c 2f 64 69 76 3e 3c 61 20     nen</a></div><a 
     874:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 62 69 67     href="http://big
     884:	62 61 62 6f 75 2e 64 79 6e 64 6e 73 2e 69 6e 66     babou.dyndns.inf
     894:	6f 22 3e 48 6f 6d 65 70 61 67 65 3c 2f 61 3e 3c     o">Homepage</a><
     8a4:	2f 63 65 6e 74 65 72 3e 3c 2f 62 6f 64 79 3e 3c     /center></body><
     8b4:	2f 68 74 6d 6c 3e 3c 63 65 6e 74 65 72 3e 42 69     /html><center>Bi
     8c4:	67 57 65 62 42 61 62 6f 75 2c 20 41 54 6d 65 67     gWebBabou, ATmeg
     8d4:	61 33 32 20 2d 20 31 34 2c 37 34 35 36 20 4d 48     a32 - 14,7456 MH
     8e4:	7a 20 2d 20 48 61 6e 64 79 43 61 6d 20 2d 20 53     z - HandyCam - S
     8f4:	65 72 76 6f 20 2d 20 75 49 50 3c 2f 63 65 6e 74     ervo - uIP</cent
     904:	65 72 3e 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c     er></body></html
     914:	3e 0d 0a 0d 0a 25 45 4f 46 00                       >....%EOF.

0000091e <error_404>:
     91e:	3c 68 74 6d 6c 3e 3c 62 6f 64 79 20 62 67 63 6f     <html><body bgco
     92e:	6c 6f 72 3d 22 77 68 69 74 65 22 3e 3c 63 65 6e     lor="white"><cen
     93e:	74 65 72 3e 3c 68 31 3e 34 30 34 20 2d 20 66 69     ter><h1>404 - fi
     94e:	6c 65 20 6e 6f 74 20 66 6f 75 6e 64 3c 2f 68 31     le not found</h1
     95e:	3e 3c 2f 63 65 6e 74 65 72 3e 3c 2f 62 6f 64 79     ></center></body
     96e:	3e 3c 2f 68 74 6d 6c 3e 0d 0a 0d 0a 00              ></html>.....

0000097b <__c.2086>:
     97b:	32 35 30 00                                         250.

0000097f <__c.2083>:
     97f:	32 35 30 00                                         250.

00000983 <__c.2081>:
     983:	32 32 35 00                                         225.

00000987 <__c.2078>:
     987:	32 32 35 00                                         225.

0000098b <__c.2076>:
     98b:	32 30 30 00                                         200.

0000098f <__c.2073>:
     98f:	32 30 30 00                                         200.

00000993 <__c.2071>:
     993:	31 37 35 00                                         175.

00000997 <__c.2068>:
     997:	31 37 35 00                                         175.

0000099b <__c.2066>:
     99b:	31 35 30 00                                         150.

0000099f <__c.2063>:
     99f:	31 35 30 00                                         150.

000009a3 <__c.2061>:
     9a3:	31 32 35 00                                         125.

000009a7 <__c.2058>:
     9a7:	31 32 35 00                                         125.

000009ab <__c.2056>:
     9ab:	31 30 30 00                                         100.

000009af <__c.2053>:
     9af:	31 30 30 00                                         100.

000009b3 <__c.2051>:
     9b3:	30 37 35 00                                         075.

000009b7 <__c.2048>:
     9b7:	30 37 35 00                                         075.

000009bb <__c.2046>:
     9bb:	30 35 30 00                                         050.

000009bf <__c.2043>:
     9bf:	30 35 30 00                                         050.

000009c3 <__c.2041>:
     9c3:	30 32 35 00                                         025.

000009c7 <__c.2038>:
     9c7:	30 32 35 00                                         025.

000009cb <__c.2036>:
     9cb:	30 30 30 00                                         000.

000009cf <__c.2032>:
     9cf:	30 30 30 00                                         000.

000009d3 <__c.2030>:
     9d3:	63 64 65 72 66 76 00                                cderfv.

000009da <__c.2028>:
     9da:	79 61 71 77 73 78 00                                yaqwsx.

000009e1 <__c.2026>:
     9e1:	70 69 63 74 75 72 65 2e 6a 70 67 00                 picture.jpg.

000009ed <__c.2023>:
     9ed:	73 65 73 61 6d 2e 68 74 6d 6c 00                    sesam.html.

000009f8 <__c.2021>:
     9f8:	47 45 54 20 2f 00                                   GET /.

000009fe <__c.1989>:
     9fe:	45 4f 46 00                                         EOF.

00000a02 <__c.1945>:
     a02:	0d 0a 0d 0a 00                                      .....

00000a07 <MCA25_START_JPG_1>:
     a07:	f9 81 ef 3f 83 00 82 71 00 58 3c 6d 6f 6e 69 74     ...?...q.X<monit
     a17:	6f 72 69 6e 67 2d 63 6f 6d 6d 61 6e 64 20 76 65     oring-command ve
     a27:	72 73 69 8c f9 f9 81 ef 3f 6f 6e 3d 22 31 2e 30     rsi.....?on="1.0
     a37:	22 20 74 61 6b 65 2d 70 69 63 3d 22 4e 4f 22 20     " take-pic="NO" 
     a47:	73 65 6e 64 2d 70 69 78 8c f9 f9 81 ef 3f 65 6c     send-pix.....?el
     a57:	2d 73 69 7a 65 3d 22                                -size="

00000a5e <MCA25_START_JPG_640x480>:
     a5e:	36 34 30 2a 34 38 30                                640*480

00000a65 <MCA25_START_JPG_320x240>:
     a65:	33 32 30 2a 32 34 30                                320*240

00000a6c <MCA25_START_JPG_160x120>:
     a6c:	31 36 30 2a 31 32 30                                160*120

00000a73 <MCA25_START_JPG_2>:
     a73:	22 20 7a 6f 6f 6d 3d 22 31 30 22 2f 3e 42 00 8c     " zoom="10"/>B..
     a83:	f9 f9 81 ef 3f 21 78 2d 62 74 2f 69 6d 61 67 69     ....?!x-bt/imagi
     a93:	6e 67 2d 6d 6f 6e 69 74 6f 72 69 6e 67 2d 69 6d     ng-monitoring-im
     aa3:	61 67 65 00 8c f9 f9 81 ef 0d 4c 00 06 06 01 80     age.......L.....
     ab3:	4b f9                                               K.

00000ab5 <MCA25_START_CAPTURING>:
     ab5:	f9 81 ef 3f 83 00 69 71 00 3f 3c 6d 6f 6e 69 74     ...?..iq.?<monit
     ac5:	6f 72 69 6e 67 2d 63 6f 6d 6d 61 6e 64 20 76 65     oring-command ve
     ad5:	72 73 69 8c f9 f9 81 ef 3f 6f 6e 3d 22 31 2e 30     rsi.....?on="1.0
     ae5:	22 20 74 61 6b 65 2d 70 69 63 3d 22 59 45 53 22     " take-pic="YES"
     af5:	20 7a 6f 6f 6d 3d 22 31 8c f9 f9 81 ef 3f 30 22      zoom="1.....?0"
     b05:	2f 3e 42 00 21 78 2d 62 74 2f 69 6d 61 67 69 6e     />B.!x-bt/imagin
     b15:	67 2d 6d 6f 6e 69 74 6f 72 69 6e 67 2d 8c f9 f9     g-monitoring-...
     b25:	81 ef 19 69 6d 61 67 65 00 4c 00 06 06 01 80 50     ...image.L.....P
     b35:	f9                                                  .

00000b36 <MCA25_CONFIG_640x480>:
     b36:	f9 81 ef 3f 82 01 3b 01 00 03 49 01 35 3c 63 61     ...?..;...I.5<ca
     b46:	6d 65 72 61 2d 73 65 74 74 69 6e 67 73 20 76 65     mera-settings ve
     b56:	72 73 69 8c f9 f9 81 ef 3f 6f 6e 3d 22 31 2e 30     rsi.....?on="1.0
     b66:	22 20 77 68 69 74 65 2d 62 61 6c 61 6e 63 65 3d     " white-balance=
     b76:	22 4f 46 46 22 20 63 6f 8c f9 f9 81 ef 3f 6c 6f     "OFF" co.....?lo
     b86:	72 2d 63 6f 6d 70 65 6e 73 61 74 69 6f 6e 3d 22     r-compensation="
     b96:	31 33 22 20 66 75 6e 2d 6c 61 79 65 72 8c f9 f9     13" fun-layer...
     ba6:	81 ef 3f 3d 22 30 22 3e 3c 6d 6f 6e 69 74 6f 72     ..?="0"><monitor
     bb6:	69 6e 67 2d 66 6f 72 6d 61 74 20 65 6e 63 6f 64     ing-format encod
     bc6:	69 6e 8c f9 f9 81 ef 3f 67 3d 22 45 42 4d 50 22     in.....?g="EBMP"
     bd6:	20 70 69 78 65 6c 2d 73 69 7a 65 3d 22 38 30 2a      pixel-size="80*
     be6:	36 30 22 20 63 6f 6c 8c f9 f9 81 ef 3f 6f 72 2d     60" col.....?or-
     bf6:	64 65 70 74 68 3d 22 38 22 2f 3e 0d 0a 3c 74 68     depth="8"/>..<th
     c06:	75 6d 62 6e 61 69 6c 2d 66 6f 72 6d 8c f9 f9 81     umbnail-form....
     c16:	ef 3f 61 74 20 65 6e 63 6f 64 69 6e 67 3d 22 45     .?at encoding="E
     c26:	42 4d 50 22 20 70 69 78 65 6c 2d 73 69 7a 65 3d     BMP" pixel-size=
     c36:	22 8c f9 f9 81 ef 3f 31 30 31 2a 38 30 22 20 63     ".....?101*80" c
     c46:	6f 6c 6f 72 2d 64 65 70 74 68 3d 22 38 22 2f 3e     olor-depth="8"/>
     c56:	0d 0a 3c 6e 61 74 8c f9 f9 81 ef 3f 69 76 65 2d     ..<nat.....?ive-
     c66:	66 6f 72 6d 61 74 20 65 6e 63 6f 64 69 6e 67 3d     format encoding=
     c76:	22 22 20 70 69 78 65 6c 2d 73 69 8c f9 f9 81 ef     "" pixel-si.....
     c86:	3f 7a 65 3d 22 31 36 30 2a 31 32 30 22 2f 3e 0d     ?ze="160*120"/>.
     c96:	0a 3c 2f 63 61 6d 65 72 61 2d 73 65 74 74 69 6e     .</camera-settin
     ca6:	8c f9 f9 81 ef 0b 67 73 3e 0d 0a af f9              ......gs>....

00000cb3 <__c.2081>:
     cb3:	f9 01 ef 0b e3 07 23 0c 01 79 f9 00                 ......#..y..

00000cbf <__c.2039>:
     cbf:	f9 83 ef 31 00                                      ...1.

00000cc4 <__c.2037>:
     cc4:	f9 83 ef 21 00                                      ...!.

00000cc9 <__c.2033>:
     cc9:	f9 83 ef 3f a0 00                                   ...?..

00000ccf <__c.2031>:
     ccf:	f9 83 ef 3f 90 02 00                                ...?...

00000cd6 <__c.2028>:
     cd6:	f9 21 ef 0d 0d 0a 4f 4b 0d 0a 48 f9 00              .!....OK..H..

00000ce3 <__c.1960>:
     ce3:	f9 83 ef 33 79 65 72 3d 22 31 30 22 2f 3e 3c 2f     ...3yer="10"/></
     cf3:	63 61 6d 65 72 61 2d 69 6e 66 6f 3e 00 e4 f9 00     camera-info>....

00000d03 <__c.1958>:
     d03:	90 f9 00                                            ...

00000d06 <__c.1956>:
     d06:	2d 69 6e 66 6f 00                                   -info.

00000d0c <__c.1954>:
     d0c:	14 78 2d 62 74 2f 63 61 6d 65 72 61 00              .x-bt/camera.

00000d19 <__c.1952>:
     d19:	17 42 00                                            .B.

00000d1c <__c.1950>:
     d1c:	f9 81 ef 2f 83 00                                   .../..

00000d22 <__c.1948>:
     d22:	f9 83 ef 07 a0 00 03 c7 f9 00                       ..........

00000d2c <__c.1918>:
     d2c:	f9 83 ef 3f a0 00 1f 10 00 20 00 cb 00 00 00 01     ...?..... ......
     d3c:	4a 00 13 e3 3d 95 45 83 74 4a d7 9e c5 c1 6b e3     J...=.E.tJ....k.
     d4c:	1e de 8e ed f9 00                                   ......

00000d52 <__c.1916>:
     d52:	f9 21 ef 0d 0d 0a 4f 4b 0d 0a 48 f9 00              .!....OK..H..

00000d5f <__c.1914>:
     d5f:	9e c5 c1 6b e3 1e de 8e 61 82 f9 00                 ...k....a...

00000d6b <__c.1912>:
     d6b:	13 e3 3d 95 45 83 74 4a d7 00                       ..=.E.tJ..

00000d75 <__c.1910>:
     d75:	46 00                                               F.

00000d77 <__c.1908>:
     d77:	02 00                                               ..

00000d79 <__c.1906>:
     d79:	1a 10 00                                            ...

00000d7c <__c.1904>:
     d7c:	f9 81 ef 37 80 00                                   ...7..

00000d82 <__c.1902>:
     d82:	f9 01 ef 09 e1 05 83 8d 9a f9 00                    ...........

00000d8d <__c.1900>:
     d8d:	f9 03 ef 09 e3 05 83 8d fb f9 00                    ...........

00000d98 <__c.1898>:
     d98:	f9 81 73 01 60 f9 00                                ..s.`..

00000d9f <__c.1896>:
     d9f:	f9 81 3f 01 ab f9 00                                ..?....

00000da6 <__c.1894>:
     da6:	f9 21 ef 0d 0d 0a 4f 4b 0d 0a 48 f9 00              .!....OK..H..

00000db3 <__c.1892>:
     db3:	f9 23 ef 23 41 54 2b 43 53 43 43 3d 32 2c 31 39     .#.#AT+CSCC=2,19
     dc3:	39 2c 42 39 0d fb f9 00                             9,B9....

00000dcb <__c.1890>:
     dcb:	f9 21 ef 0d 0d 0a 4f 4b 0d 0a 48 f9 00              .!....OK..H..

00000dd8 <__c.1888>:
     dd8:	f9 21 ef 1b 0d 0a 2b 43 53 43 43 3a 20 45 33 0d     .!....+CSCC: E3.
     de8:	0a b0 f9 00                                         ....

00000dec <__c.1886>:
     dec:	f9 23 ef 1d 41 54 2b 43 53 43 43 3d 31 2c 31 39     .#..AT+CSCC=1,19
     dfc:	39 0d 35 f9 00                                      9.5..

00000e01 <__c.1884>:
     e01:	f9 21 ef 0d 0d 0a 4f 4b 0d 0a 48 f9 00              .!....OK..H..

00000e0e <__c.1882>:
     e0e:	f9 23 ef 1b 41 54 2a 45 41 43 53 3d 31 37 2c 31     .#..AT*EACS=17,1
     e1e:	0d d1 f9 00                                         ....

00000e22 <__c.1880>:
     e22:	f9 01 ef 09 e1 05 23 8d 9a f9 00                    ......#....

00000e2d <__c.1878>:
     e2d:	f9 03 ef 09 e1 07 23 0c 01 fb f9 00                 ......#.....

00000e39 <__c.1876>:
     e39:	f9 01 ef 0b e3 07 23 0c 01 79 f9 00                 ......#..y..

00000e45 <__c.1874>:
     e45:	f9 03 ef 09 e3 05 23 8d fb f9 00                    ......#....

00000e50 <__c.1872>:
     e50:	f9 23 73 01 02 f9 00                                .#s....

00000e57 <__c.1870>:
     e57:	f9 23 3f 01 c9 f9 00                                .#?....

00000e5e <__c.1868>:
     e5e:	f9 03 73 01 d7 f9 00                                ..s....

00000e65 <__c.1866>:
     e65:	f9 03 3f 01 1c f9 00                                ..?....

00000e6c <__c.1864>:
     e6c:	0d 0d 0a 4f 4b 0d 0a 00                             ...OK...

00000e74 <__c.1862>:
     e74:	41 54 2b 43 4d 55 58 3d 30 2c 30 2c 37 2c 33 31     AT+CMUX=0,0,7,31
	...

00000e85 <__c.1860>:
     e85:	0d 0d 0a 2b 43 4d 55 58 3a 20 28 30 29 2c 28 30     ...+CMUX: (0),(0
     e95:	29 2c 28 31 2d 37 29 2c 28 33 31 29 2c 28 31 30     ),(1-7),(31),(10
     ea5:	29 2c 28 33 29 2c 28 33 30 29 2c 28 31 30 29 2c     ),(3),(30),(10),
     eb5:	28 31 2d 37 29 0d 00                                (1-7)..

00000ebc <__c.1858>:
     ebc:	41 54 2b 43 4d 55 58 3d 3f 00                       AT+CMUX=?.

00000ec6 <__c.1856>:
     ec6:	0d 0a 4f 4b 0d 0a 00                                ..OK...

00000ecd <__c.1854>:
     ecd:	41 54 2b 49 50 52 3d 34 36 30 38 30 30 00           AT+IPR=460800.

00000edb <__c.1852>:
     edb:	2b 49 50 52 3a 20 28 29 2c 28 31 32 30 30 2c 32     +IPR: (),(1200,2
     eeb:	34 30 30 2c 34 38 30 30 2c 39 36 30 30 2c 31 39     400,4800,9600,19
     efb:	32 30 30 2c 33 38 34 30 30 2c 35 37 36 30 30 2c     200,38400,57600,
     f0b:	34 36 30 38 30 30 29 0d 0a 0d 0a 4f 4b 0d 0a 00     460800)....OK...

00000f1b <__c.1850>:
     f1b:	41 54 2b 49 50 52 3d 3f 00                          AT+IPR=?.

00000f24 <__c.1848>:
     f24:	0d 0d 0a 4f 4b 0d 0a 00                             ...OK...

00000f2c <__c.1846>:
     f2c:	41 54 26 46 00                                      AT&F.

00000f31 <__c.1841>:
     f31:	03 a6 f9 00                                         ....

00000f35 <__c.1839>:
     f35:	f9 81 ef 07 83 00 00                                .......

00000f3c <__ctors_end>:
     f3c:	11 24       	eor	r1, r1
     f3e:	1f be       	out	0x3f, r1	; 63
     f40:	cf e5       	ldi	r28, 0x5F	; 95
     f42:	d8 e0       	ldi	r29, 0x08	; 8
     f44:	de bf       	out	0x3e, r29	; 62
     f46:	cd bf       	out	0x3d, r28	; 61

00000f48 <__do_copy_data>:
     f48:	10 e0       	ldi	r17, 0x00	; 0
     f4a:	a0 e6       	ldi	r26, 0x60	; 96
     f4c:	b0 e0       	ldi	r27, 0x00	; 0
     f4e:	e4 e0       	ldi	r30, 0x04	; 4
     f50:	fd e3       	ldi	r31, 0x3D	; 61
     f52:	02 c0       	rjmp	.+4      	; 0xf58 <.do_copy_data_start>

00000f54 <.do_copy_data_loop>:
     f54:	05 90       	lpm	r0, Z+
     f56:	0d 92       	st	X+, r0

00000f58 <.do_copy_data_start>:
     f58:	a4 37       	cpi	r26, 0x74	; 116
     f5a:	b1 07       	cpc	r27, r17
     f5c:	d9 f7       	brne	.-10     	; 0xf54 <.do_copy_data_loop>

00000f5e <__do_clear_bss>:
     f5e:	15 e0       	ldi	r17, 0x05	; 5
     f60:	a4 e7       	ldi	r26, 0x74	; 116
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	01 c0       	rjmp	.+2      	; 0xf68 <.do_clear_bss_start>

00000f66 <.do_clear_bss_loop>:
     f66:	1d 92       	st	X+, r1

00000f68 <.do_clear_bss_start>:
     f68:	a4 3a       	cpi	r26, 0xA4	; 164
     f6a:	b1 07       	cpc	r27, r17
     f6c:	e1 f7       	brne	.-8      	; 0xf66 <.do_clear_bss_loop>
     f6e:	0e 94 e6 07 	call	0xfcc	; 0xfcc <main>
     f72:	0c 94 81 1e 	jmp	0x3d02	; 0x3d02 <_exit>

00000f76 <__bad_interrupt>:
     f76:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000f7a <initTimer>:

static unsigned char timerCounter;

void initTimer(void)
{
  TCCR0=5; //outp( 5, TCCR0 ) ;  // timer0 prescale 1/1024
     f7a:	85 e0       	ldi	r24, 0x05	; 5
     f7c:	83 bf       	out	0x33, r24	; 51

  // interrupt on overflow
  TIMSK|=(1<<TOIE0); //sbi( TIMSK, TOIE0 ) ;
     f7e:	89 b7       	in	r24, 0x39	; 57
     f80:	81 60       	ori	r24, 0x01	; 1
     f82:	89 bf       	out	0x39, r24	; 57
  timerCounter = 0;
     f84:	10 92 74 00 	sts	0x0074, r1
     f88:	08 95       	ret

00000f8a <__vector_11>:
#ifdef __IMAGECRAFT__
#pragma interrupt_handler SIG_OVERFLOW0:iv_TIMER0_OVF
#endif

SIGNAL(SIG_OVERFLOW0)
{
     f8a:	1f 92       	push	r1
     f8c:	0f 92       	push	r0
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	0f 92       	push	r0
     f92:	11 24       	eor	r1, r1
     f94:	8f 93       	push	r24
     f96:	9f 93       	push	r25
  timerCounter++;
     f98:	80 91 74 00 	lds	r24, 0x0074
     f9c:	8f 5f       	subi	r24, 0xFF	; 255
     f9e:	80 93 74 00 	sts	0x0074, r24
  if((unsigned char)!(timerCounter&3)) if (usart_timeout) usart_timeout--;
     fa2:	99 27       	eor	r25, r25
     fa4:	83 70       	andi	r24, 0x03	; 3
     fa6:	90 70       	andi	r25, 0x00	; 0
     fa8:	89 2b       	or	r24, r25
     faa:	49 f4       	brne	.+18     	; 0xfbe <__vector_11+0x34>
     fac:	80 91 e8 00 	lds	r24, 0x00E8
     fb0:	88 23       	and	r24, r24
     fb2:	29 f0       	breq	.+10     	; 0xfbe <__vector_11+0x34>
     fb4:	80 91 e8 00 	lds	r24, 0x00E8
     fb8:	81 50       	subi	r24, 0x01	; 1
     fba:	80 93 e8 00 	sts	0x00E8, r24
     fbe:	9f 91       	pop	r25
     fc0:	8f 91       	pop	r24
     fc2:	0f 90       	pop	r0
     fc4:	0f be       	out	0x3f, r0	; 63
     fc6:	0f 90       	pop	r0
     fc8:	1f 90       	pop	r1
     fca:	18 95       	reti

00000fcc <main>:
*  Main Control Loop
*
*  
*****************************************************************************/
int main(void)
{
     fcc:	cf e5       	ldi	r28, 0x5F	; 95
     fce:	d8 e0       	ldi	r29, 0x08	; 8
     fd0:	de bf       	out	0x3e, r29	; 62
     fd2:	cd bf       	out	0x3d, r28	; 61
 	//led PB4
	// Pins als Ausgänge definieren:
	DDRB  |= (1 << 4);
     fd4:	bc 9a       	sbi	0x17, 4	; 23

    PORTB |= (0 << 4);
     fd6:	88 b3       	in	r24, 0x18	; 24
     fd8:	88 bb       	out	0x18, r24	; 24
  
  unsigned char i;
  unsigned char arptimer=0;

   // init NIC device driver
  nic_init();
     fda:	0e 94 83 13 	call	0x2706	; 0x2706 <nic_init>

  // init uIP
  uip_init();
     fde:	0e 94 86 13 	call	0x270c	; 0x270c <uip_init>

  // init app
  services_init();
     fe2:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <services_init>

  // init ARP cache
  uip_arp_init();
     fe6:	0e 94 0c 1b 	call	0x3618	; 0x3618 <uip_arp_init>

static unsigned char timerCounter;

void initTimer(void)
{
  TCCR0=5; //outp( 5, TCCR0 ) ;  // timer0 prescale 1/1024
     fea:	85 e0       	ldi	r24, 0x05	; 5
     fec:	83 bf       	out	0x33, r24	; 51

  // interrupt on overflow
  TIMSK|=(1<<TOIE0); //sbi( TIMSK, TOIE0 ) ;
     fee:	89 b7       	in	r24, 0x39	; 57
     ff0:	81 60       	ori	r24, 0x01	; 1
     ff2:	89 bf       	out	0x39, r24	; 57
  timerCounter = 0;
     ff4:	10 92 74 00 	sts	0x0074, r1
  uip_arp_init();

  // init periodic timer
  initTimer();

  SET_USART_9600();
     ff8:	60 e0       	ldi	r22, 0x00	; 0
     ffa:	8f e5       	ldi	r24, 0x5F	; 95
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0e 94 76 0b 	call	0x16ec	; 0x16ec <USART_Init>
  //PORTB |= (1 << 4); //LED PB4 ein
  sei();
    1002:	78 94       	sei

    // print error message?;
//  }
#if USE_MCA25_CAM
//DEBUG:
	MCA25_ERROR_LED_OFF();
    1004:	95 9a       	sbi	0x12, 5	; 18
	MCA25_CLOCK_LED_OFF();
    1006:	94 9a       	sbi	0x12, 4	; 18
	//DDRB = 0xFF;
	
	MCA25_STATUS_LED_ON();
    1008:	93 98       	cbi	0x12, 3	; 18
	mca25_init();
    100a:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <mca25_init>
	mca25_configure();	
    100e:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <mca25_configure>
	MCA25_STATUS_LED_OFF();
    1012:	93 9a       	sbi	0x12, 3	; 18
	MCA25_ERROR_LED_ON();
    1014:	95 98       	cbi	0x12, 5	; 18
	MCA25_CLOCK_LED_ON();
    1016:	94 98       	cbi	0x12, 4	; 18
#endif	
//	#if USE_CLOCK
//		Start_Clock();
	//#endif  
#if USE_SERVO
	servo_init();
    1018:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <servo_init>
    101c:	ff 24       	eor	r15, r15
    if(uip_len == 0)
    {
      // if timed out, call periodic function for each connection
      if(timerCounter > TIMERCOUNTER_PERIODIC_TIMEOUT)
      {
        timerCounter = 0;
    101e:	87 ef       	ldi	r24, 0xF7	; 247
    1020:	c8 2e       	mov	r12, r24
    1022:	82 e0       	ldi	r24, 0x02	; 2
    1024:	d8 2e       	mov	r13, r24
#endif	
//PORTD |= (1 << 7);
  while(1)
  {
    // look for a packet
    uip_len = nic_poll();
    1026:	0e 94 39 13 	call	0x2672	; 0x2672 <nic_poll>
    102a:	90 93 eb 02 	sts	0x02EB, r25
    102e:	80 93 ea 02 	sts	0x02EA, r24
    if(uip_len == 0)
    1032:	80 91 ea 02 	lds	r24, 0x02EA
    1036:	90 91 eb 02 	lds	r25, 0x02EB
    103a:	89 2b       	or	r24, r25
    103c:	29 f5       	brne	.+74     	; 0x1088 <main+0xbc>
    {
      // if timed out, call periodic function for each connection
      if(timerCounter > TIMERCOUNTER_PERIODIC_TIMEOUT)
    103e:	80 91 74 00 	lds	r24, 0x0074
    1042:	8d 31       	cpi	r24, 0x1D	; 29
    1044:	80 f3       	brcs	.-32     	; 0x1026 <main+0x5a>
      {
        timerCounter = 0;
    1046:	10 92 74 00 	sts	0x0074, r1
    104a:	e6 01       	movw	r28, r12
        
        for(i = 0; i < UIP_CONNS; i++)
        {
          uip_periodic(i);
    104c:	d0 93 f6 02 	sts	0x02F6, r29
    1050:	c0 93 f5 02 	sts	0x02F5, r28
    1054:	82 e0       	ldi	r24, 0x02	; 2
    1056:	0e 94 b2 14 	call	0x2964	; 0x2964 <uip_process>
		
          // transmit a packet, if one is ready
          if(uip_len > 0)
    105a:	80 91 ea 02 	lds	r24, 0x02EA
    105e:	90 91 eb 02 	lds	r25, 0x02EB
    1062:	89 2b       	or	r24, r25
    1064:	21 f0       	breq	.+8      	; 0x106e <main+0xa2>
          {
            uip_arp_out();
    1066:	0e 94 21 1b 	call	0x3642	; 0x3642 <uip_arp_out>
            nic_send();
    106a:	0e 94 54 13 	call	0x26a8	; 0x26a8 <nic_send>
    106e:	a3 96       	adiw	r28, 0x23	; 35
      // if timed out, call periodic function for each connection
      if(timerCounter > TIMERCOUNTER_PERIODIC_TIMEOUT)
      {
        timerCounter = 0;
        
        for(i = 0; i < UIP_CONNS; i++)
    1070:	83 e0       	ldi	r24, 0x03	; 3
    1072:	c0 36       	cpi	r28, 0x60	; 96
    1074:	d8 07       	cpc	r29, r24
    1076:	51 f7       	brne	.-44     	; 0x104c <main+0x80>
            nic_send();
          }
        }

        /* Call the ARP timer function every 10 seconds. */
        if(++arptimer == 20)
    1078:	f3 94       	inc	r15
    107a:	84 e1       	ldi	r24, 0x14	; 20
    107c:	f8 16       	cp	r15, r24
    107e:	99 f6       	brne	.-90     	; 0x1026 <main+0x5a>
        {	
          uip_arp_timer();
    1080:	0e 94 df 1a 	call	0x35be	; 0x35be <uip_arp_timer>
    1084:	ff 24       	eor	r15, r15
    1086:	cf cf       	rjmp	.-98     	; 0x1026 <main+0x5a>
      }
    }
    else  // packet received
    {
      // process an IP packet
      if(BUF->type == htons(UIP_ETHTYPE_IP))
    1088:	00 91 76 03 	lds	r16, 0x0376
    108c:	10 91 77 03 	lds	r17, 0x0377
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	98 e0       	ldi	r25, 0x08	; 8
    1094:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <htons>
    1098:	08 17       	cp	r16, r24
    109a:	19 07       	cpc	r17, r25
    109c:	79 f4       	brne	.+30     	; 0x10bc <main+0xf0>
      {
        // add the source to the ARP cache
        // also correctly set the ethernet packet length before processing
        uip_arp_ipin();
    109e:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uip_arp_ipin>
        uip_input();
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	0e 94 b2 14 	call	0x2964	; 0x2964 <uip_process>

        // transmit a packet, if one is ready
        if(uip_len > 0)
    10a8:	80 91 ea 02 	lds	r24, 0x02EA
    10ac:	90 91 eb 02 	lds	r25, 0x02EB
    10b0:	89 2b       	or	r24, r25
    10b2:	09 f4       	brne	.+2      	; 0x10b6 <main+0xea>
    10b4:	b8 cf       	rjmp	.-144    	; 0x1026 <main+0x5a>
        {
          uip_arp_out();
    10b6:	0e 94 21 1b 	call	0x3642	; 0x3642 <uip_arp_out>
    10ba:	15 c0       	rjmp	.+42     	; 0x10e6 <main+0x11a>
          nic_send();
        }
      }
      // process an ARP packet
      else if(BUF->type == htons(UIP_ETHTYPE_ARP))
    10bc:	00 91 76 03 	lds	r16, 0x0376
    10c0:	10 91 77 03 	lds	r17, 0x0377
    10c4:	86 e0       	ldi	r24, 0x06	; 6
    10c6:	98 e0       	ldi	r25, 0x08	; 8
    10c8:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <htons>
    10cc:	08 17       	cp	r16, r24
    10ce:	19 07       	cpc	r17, r25
    10d0:	09 f0       	breq	.+2      	; 0x10d4 <main+0x108>
    10d2:	a9 cf       	rjmp	.-174    	; 0x1026 <main+0x5a>
      {
        uip_arp_arpin();
    10d4:	0e 94 a1 1c 	call	0x3942	; 0x3942 <uip_arp_arpin>

        // transmit a packet, if one is ready
        if(uip_len > 0)
    10d8:	80 91 ea 02 	lds	r24, 0x02EA
    10dc:	90 91 eb 02 	lds	r25, 0x02EB
    10e0:	89 2b       	or	r24, r25
    10e2:	09 f4       	brne	.+2      	; 0x10e6 <main+0x11a>
    10e4:	a0 cf       	rjmp	.-192    	; 0x1026 <main+0x5a>
          nic_send();
    10e6:	0e 94 54 13 	call	0x26a8	; 0x26a8 <nic_send>
    10ea:	9d cf       	rjmp	.-198    	; 0x1026 <main+0x5a>

000010ec <strncmp_PP>:
 return !strncmp_P((const char*)uip_appdata+uip_datalen()-4,PSTR("\r\n\r\n"),4);
}


u8_t strncmp_PP(prog_char* ptr1, prog_char* ptr2, u8_t len)
{
    10ec:	9c 01       	movw	r18, r24
    10ee:	0d c0       	rjmp	.+26     	; 0x110a <strncmp_PP+0x1e>
 while(len--) if (pgm_read_byte(ptr1++)!=pgm_read_byte(ptr2++)) return 1;
    10f0:	f9 01       	movw	r30, r18
    10f2:	94 91       	lpm	r25, Z+
    10f4:	fb 01       	movw	r30, r22
    10f6:	84 91       	lpm	r24, Z+
    10f8:	98 17       	cp	r25, r24
    10fa:	19 f0       	breq	.+6      	; 0x1102 <strncmp_PP+0x16>
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	08 95       	ret
    1102:	2f 5f       	subi	r18, 0xFF	; 255
    1104:	3f 4f       	sbci	r19, 0xFF	; 255
    1106:	6f 5f       	subi	r22, 0xFF	; 255
    1108:	7f 4f       	sbci	r23, 0xFF	; 255
    110a:	41 50       	subi	r20, 0x01	; 1
    110c:	88 f7       	brcc	.-30     	; 0x10f0 <strncmp_PP+0x4>
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	90 e0       	ldi	r25, 0x00	; 0
 return 0;
}
    1112:	08 95       	ret

00001114 <sendhtml_P>:
 uip_send(uip_appdata,dataleft);
}


prog_char* sendhtml_P(struct http_state* s)
{
    1114:	ef 92       	push	r14
    1116:	ff 92       	push	r15
    1118:	0f 93       	push	r16
    111a:	1f 93       	push	r17
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
 u16_t i;
 prog_char* ptr=s->dataptr_P;
    1120:	fc 01       	movw	r30, r24
    1122:	c1 81       	ldd	r28, Z+1	; 0x01
    1124:	d2 81       	ldd	r29, Z+2	; 0x02
    1126:	00 e0       	ldi	r16, 0x00	; 0
    1128:	10 e0       	ldi	r17, 0x00	; 0
    112a:	8e ef       	ldi	r24, 0xFE	; 254
    112c:	e8 2e       	mov	r14, r24
    112e:	89 e0       	ldi	r24, 0x09	; 9
    1130:	f8 2e       	mov	r15, r24
    1132:	1a c0       	rjmp	.+52     	; 0x1168 <sendhtml_P+0x54>
 
 for (i=0; i<uip_mss(); i++) {
  if ((*(uip_appdata+i)=pgm_read_byte(ptr++)) =='%') {
    1134:	a0 91 f3 02 	lds	r26, 0x02F3
    1138:	b0 91 f4 02 	lds	r27, 0x02F4
    113c:	a0 0f       	add	r26, r16
    113e:	b1 1f       	adc	r27, r17
    1140:	ce 01       	movw	r24, r28
    1142:	21 96       	adiw	r28, 0x01	; 1
    1144:	fc 01       	movw	r30, r24
    1146:	84 91       	lpm	r24, Z+
    1148:	8c 93       	st	X, r24
    114a:	8c 91       	ld	r24, X
    114c:	85 32       	cpi	r24, 0x25	; 37
    114e:	51 f4       	brne	.+20     	; 0x1164 <sendhtml_P+0x50>
    if (strncmp_PP((prog_char*)PSTR("EOF"),ptr,3) == 0) {ptr=(prog_char*)0; break;}
    1150:	43 e0       	ldi	r20, 0x03	; 3
    1152:	be 01       	movw	r22, r28
    1154:	c7 01       	movw	r24, r14
    1156:	0e 94 76 08 	call	0x10ec	; 0x10ec <strncmp_PP>
    115a:	88 23       	and	r24, r24
    115c:	19 f4       	brne	.+6      	; 0x1164 <sendhtml_P+0x50>
    115e:	c0 e0       	ldi	r28, 0x00	; 0
    1160:	d0 e0       	ldi	r29, 0x00	; 0
    1162:	0b c0       	rjmp	.+22     	; 0x117a <sendhtml_P+0x66>
prog_char* sendhtml_P(struct http_state* s)
{
 u16_t i;
 prog_char* ptr=s->dataptr_P;
 
 for (i=0; i<uip_mss(); i++) {
    1164:	0f 5f       	subi	r16, 0xFF	; 255
    1166:	1f 4f       	sbci	r17, 0xFF	; 255
    1168:	e0 91 f5 02 	lds	r30, 0x02F5
    116c:	f0 91 f6 02 	lds	r31, 0x02F6
    1170:	82 89       	ldd	r24, Z+18	; 0x12
    1172:	93 89       	ldd	r25, Z+19	; 0x13
    1174:	08 17       	cp	r16, r24
    1176:	19 07       	cpc	r17, r25
    1178:	e8 f2       	brcs	.-70     	; 0x1134 <sendhtml_P+0x20>
  if ((*(uip_appdata+i)=pgm_read_byte(ptr++)) =='%') {
    if (strncmp_PP((prog_char*)PSTR("EOF"),ptr,3) == 0) {ptr=(prog_char*)0; break;}
  }
 }
 if (i) uip_send(uip_appdata,i);
    117a:	01 15       	cp	r16, r1
    117c:	11 05       	cpc	r17, r1
    117e:	61 f0       	breq	.+24     	; 0x1198 <sendhtml_P+0x84>
    1180:	80 91 f3 02 	lds	r24, 0x02F3
    1184:	90 91 f4 02 	lds	r25, 0x02F4
    1188:	90 93 ed 02 	sts	0x02ED, r25
    118c:	80 93 ec 02 	sts	0x02EC, r24
    1190:	10 93 a3 05 	sts	0x05A3, r17
    1194:	00 93 a2 05 	sts	0x05A2, r16
 return ptr;
}
    1198:	ce 01       	movw	r24, r28
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	1f 91       	pop	r17
    11a0:	0f 91       	pop	r16
    11a2:	ff 90       	pop	r15
    11a4:	ef 90       	pop	r14
    11a6:	08 95       	ret

000011a8 <services_init>:
}


void services_init(void) {
   
   uip_listen(HTONS(80));
    11a8:	80 e0       	ldi	r24, 0x00	; 0
    11aa:	90 e5       	ldi	r25, 0x50	; 80
    11ac:	0e 94 cc 13 	call	0x2798	; 0x2798 <uip_listen>
    11b0:	08 95       	ret

000011b2 <chk4getend>:
"WWW-Authenticate: Basic realm=\"NeedPassword\""
"\r\nContent-Type: text/html\r\n\r\n"};
*/

u8_t chk4getend(void) {
 if (uip_datalen()<5) return 1;
    11b2:	80 91 ea 02 	lds	r24, 0x02EA
    11b6:	90 91 eb 02 	lds	r25, 0x02EB
    11ba:	05 97       	sbiw	r24, 0x05	; 5
    11bc:	a8 f0       	brcs	.+42     	; 0x11e8 <chk4getend+0x36>
 return !strncmp_P((const char*)uip_appdata+uip_datalen()-4,PSTR("\r\n\r\n"),4);
    11be:	80 91 ea 02 	lds	r24, 0x02EA
    11c2:	90 91 eb 02 	lds	r25, 0x02EB
    11c6:	20 91 f3 02 	lds	r18, 0x02F3
    11ca:	30 91 f4 02 	lds	r19, 0x02F4
    11ce:	82 0f       	add	r24, r18
    11d0:	93 1f       	adc	r25, r19
    11d2:	44 e0       	ldi	r20, 0x04	; 4
    11d4:	50 e0       	ldi	r21, 0x00	; 0
    11d6:	62 e0       	ldi	r22, 0x02	; 2
    11d8:	7a e0       	ldi	r23, 0x0A	; 10
    11da:	04 97       	sbiw	r24, 0x04	; 4
    11dc:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    11e0:	20 e0       	ldi	r18, 0x00	; 0
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	89 2b       	or	r24, r25
    11e6:	11 f4       	brne	.+4      	; 0x11ec <chk4getend+0x3a>
    11e8:	21 e0       	ldi	r18, 0x01	; 1
    11ea:	30 e0       	ldi	r19, 0x00	; 0
}
    11ec:	c9 01       	movw	r24, r18
    11ee:	08 95       	ret

000011f0 <start_pic_trans>:
 if (i) uip_send(uip_appdata,i);
 return ptr;
}


void start_pic_trans(struct http_state* s,unsigned int *len) {
    11f0:	ef 92       	push	r14
    11f2:	ff 92       	push	r15
    11f4:	0f 93       	push	r16
    11f6:	1f 93       	push	r17
    11f8:	cf 93       	push	r28
    11fa:	df 93       	push	r29
    11fc:	ec 01       	movw	r28, r24
    11fe:	7b 01       	movw	r14, r22
 if (chk4getend()) {
    1200:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <chk4getend>
    1204:	88 23       	and	r24, r24
    1206:	29 f1       	breq	.+74     	; 0x1252 <start_pic_trans+0x62>
   if (mca25_stat.init) {
    1208:	90 91 e7 00 	lds	r25, 0x00E7
    120c:	89 2f       	mov	r24, r25
    120e:	87 70       	andi	r24, 0x07	; 7
    1210:	11 f0       	breq	.+4      	; 0x1216 <start_pic_trans+0x26>
     // do something here - create a message for user
     uip_abort();
    1212:	80 e2       	ldi	r24, 0x20	; 32
    1214:	03 c0       	rjmp	.+6      	; 0x121c <start_pic_trans+0x2c>
     return;
   }
   if (mca25_stat.busy) {
    1216:	93 ff       	sbrs	r25, 3
    1218:	04 c0       	rjmp	.+8      	; 0x1222 <start_pic_trans+0x32>
     uip_close();
    121a:	80 e1       	ldi	r24, 0x10	; 16
    121c:	80 93 f2 02 	sts	0x02F2, r24
    1220:	18 c0       	rjmp	.+48     	; 0x1252 <start_pic_trans+0x62>
     return;
   }
   s->state=HTTP_PIC;
    1222:	86 e0       	ldi	r24, 0x06	; 6
    1224:	88 83       	st	Y, r24
   mca25_stat.busy=1;
    1226:	80 91 e7 00 	lds	r24, 0x00E7
    122a:	88 60       	ori	r24, 0x08	; 8
    122c:	80 93 e7 00 	sts	0x00E7, r24
   mca25_copy_data(mca25_buf,len);
    1230:	09 ee       	ldi	r16, 0xE9	; 233
    1232:	10 e0       	ldi	r17, 0x00	; 0
    1234:	b7 01       	movw	r22, r14
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <mca25_copy_data>
   uip_send(mca25_buf,*len);
    123c:	10 93 ed 02 	sts	0x02ED, r17
    1240:	00 93 ec 02 	sts	0x02EC, r16
    1244:	f7 01       	movw	r30, r14
    1246:	80 81       	ld	r24, Z
    1248:	91 81       	ldd	r25, Z+1	; 0x01
    124a:	90 93 a3 05 	sts	0x05A3, r25
    124e:	80 93 a2 05 	sts	0x05A2, r24
    1252:	df 91       	pop	r29
    1254:	cf 91       	pop	r28
    1256:	1f 91       	pop	r17
    1258:	0f 91       	pop	r16
    125a:	ff 90       	pop	r15
    125c:	ef 90       	pop	r14
    125e:	08 95       	ret

00001260 <sendraw_P>:
 return 0;
}


void sendraw_P(prog_char* dataptr_P, u16_t dataleft)
{
    1260:	cf 93       	push	r28
    1262:	df 93       	push	r29
    1264:	eb 01       	movw	r28, r22
 memcpy_P((u8_t*)uip_appdata,dataptr_P,(dataleft>uip_mss())?uip_mss():dataleft);
    1266:	e0 91 f5 02 	lds	r30, 0x02F5
    126a:	f0 91 f6 02 	lds	r31, 0x02F6
    126e:	22 89       	ldd	r18, Z+18	; 0x12
    1270:	33 89       	ldd	r19, Z+19	; 0x13
    1272:	ab 01       	movw	r20, r22
    1274:	26 17       	cp	r18, r22
    1276:	37 07       	cpc	r19, r23
    1278:	08 f4       	brcc	.+2      	; 0x127c <sendraw_P+0x1c>
    127a:	a9 01       	movw	r20, r18
    127c:	bc 01       	movw	r22, r24
    127e:	80 91 f3 02 	lds	r24, 0x02F3
    1282:	90 91 f4 02 	lds	r25, 0x02F4
    1286:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <memcpy_P>
 uip_send(uip_appdata,dataleft);
    128a:	80 91 f3 02 	lds	r24, 0x02F3
    128e:	90 91 f4 02 	lds	r25, 0x02F4
    1292:	90 93 ed 02 	sts	0x02ED, r25
    1296:	80 93 ec 02 	sts	0x02EC, r24
    129a:	d0 93 a3 05 	sts	0x05A3, r29
    129e:	c0 93 a2 05 	sts	0x05A2, r28
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	08 95       	ret

000012a8 <httpd>:
   uip_send(mca25_buf,*len);
 }
}


void httpd(void) {
    12a8:	ef 92       	push	r14
    12aa:	ff 92       	push	r15
    12ac:	0f 93       	push	r16
    12ae:	1f 93       	push	r17
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
   
   static unsigned int len=0;
   static char ret=1;
  
   struct http_state *s;
   s = (struct http_state *)uip_conn->appstate;
    12b4:	e0 90 f5 02 	lds	r14, 0x02F5
    12b8:	f0 90 f6 02 	lds	r15, 0x02F6
    12bc:	e7 01       	movw	r28, r14
    12be:	6c 96       	adiw	r28, 0x1c	; 28

   if(uip_connected()) {
    12c0:	80 91 f2 02 	lds	r24, 0x02F2
    12c4:	86 ff       	sbrs	r24, 6
    12c6:	03 c0       	rjmp	.+6      	; 0x12ce <httpd+0x26>
     s->state=HTTP_NOGET;
    12c8:	f7 01       	movw	r30, r14
    12ca:	14 8e       	std	Z+28, r1	; 0x1c
    12cc:	e2 c1       	rjmp	.+964    	; 0x1692 <httpd+0x3ea>
     return;
   }
   
   if(uip_newdata()) {
    12ce:	80 91 f2 02 	lds	r24, 0x02F2
    12d2:	81 ff       	sbrs	r24, 1
    12d4:	48 c1       	rjmp	.+656    	; 0x1566 <httpd+0x2be>
     switch (s->state) {
    12d6:	f7 01       	movw	r30, r14
    12d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    12da:	81 30       	cpi	r24, 0x01	; 1
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <httpd+0x38>
    12de:	39 c1       	rjmp	.+626    	; 0x1552 <httpd+0x2aa>
    12e0:	81 30       	cpi	r24, 0x01	; 1
    12e2:	38 f0       	brcs	.+14     	; 0x12f2 <httpd+0x4a>
    12e4:	84 30       	cpi	r24, 0x04	; 4
    12e6:	09 f4       	brne	.+2      	; 0x12ea <httpd+0x42>
    12e8:	20 c1       	rjmp	.+576    	; 0x152a <httpd+0x282>
    12ea:	85 30       	cpi	r24, 0x05	; 5
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <httpd+0x48>
    12ee:	3b c1       	rjmp	.+630    	; 0x1566 <httpd+0x2be>
    12f0:	35 c1       	rjmp	.+618    	; 0x155c <httpd+0x2b4>

     case HTTP_NOGET:
      if (strncmp_P((const char*)uip_appdata,PSTR("GET /"),5)) uip_abort();
    12f2:	00 91 f3 02 	lds	r16, 0x02F3
    12f6:	10 91 f4 02 	lds	r17, 0x02F4
    12fa:	45 e0       	ldi	r20, 0x05	; 5
    12fc:	50 e0       	ldi	r21, 0x00	; 0
    12fe:	68 ef       	ldi	r22, 0xF8	; 248
    1300:	79 e0       	ldi	r23, 0x09	; 9
    1302:	c8 01       	movw	r24, r16
    1304:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1308:	89 2b       	or	r24, r25
    130a:	19 f0       	breq	.+6      	; 0x1312 <httpd+0x6a>
    130c:	80 e2       	ldi	r24, 0x20	; 32
    130e:	80 93 f2 02 	sts	0x02F2, r24
         }
	 uip_abort();
         break;  
      }
*/
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("sesam.html"),7)) {
    1312:	0b 5f       	subi	r16, 0xFB	; 251
    1314:	1f 4f       	sbci	r17, 0xFF	; 255
    1316:	47 e0       	ldi	r20, 0x07	; 7
    1318:	50 e0       	ldi	r21, 0x00	; 0
    131a:	6d ee       	ldi	r22, 0xED	; 237
    131c:	79 e0       	ldi	r23, 0x09	; 9
    131e:	c8 01       	movw	r24, r16
    1320:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1324:	89 2b       	or	r24, r25
    1326:	21 f4       	brne	.+8      	; 0x1330 <httpd+0x88>
         s->state=HTTP_GET;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	f7 01       	movw	r30, r14
    132c:	84 8f       	std	Z+28, r24	; 0x1c
    132e:	11 c1       	rjmp	.+546    	; 0x1552 <httpd+0x2aa>
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         }
         break;  
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("picture.jpg"),7)) {
    1330:	47 e0       	ldi	r20, 0x07	; 7
    1332:	50 e0       	ldi	r21, 0x00	; 0
    1334:	61 ee       	ldi	r22, 0xE1	; 225
    1336:	79 e0       	ldi	r23, 0x09	; 9
    1338:	c8 01       	movw	r24, r16
    133a:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    133e:	89 2b       	or	r24, r25
    1340:	21 f4       	brne	.+8      	; 0x134a <httpd+0xa2>
         
         s->state=HTTP_GET_PIC;
    1342:	85 e0       	ldi	r24, 0x05	; 5
    1344:	f7 01       	movw	r30, r14
    1346:	84 8f       	std	Z+28, r24	; 0x1c
    1348:	09 c1       	rjmp	.+530    	; 0x155c <httpd+0x2b4>
         start_pic_trans(s,&len);
         break;
      }
// schalten
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("yaqwsx"),3) ) {
    134a:	43 e0       	ldi	r20, 0x03	; 3
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	6a ed       	ldi	r22, 0xDA	; 218
    1350:	79 e0       	ldi	r23, 0x09	; 9
    1352:	c8 01       	movw	r24, r16
    1354:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1358:	89 2b       	or	r24, r25
    135a:	71 f4       	brne	.+28     	; 0x1378 <httpd+0xd0>
           PORTB |= (1 << 4);
    135c:	c4 9a       	sbi	0x18, 4	; 24
		   s->dataptr_P=(prog_char*)index_html;
    135e:	84 e5       	ldi	r24, 0x54	; 84
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	9a 83       	std	Y+2, r25	; 0x02
    1364:	89 83       	std	Y+1, r24	; 0x01
           s->state=HTTP_FILE;
    1366:	82 e0       	ldi	r24, 0x02	; 2
    1368:	f7 01       	movw	r30, r14
    136a:	84 8f       	std	Z+28, r24	; 0x1c
           s->nxtdatptr_P=sendhtml_P(s);
    136c:	ce 01       	movw	r24, r28
    136e:	0e 94 8a 08 	call	0x1114	; 0x1114 <sendhtml_P>
    1372:	9e 83       	std	Y+6, r25	; 0x06
    1374:	8d 83       	std	Y+5, r24	; 0x05
    1376:	f7 c0       	rjmp	.+494    	; 0x1566 <httpd+0x2be>
         break;
      }
	   if (!strncmp_P((const char*)uip_appdata+5,PSTR("cderfv"),3) ) {
    1378:	43 e0       	ldi	r20, 0x03	; 3
    137a:	50 e0       	ldi	r21, 0x00	; 0
    137c:	63 ed       	ldi	r22, 0xD3	; 211
    137e:	79 e0       	ldi	r23, 0x09	; 9
    1380:	c8 01       	movw	r24, r16
    1382:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1386:	89 2b       	or	r24, r25
    1388:	11 f4       	brne	.+4      	; 0x138e <httpd+0xe6>
           PORTB &= ~(1 << 4);
    138a:	c4 98       	cbi	0x18, 4	; 24
    138c:	e8 cf       	rjmp	.-48     	; 0x135e <httpd+0xb6>
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }

//SERVO TEST
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("000"),3) ) {
    138e:	43 e0       	ldi	r20, 0x03	; 3
    1390:	50 e0       	ldi	r21, 0x00	; 0
    1392:	6f ec       	ldi	r22, 0xCF	; 207
    1394:	79 e0       	ldi	r23, 0x09	; 9
    1396:	c8 01       	movw	r24, r16
    1398:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    139c:	89 2b       	or	r24, r25
    139e:	41 f4       	brne	.+16     	; 0x13b0 <httpd+0x108>
		unsigned char val = (unsigned char)atoi(PSTR("000")+6);
    13a0:	81 ed       	ldi	r24, 0xD1	; 209
    13a2:	99 e0       	ldi	r25, 0x09	; 9
    13a4:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
    	   servo_prepare_pos(val); 
    13a8:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
           servo_set_pos(0);
    13ac:	80 e0       	ldi	r24, 0x00	; 0
    13ae:	10 c0       	rjmp	.+32     	; 0x13d0 <httpd+0x128>
		   s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
	        if (!strncmp_P((const char*)uip_appdata+5,PSTR("025"),3) ) {
    13b0:	43 e0       	ldi	r20, 0x03	; 3
    13b2:	50 e0       	ldi	r21, 0x00	; 0
    13b4:	67 ec       	ldi	r22, 0xC7	; 199
    13b6:	79 e0       	ldi	r23, 0x09	; 9
    13b8:	c8 01       	movw	r24, r16
    13ba:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    13be:	89 2b       	or	r24, r25
    13c0:	51 f4       	brne	.+20     	; 0x13d6 <httpd+0x12e>
		unsigned char val = (unsigned char)atoi(PSTR("025")+6);
    13c2:	89 ec       	ldi	r24, 0xC9	; 201
    13c4:	99 e0       	ldi	r25, 0x09	; 9
    13c6:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    13ca:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(25);
    13ce:	89 e1       	ldi	r24, 0x19	; 25
    13d0:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <servo_set_pos>
    13d4:	c4 cf       	rjmp	.-120    	; 0x135e <httpd+0xb6>
		   s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("050"),3)) {
    13d6:	43 e0       	ldi	r20, 0x03	; 3
    13d8:	50 e0       	ldi	r21, 0x00	; 0
    13da:	6f eb       	ldi	r22, 0xBF	; 191
    13dc:	79 e0       	ldi	r23, 0x09	; 9
    13de:	c8 01       	movw	r24, r16
    13e0:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    13e4:	89 2b       	or	r24, r25
    13e6:	41 f4       	brne	.+16     	; 0x13f8 <httpd+0x150>
		unsigned char val = (unsigned char)atoi(PSTR("050")+6);
    13e8:	81 ec       	ldi	r24, 0xC1	; 193
    13ea:	99 e0       	ldi	r25, 0x09	; 9
    13ec:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    13f0:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
           servo_set_pos(50);
    13f4:	82 e3       	ldi	r24, 0x32	; 50
    13f6:	87 c0       	rjmp	.+270    	; 0x1506 <httpd+0x25e>
		   s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
	        if (!strncmp_P((const char*)uip_appdata+5,PSTR("075"),3) ) {
    13f8:	43 e0       	ldi	r20, 0x03	; 3
    13fa:	50 e0       	ldi	r21, 0x00	; 0
    13fc:	67 eb       	ldi	r22, 0xB7	; 183
    13fe:	79 e0       	ldi	r23, 0x09	; 9
    1400:	c8 01       	movw	r24, r16
    1402:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1406:	89 2b       	or	r24, r25
    1408:	41 f4       	brne	.+16     	; 0x141a <httpd+0x172>
		unsigned char val = (unsigned char)atoi(PSTR("075")+6);
    140a:	89 eb       	ldi	r24, 0xB9	; 185
    140c:	99 e0       	ldi	r25, 0x09	; 9
    140e:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    1412:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
           servo_set_pos(75);
    1416:	8b e4       	ldi	r24, 0x4B	; 75
    1418:	76 c0       	rjmp	.+236    	; 0x1506 <httpd+0x25e>
		   s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
	        if (!strncmp_P((const char*)uip_appdata+5,PSTR("100"),3) ) {
    141a:	43 e0       	ldi	r20, 0x03	; 3
    141c:	50 e0       	ldi	r21, 0x00	; 0
    141e:	6f ea       	ldi	r22, 0xAF	; 175
    1420:	79 e0       	ldi	r23, 0x09	; 9
    1422:	c8 01       	movw	r24, r16
    1424:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    1428:	89 2b       	or	r24, r25
    142a:	41 f4       	brne	.+16     	; 0x143c <httpd+0x194>
		unsigned char val = (unsigned char)atoi(PSTR("100")+6);
    142c:	81 eb       	ldi	r24, 0xB1	; 177
    142e:	99 e0       	ldi	r25, 0x09	; 9
    1430:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    1434:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
           servo_set_pos(100);
    1438:	84 e6       	ldi	r24, 0x64	; 100
    143a:	65 c0       	rjmp	.+202    	; 0x1506 <httpd+0x25e>
		   s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("125"),3) ) {
    143c:	43 e0       	ldi	r20, 0x03	; 3
    143e:	50 e0       	ldi	r21, 0x00	; 0
    1440:	67 ea       	ldi	r22, 0xA7	; 167
    1442:	79 e0       	ldi	r23, 0x09	; 9
    1444:	c8 01       	movw	r24, r16
    1446:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    144a:	89 2b       	or	r24, r25
    144c:	41 f4       	brne	.+16     	; 0x145e <httpd+0x1b6>
		unsigned char val = (unsigned char)atoi(PSTR("125")+6);
    144e:	89 ea       	ldi	r24, 0xA9	; 169
    1450:	99 e0       	ldi	r25, 0x09	; 9
    1452:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    1456:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
        servo_set_pos(125);
    145a:	8d e7       	ldi	r24, 0x7D	; 125
    145c:	54 c0       	rjmp	.+168    	; 0x1506 <httpd+0x25e>
                    s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
	        if (!strncmp_P((const char*)uip_appdata+5,PSTR("150"),3) ) {
    145e:	43 e0       	ldi	r20, 0x03	; 3
    1460:	50 e0       	ldi	r21, 0x00	; 0
    1462:	6f e9       	ldi	r22, 0x9F	; 159
    1464:	79 e0       	ldi	r23, 0x09	; 9
    1466:	c8 01       	movw	r24, r16
    1468:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    146c:	89 2b       	or	r24, r25
    146e:	41 f4       	brne	.+16     	; 0x1480 <httpd+0x1d8>
		unsigned char val = (unsigned char)atoi(PSTR("150")+6);
    1470:	81 ea       	ldi	r24, 0xA1	; 161
    1472:	99 e0       	ldi	r25, 0x09	; 9
    1474:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    1478:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(150);
    147c:	86 e9       	ldi	r24, 0x96	; 150
    147e:	43 c0       	rjmp	.+134    	; 0x1506 <httpd+0x25e>
           s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("175"),3) ) {
    1480:	43 e0       	ldi	r20, 0x03	; 3
    1482:	50 e0       	ldi	r21, 0x00	; 0
    1484:	67 e9       	ldi	r22, 0x97	; 151
    1486:	79 e0       	ldi	r23, 0x09	; 9
    1488:	c8 01       	movw	r24, r16
    148a:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    148e:	89 2b       	or	r24, r25
    1490:	41 f4       	brne	.+16     	; 0x14a2 <httpd+0x1fa>
		unsigned char val = (unsigned char)atoi(PSTR("175")+6);
    1492:	89 e9       	ldi	r24, 0x99	; 153
    1494:	99 e0       	ldi	r25, 0x09	; 9
    1496:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    149a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(175);
    149e:	8f ea       	ldi	r24, 0xAF	; 175
    14a0:	32 c0       	rjmp	.+100    	; 0x1506 <httpd+0x25e>
           s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("200"),3) ) {
    14a2:	43 e0       	ldi	r20, 0x03	; 3
    14a4:	50 e0       	ldi	r21, 0x00	; 0
    14a6:	6f e8       	ldi	r22, 0x8F	; 143
    14a8:	79 e0       	ldi	r23, 0x09	; 9
    14aa:	c8 01       	movw	r24, r16
    14ac:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    14b0:	89 2b       	or	r24, r25
    14b2:	41 f4       	brne	.+16     	; 0x14c4 <httpd+0x21c>
		unsigned char val = (unsigned char)atoi(PSTR("200")+6);
    14b4:	81 e9       	ldi	r24, 0x91	; 145
    14b6:	99 e0       	ldi	r25, 0x09	; 9
    14b8:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    14bc:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(200);
    14c0:	88 ec       	ldi	r24, 0xC8	; 200
    14c2:	21 c0       	rjmp	.+66     	; 0x1506 <httpd+0x25e>
           s->dataptr_P=(prog_char*)index_html;
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }
      if (!strncmp_P((const char*)uip_appdata+5,PSTR("225"),3) ) {
    14c4:	43 e0       	ldi	r20, 0x03	; 3
    14c6:	50 e0       	ldi	r21, 0x00	; 0
    14c8:	67 e8       	ldi	r22, 0x87	; 135
    14ca:	79 e0       	ldi	r23, 0x09	; 9
    14cc:	c8 01       	movw	r24, r16
    14ce:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    14d2:	89 2b       	or	r24, r25
    14d4:	41 f4       	brne	.+16     	; 0x14e6 <httpd+0x23e>
		unsigned char val = (unsigned char)atoi(PSTR("225")+6);
    14d6:	89 e8       	ldi	r24, 0x89	; 137
    14d8:	99 e0       	ldi	r25, 0x09	; 9
    14da:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    14de:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(225);
    14e2:	81 ee       	ldi	r24, 0xE1	; 225
    14e4:	10 c0       	rjmp	.+32     	; 0x1506 <httpd+0x25e>
           s->state=HTTP_FILE;
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }

      if (!strncmp_P((const char*)uip_appdata+5,PSTR("250"),3) ) {
    14e6:	43 e0       	ldi	r20, 0x03	; 3
    14e8:	50 e0       	ldi	r21, 0x00	; 0
    14ea:	6f e7       	ldi	r22, 0x7F	; 127
    14ec:	79 e0       	ldi	r23, 0x09	; 9
    14ee:	c8 01       	movw	r24, r16
    14f0:	0e 94 64 1e 	call	0x3cc8	; 0x3cc8 <strncmp_P>
    14f4:	89 2b       	or	r24, r25
    14f6:	81 f4       	brne	.+32     	; 0x1518 <httpd+0x270>
		unsigned char val = (unsigned char)atoi(PSTR("250")+6);
    14f8:	81 e8       	ldi	r24, 0x81	; 129
    14fa:	99 e0       	ldi	r25, 0x09	; 9
    14fc:	0e 94 3d 1e 	call	0x3c7a	; 0x3c7a <atoi>
			servo_prepare_pos(val); 
    1500:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <servo_prepare_pos>
            servo_set_pos(250);
    1504:	8a ef       	ldi	r24, 0xFA	; 250
    1506:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <servo_set_pos>
           s->dataptr_P=(prog_char*)index_html;
    150a:	84 e5       	ldi	r24, 0x54	; 84
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	9a 83       	std	Y+2, r25	; 0x02
    1510:	89 83       	std	Y+1, r24	; 0x01
           s->state=HTTP_FILE;
    1512:	82 e0       	ldi	r24, 0x02	; 2
    1514:	88 83       	st	Y, r24
    1516:	2a cf       	rjmp	.-428    	; 0x136c <httpd+0xc4>
           s->nxtdatptr_P=sendhtml_P(s);
         break;
      }

      s->state=HTTP_GET_404;
    1518:	84 e0       	ldi	r24, 0x04	; 4
    151a:	88 83       	st	Y, r24
      if (chk4getend()) {
    151c:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <chk4getend>
    1520:	88 23       	and	r24, r24
    1522:	09 f1       	breq	.+66     	; 0x1566 <httpd+0x2be>
        s->state=RAW_FILE;
    1524:	83 e0       	ldi	r24, 0x03	; 3
    1526:	88 83       	st	Y, r24
    1528:	07 c0       	rjmp	.+14     	; 0x1538 <httpd+0x290>
      }
      uip_abort();
      break;
*/
     case HTTP_GET_404:
      if (chk4getend()) {
    152a:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <chk4getend>
    152e:	88 23       	and	r24, r24
    1530:	d1 f0       	breq	.+52     	; 0x1566 <httpd+0x2be>
        s->state=RAW_FILE;
    1532:	83 e0       	ldi	r24, 0x03	; 3
    1534:	f7 01       	movw	r30, r14
    1536:	84 8f       	std	Z+28, r24	; 0x1c
        s->dataptr_P=(prog_char*)error_404;
    1538:	8e e1       	ldi	r24, 0x1E	; 30
    153a:	99 e0       	ldi	r25, 0x09	; 9
    153c:	9a 83       	std	Y+2, r25	; 0x02
    153e:	89 83       	std	Y+1, r24	; 0x01
        s->dataleft=sizeof(error_404);
    1540:	2d e5       	ldi	r18, 0x5D	; 93
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	3e 83       	std	Y+6, r19	; 0x06
    1546:	2d 83       	std	Y+5, r18	; 0x05
        sendraw_P(s->dataptr_P,s->dataleft);
    1548:	6d e5       	ldi	r22, 0x5D	; 93
    154a:	70 e0       	ldi	r23, 0x00	; 0
    154c:	0e 94 30 09 	call	0x1260	; 0x1260 <sendraw_P>
    1550:	0a c0       	rjmp	.+20     	; 0x1566 <httpd+0x2be>
      }
      break;        

     case HTTP_GET:
      if (chk4getend()) {
    1552:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <chk4getend>
    1556:	88 23       	and	r24, r24
    1558:	31 f0       	breq	.+12     	; 0x1566 <httpd+0x2be>
    155a:	01 cf       	rjmp	.-510    	; 0x135e <httpd+0xb6>
        s->nxtdatptr_P=sendhtml_P(s);
      }
      break;

     case HTTP_GET_PIC:
      start_pic_trans(s,&len); 
    155c:	65 e7       	ldi	r22, 0x75	; 117
    155e:	70 e0       	ldi	r23, 0x00	; 0
    1560:	ce 01       	movw	r24, r28
    1562:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <start_pic_trans>

     }
   }
 

   if(uip_rexmit()) {
    1566:	80 91 f2 02 	lds	r24, 0x02F2
    156a:	82 ff       	sbrs	r24, 2
    156c:	1c c0       	rjmp	.+56     	; 0x15a6 <httpd+0x2fe>
     switch (s->state) {
    156e:	88 81       	ld	r24, Y
    1570:	83 30       	cpi	r24, 0x03	; 3
    1572:	59 f0       	breq	.+22     	; 0x158a <httpd+0x2e2>
    1574:	86 30       	cpi	r24, 0x06	; 6
    1576:	81 f0       	breq	.+32     	; 0x1598 <httpd+0x2f0>
    1578:	82 30       	cpi	r24, 0x02	; 2
    157a:	09 f0       	breq	.+2      	; 0x157e <httpd+0x2d6>
    157c:	8a c0       	rjmp	.+276    	; 0x1692 <httpd+0x3ea>
     
     case HTTP_FILE:
      s->nxtdatptr_P=sendhtml_P(s);
    157e:	ce 01       	movw	r24, r28
    1580:	0e 94 8a 08 	call	0x1114	; 0x1114 <sendhtml_P>
    1584:	9e 83       	std	Y+6, r25	; 0x06
    1586:	8d 83       	std	Y+5, r24	; 0x05
    1588:	84 c0       	rjmp	.+264    	; 0x1692 <httpd+0x3ea>
      break;
    
     case RAW_FILE:
      sendraw_P(s->dataptr_P,s->dataleft);
    158a:	6d 81       	ldd	r22, Y+5	; 0x05
    158c:	7e 81       	ldd	r23, Y+6	; 0x06
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	9a 81       	ldd	r25, Y+2	; 0x02
    1592:	0e 94 30 09 	call	0x1260	; 0x1260 <sendraw_P>
    1596:	7d c0       	rjmp	.+250    	; 0x1692 <httpd+0x3ea>
      break;

     case HTTP_PIC:
      uip_send(mca25_buf,len);
    1598:	89 ee       	ldi	r24, 0xE9	; 233
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	90 93 ed 02 	sts	0x02ED, r25
    15a0:	80 93 ec 02 	sts	0x02EC, r24
    15a4:	44 c0       	rjmp	.+136    	; 0x162e <httpd+0x386>
      break;
     }    
     return;
   }

   if(uip_acked()) {
    15a6:	80 91 f2 02 	lds	r24, 0x02F2
    15aa:	80 ff       	sbrs	r24, 0
    15ac:	54 c0       	rjmp	.+168    	; 0x1656 <httpd+0x3ae>
   
     switch (s->state) {
    15ae:	88 81       	ld	r24, Y
    15b0:	83 30       	cpi	r24, 0x03	; 3
    15b2:	31 f0       	breq	.+12     	; 0x15c0 <httpd+0x318>
    15b4:	86 30       	cpi	r24, 0x06	; 6
    15b6:	51 f1       	breq	.+84     	; 0x160c <httpd+0x364>
    15b8:	82 30       	cpi	r24, 0x02	; 2
    15ba:	09 f0       	breq	.+2      	; 0x15be <httpd+0x316>
    15bc:	4c c0       	rjmp	.+152    	; 0x1656 <httpd+0x3ae>
    15be:	1a c0       	rjmp	.+52     	; 0x15f4 <httpd+0x34c>
     
     case RAW_FILE:
      if(s->dataleft < uip_mss()) {
    15c0:	e0 91 f5 02 	lds	r30, 0x02F5
    15c4:	f0 91 f6 02 	lds	r31, 0x02F6
    15c8:	6d 81       	ldd	r22, Y+5	; 0x05
    15ca:	7e 81       	ldd	r23, Y+6	; 0x06
    15cc:	82 89       	ldd	r24, Z+18	; 0x12
    15ce:	93 89       	ldd	r25, Z+19	; 0x13
    15d0:	68 17       	cp	r22, r24
    15d2:	79 07       	cpc	r23, r25
    15d4:	e8 f1       	brcs	.+122    	; 0x1650 <httpd+0x3a8>
         uip_close();
	 break;
      }
      s->dataptr_P+=uip_conn->len;
    15d6:	89 81       	ldd	r24, Y+1	; 0x01
    15d8:	9a 81       	ldd	r25, Y+2	; 0x02
    15da:	20 89       	ldd	r18, Z+16	; 0x10
    15dc:	31 89       	ldd	r19, Z+17	; 0x11
    15de:	82 0f       	add	r24, r18
    15e0:	93 1f       	adc	r25, r19
    15e2:	9a 83       	std	Y+2, r25	; 0x02
    15e4:	89 83       	std	Y+1, r24	; 0x01
      s->dataleft-=uip_conn->len;
    15e6:	62 1b       	sub	r22, r18
    15e8:	73 0b       	sbc	r23, r19
    15ea:	7e 83       	std	Y+6, r23	; 0x06
    15ec:	6d 83       	std	Y+5, r22	; 0x05
      sendraw_P(s->dataptr_P,s->dataleft);
    15ee:	0e 94 30 09 	call	0x1260	; 0x1260 <sendraw_P>
    15f2:	31 c0       	rjmp	.+98     	; 0x1656 <httpd+0x3ae>
      break;
     
     case HTTP_FILE:
      if(s->nxtdatptr_P) {
    15f4:	8d 81       	ldd	r24, Y+5	; 0x05
    15f6:	9e 81       	ldd	r25, Y+6	; 0x06
    15f8:	00 97       	sbiw	r24, 0x00	; 0
    15fa:	51 f1       	breq	.+84     	; 0x1650 <httpd+0x3a8>
        s->dataptr_P=s->nxtdatptr_P;
    15fc:	9a 83       	std	Y+2, r25	; 0x02
    15fe:	89 83       	std	Y+1, r24	; 0x01
        s->nxtdatptr_P=sendhtml_P(s);
    1600:	ce 01       	movw	r24, r28
    1602:	0e 94 8a 08 	call	0x1114	; 0x1114 <sendhtml_P>
    1606:	9e 83       	std	Y+6, r25	; 0x06
    1608:	8d 83       	std	Y+5, r24	; 0x05
    160a:	25 c0       	rjmp	.+74     	; 0x1656 <httpd+0x3ae>
      }
      uip_close();
      break;

      case HTTP_PIC:
       if (ret) { 
    160c:	80 91 60 00 	lds	r24, 0x0060
    1610:	88 23       	and	r24, r24
    1612:	b1 f0       	breq	.+44     	; 0x1640 <httpd+0x398>
         ret=mca25_copy_data(mca25_buf,&len);
    1614:	09 ee       	ldi	r16, 0xE9	; 233
    1616:	10 e0       	ldi	r17, 0x00	; 0
    1618:	65 e7       	ldi	r22, 0x75	; 117
    161a:	70 e0       	ldi	r23, 0x00	; 0
    161c:	c8 01       	movw	r24, r16
    161e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <mca25_copy_data>
    1622:	80 93 60 00 	sts	0x0060, r24
         uip_send(mca25_buf,len);
    1626:	10 93 ed 02 	sts	0x02ED, r17
    162a:	00 93 ec 02 	sts	0x02EC, r16
    162e:	80 91 75 00 	lds	r24, 0x0075
    1632:	90 91 76 00 	lds	r25, 0x0076
    1636:	90 93 a3 05 	sts	0x05A3, r25
    163a:	80 93 a2 05 	sts	0x05A2, r24
    163e:	29 c0       	rjmp	.+82     	; 0x1692 <httpd+0x3ea>
         return;  
       }
       ret=1;
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	80 93 60 00 	sts	0x0060, r24
       mca25_stat.busy=0;
    1646:	80 91 e7 00 	lds	r24, 0x00E7
    164a:	87 7f       	andi	r24, 0xF7	; 247
    164c:	80 93 e7 00 	sts	0x00E7, r24
       uip_close(); 
    1650:	80 e1       	ldi	r24, 0x10	; 16
    1652:	80 93 f2 02 	sts	0x02F2, r24
       break; 
     }
   }
   
   if((uip_aborted()||uip_timedout()) && mca25_stat.busy) {
    1656:	80 91 f2 02 	lds	r24, 0x02F2
    165a:	85 fd       	sbrc	r24, 5
    165c:	04 c0       	rjmp	.+8      	; 0x1666 <httpd+0x3be>
    165e:	80 91 f2 02 	lds	r24, 0x02F2
    1662:	87 ff       	sbrs	r24, 7
    1664:	16 c0       	rjmp	.+44     	; 0x1692 <httpd+0x3ea>
    1666:	80 91 e7 00 	lds	r24, 0x00E7
    166a:	83 ff       	sbrs	r24, 3
    166c:	12 c0       	rjmp	.+36     	; 0x1692 <httpd+0x3ea>
    166e:	05 e7       	ldi	r16, 0x75	; 117
    1670:	10 e0       	ldi	r17, 0x00	; 0
    1672:	c9 ee       	ldi	r28, 0xE9	; 233
    1674:	d0 e0       	ldi	r29, 0x00	; 0
     while (mca25_copy_data(mca25_buf,&len)); 
    1676:	b8 01       	movw	r22, r16
    1678:	ce 01       	movw	r24, r28
    167a:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <mca25_copy_data>
    167e:	88 23       	and	r24, r24
    1680:	d1 f7       	brne	.-12     	; 0x1676 <httpd+0x3ce>
     mca25_stat.busy=0;
    1682:	80 91 e7 00 	lds	r24, 0x00E7
    1686:	87 7f       	andi	r24, 0xF7	; 247
    1688:	80 93 e7 00 	sts	0x00E7, r24
     ret=1;
    168c:	81 e0       	ldi	r24, 0x01	; 1
    168e:	80 93 60 00 	sts	0x0060, r24
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	1f 91       	pop	r17
    1698:	0f 91       	pop	r16
    169a:	ff 90       	pop	r15
    169c:	ef 90       	pop	r14
    169e:	08 95       	ret

000016a0 <services_main>:
}


void services_main(void) {
  
 switch(uip_conn->lport) {
    16a0:	e0 91 f5 02 	lds	r30, 0x02F5
    16a4:	f0 91 f6 02 	lds	r31, 0x02F6
    16a8:	84 81       	ldd	r24, Z+4	; 0x04
    16aa:	95 81       	ldd	r25, Z+5	; 0x05
    16ac:	80 50       	subi	r24, 0x00	; 0
    16ae:	90 45       	sbci	r25, 0x50	; 80
    16b0:	19 f4       	brne	.+6      	; 0x16b8 <services_main+0x18>

  case HTONS(80):
   httpd();
    16b2:	0e 94 54 09 	call	0x12a8	; 0x12a8 <httpd>
    16b6:	08 95       	ret
   break;

  default:
   uip_abort();
    16b8:	80 e2       	ldi	r24, 0x20	; 32
    16ba:	80 93 f2 02 	sts	0x02F2, r24
    16be:	08 95       	ret

000016c0 <delay_us>:


void delay_us(unsigned char us)
{
 unsigned short cnt;
 asm volatile (
    16c0:	23 e0       	ldi	r18, 0x03	; 3
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	40 e0       	ldi	r20, 0x00	; 0
    16c6:	50 e0       	ldi	r21, 0x00	; 0

000016c8 <L_dl18>:
    16c8:	e2 2f       	mov	r30, r18
    16ca:	f3 2f       	mov	r31, r19

000016cc <L_dl28>:
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	f1 f7       	brne	.-4      	; 0x16cc <L_dl28>
    16d0:	8a 95       	dec	r24
    16d2:	d1 f7       	brne	.-12     	; 0x16c8 <L_dl18>
    16d4:	08 95       	ret

000016d6 <delay_ms>:
void delay_ms(unsigned char ms)
{
   //unsigned short delay_count = F_CPU / 4000;
#ifdef __GNUC__
    unsigned short cnt;
    asm volatile ("\n"
    16d6:	26 e6       	ldi	r18, 0x66	; 102
    16d8:	3e e0       	ldi	r19, 0x0E	; 14
    16da:	40 e0       	ldi	r20, 0x00	; 0
    16dc:	50 e0       	ldi	r21, 0x00	; 0

000016de <L_dl119>:
    16de:	e2 2f       	mov	r30, r18
    16e0:	f3 2f       	mov	r31, r19

000016e2 <L_dl219>:
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	f1 f7       	brne	.-4      	; 0x16e2 <L_dl219>
    16e6:	8a 95       	dec	r24
    16e8:	d1 f7       	brne	.-12     	; 0x16de <L_dl119>
    16ea:	08 95       	ret

000016ec <USART_Init>:
extern volatile unsigned char usart_timeout;


void USART_Init(unsigned int UBRR_N, unsigned char DBR) {

 UBRRH=UBRR_N>>8;
    16ec:	29 2f       	mov	r18, r25
    16ee:	33 27       	eor	r19, r19
    16f0:	20 bd       	out	0x20, r18	; 32
 UBRRL=UBRR_N&255;
    16f2:	89 b9       	out	0x09, r24	; 9
 UCSRB=(1<<RXEN)|(1<<TXEN);
    16f4:	88 e1       	ldi	r24, 0x18	; 24
    16f6:	8a b9       	out	0x0a, r24	; 10
// UCSRC=(1<<URSEL)|(3<<UCSZ0);
 if (DBR) UCSRA|=(1<<U2X);
    16f8:	66 23       	and	r22, r22
    16fa:	11 f0       	breq	.+4      	; 0x1700 <USART_Init+0x14>
    16fc:	59 9a       	sbi	0x0b, 1	; 11
    16fe:	08 95       	ret
 else UCSRA&=(unsigned char)~(1<<U2X);
    1700:	59 98       	cbi	0x0b, 1	; 11
    1702:	08 95       	ret

00001704 <USART_Transmit>:
}


void USART_Transmit(unsigned char data) {

 while(!(UCSRA&(1<<UDRE)));
    1704:	5d 9b       	sbis	0x0b, 5	; 11
    1706:	fe cf       	rjmp	.-4      	; 0x1704 <USART_Transmit>
 UDR=data;
    1708:	8c b9       	out	0x0c, r24	; 12
    170a:	08 95       	ret

0000170c <USART_Receive>:
}


unsigned char USART_Receive(void) {

 usart_timeout=180;
    170c:	84 eb       	ldi	r24, 0xB4	; 180
    170e:	80 93 e8 00 	sts	0x00E8, r24
    1712:	07 c0       	rjmp	.+14     	; 0x1722 <USART_Receive+0x16>
 while(!(UCSRA&(1<<RXC))) if(!usart_timeout) return 0;
    1714:	80 91 e8 00 	lds	r24, 0x00E8
    1718:	88 23       	and	r24, r24
    171a:	19 f4       	brne	.+6      	; 0x1722 <USART_Receive+0x16>
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	08 95       	ret
    1722:	5f 9b       	sbis	0x0b, 7	; 11
    1724:	f7 cf       	rjmp	.-18     	; 0x1714 <USART_Receive+0x8>

 return UDR;
    1726:	8c b1       	in	r24, 0x0c	; 12
    1728:	99 27       	eor	r25, r25

}
    172a:	08 95       	ret

0000172c <USART_Flush>:


void USART_Flush(void) {
    172c:	01 c0       	rjmp	.+2      	; 0x1730 <USART_Flush+0x4>

unsigned char dummy;

 while(UCSRA&(1<<RXC)) dummy=UDR;
    172e:	8c b1       	in	r24, 0x0c	; 12
    1730:	5f 99       	sbic	0x0b, 7	; 11
    1732:	fd cf       	rjmp	.-6      	; 0x172e <USART_Flush+0x2>
    1734:	08 95       	ret

00001736 <USART_pstr_P>:

}


void USART_pstr_P(const char *addr)
{
    1736:	03 c0       	rjmp	.+6      	; 0x173e <USART_pstr_P+0x8>
}


void USART_Transmit(unsigned char data) {

 while(!(UCSRA&(1<<UDRE)));
    1738:	5d 9b       	sbis	0x0b, 5	; 11
    173a:	fe cf       	rjmp	.-4      	; 0x1738 <USART_pstr_P+0x2>
 UDR=data;
    173c:	2c b9       	out	0x0c, r18	; 12
    173e:	fc 01       	movw	r30, r24


void USART_pstr_P(const char *addr)
{
 char c;
 while((c=pgm_read_byte(addr++)))
    1740:	01 96       	adiw	r24, 0x01	; 1
    1742:	24 91       	lpm	r18, Z+
    1744:	22 23       	and	r18, r18
    1746:	c1 f7       	brne	.-16     	; 0x1738 <USART_pstr_P+0x2>
    1748:	08 95       	ret

0000174a <memcmp_P_mca>:
0x0D,0x0A,0x3C,0x2F,0x63,0x61,0x6D,0x65,0x72,0x61,0x2D,0x73,0x65,0x74,0x74,0x69,0x6E,0x8C,0xF9,
0xF9,0x81,0xEF,0x0B,0x67,0x73,0x3E,0x0D,0x0A,0xAF,0xF9};



unsigned char memcmp_P_mca(unsigned char* ptr1, const char* ptr2, unsigned char len) {
    174a:	dc 01       	movw	r26, r24
    174c:	fb 01       	movw	r30, r22
    174e:	09 c0       	rjmp	.+18     	; 0x1762 <memcmp_P_mca+0x18>

 while(len--) if(*ptr1++!=pgm_read_byte(ptr2++)) return 1;
    1750:	94 91       	lpm	r25, Z+
    1752:	8c 91       	ld	r24, X
    1754:	89 17       	cp	r24, r25
    1756:	19 f0       	breq	.+6      	; 0x175e <memcmp_P_mca+0x14>
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	08 95       	ret
    175e:	31 96       	adiw	r30, 0x01	; 1
    1760:	11 96       	adiw	r26, 0x01	; 1
    1762:	41 50       	subi	r20, 0x01	; 1
    1764:	a8 f7       	brcc	.-22     	; 0x1750 <memcmp_P_mca+0x6>
    1766:	80 e0       	ldi	r24, 0x00	; 0
    1768:	90 e0       	ldi	r25, 0x00	; 0
 return 0;
}
    176a:	08 95       	ret

0000176c <mca25_pgm_send>:
//preview image #i has been grabbed.
   }
}


void mca25_pgm_send(PGM_P pointer, unsigned int len) {
    176c:	0f 93       	push	r16
    176e:	1f 93       	push	r17
    1770:	cf 93       	push	r28
    1772:	df 93       	push	r29
    1774:	8c 01       	movw	r16, r24
    1776:	eb 01       	movw	r28, r22
    1778:	07 c0       	rjmp	.+14     	; 0x1788 <mca25_pgm_send+0x1c>

 while(len--) USART_putchar(pgm_read_byte(pointer++));
    177a:	f8 01       	movw	r30, r16
    177c:	0f 5f       	subi	r16, 0xFF	; 255
    177e:	1f 4f       	sbci	r17, 0xFF	; 255
    1780:	e4 91       	lpm	r30, Z+
    1782:	8e 2f       	mov	r24, r30
    1784:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
    1788:	21 97       	sbiw	r28, 0x01	; 1
    178a:	8f ef       	ldi	r24, 0xFF	; 255
    178c:	cf 3f       	cpi	r28, 0xFF	; 255
    178e:	d8 07       	cpc	r29, r24
    1790:	a1 f7       	brne	.-24     	; 0x177a <mca25_pgm_send+0xe>
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	1f 91       	pop	r17
    1798:	0f 91       	pop	r16
    179a:	08 95       	ret

0000179c <mca25_grab_jpeg>:
   }
 }
}


void mca25_grab_jpeg(char res) {
    179c:	1f 93       	push	r17
    179e:	18 2f       	mov	r17, r24

 mca25_pgm_send(MCA25_START_JPG_1,sizeof(MCA25_START_JPG_1));
    17a0:	67 e5       	ldi	r22, 0x57	; 87
    17a2:	70 e0       	ldi	r23, 0x00	; 0
    17a4:	87 e0       	ldi	r24, 0x07	; 7
    17a6:	9a e0       	ldi	r25, 0x0A	; 10
    17a8:	0e 94 b6 0b 	call	0x176c	; 0x176c <mca25_pgm_send>
 switch (res) {
    17ac:	11 30       	cpi	r17, 0x01	; 1
    17ae:	19 f0       	breq	.+6      	; 0x17b6 <mca25_grab_jpeg+0x1a>
    17b0:	12 30       	cpi	r17, 0x02	; 2
    17b2:	59 f4       	brne	.+22     	; 0x17ca <mca25_grab_jpeg+0x2e>
    17b4:	05 c0       	rjmp	.+10     	; 0x17c0 <mca25_grab_jpeg+0x24>
  
  case 1:   mca25_pgm_send(MCA25_START_JPG_320x240,sizeof(MCA25_START_JPG_320x240));
    17b6:	67 e0       	ldi	r22, 0x07	; 7
    17b8:	70 e0       	ldi	r23, 0x00	; 0
    17ba:	85 e6       	ldi	r24, 0x65	; 101
    17bc:	9a e0       	ldi	r25, 0x0A	; 10
    17be:	09 c0       	rjmp	.+18     	; 0x17d2 <mca25_grab_jpeg+0x36>
            break;
  
  case 2:   mca25_pgm_send(MCA25_START_JPG_640x480,sizeof(MCA25_START_JPG_640x480));
    17c0:	67 e0       	ldi	r22, 0x07	; 7
    17c2:	70 e0       	ldi	r23, 0x00	; 0
    17c4:	8e e5       	ldi	r24, 0x5E	; 94
    17c6:	9a e0       	ldi	r25, 0x0A	; 10
    17c8:	04 c0       	rjmp	.+8      	; 0x17d2 <mca25_grab_jpeg+0x36>
            break;
  
  default:  mca25_pgm_send(MCA25_START_JPG_160x120,sizeof(MCA25_START_JPG_160x120));
    17ca:	67 e0       	ldi	r22, 0x07	; 7
    17cc:	70 e0       	ldi	r23, 0x00	; 0
    17ce:	8c e6       	ldi	r24, 0x6C	; 108
    17d0:	9a e0       	ldi	r25, 0x0A	; 10
    17d2:	0e 94 b6 0b 	call	0x176c	; 0x176c <mca25_pgm_send>
 }
 mca25_pgm_send(MCA25_START_JPG_2,sizeof(MCA25_START_JPG_2));
    17d6:	62 e4       	ldi	r22, 0x42	; 66
    17d8:	70 e0       	ldi	r23, 0x00	; 0
    17da:	83 e7       	ldi	r24, 0x73	; 115
    17dc:	9a e0       	ldi	r25, 0x0A	; 10
    17de:	0e 94 b6 0b 	call	0x176c	; 0x176c <mca25_pgm_send>
    17e2:	1f 91       	pop	r17
    17e4:	08 95       	ret

000017e6 <mca25_send_data_ack>:
}


void mca25_send_data_ack(void) {

 USART_pstr_P(PSTR("\xF9\x81\xEF\x07\x83"));
    17e6:	85 e3       	ldi	r24, 0x35	; 53
    17e8:	9f e0       	ldi	r25, 0x0F	; 15
    17ea:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    17ee:	80 e0       	ldi	r24, 0x00	; 0
    17f0:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x03\xA6\xF9"));
    17f4:	81 e3       	ldi	r24, 0x31	; 49
    17f6:	9f e0       	ldi	r25, 0x0F	; 15
    17f8:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
    17fc:	08 95       	ret

000017fe <mca25_grab_data>:
                              "\x6E\x66\x6F\x3E\x00\xE4\xF9"),31)) return 7;
 return 0;
}


void mca25_grab_data(char *buffer, unsigned int *datalen, char *frametype) {
    17fe:	af 92       	push	r10
    1800:	bf 92       	push	r11
    1802:	cf 92       	push	r12
    1804:	df 92       	push	r13
    1806:	ef 92       	push	r14
    1808:	ff 92       	push	r15
    180a:	0f 93       	push	r16
    180c:	1f 93       	push	r17
    180e:	cf 93       	push	r28
    1810:	df 93       	push	r29
    1812:	cd b7       	in	r28, 0x3d	; 61
    1814:	de b7       	in	r29, 0x3e	; 62
    1816:	21 97       	sbiw	r28, 0x01	; 1
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	de bf       	out	0x3e, r29	; 62
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	cd bf       	out	0x3d, r28	; 61
    1822:	5b 01       	movw	r10, r22
    1824:	6a 01       	movw	r12, r20
 unsigned char togo=31;
 char rx=0;
 unsigned char state=0;
 unsigned char firstframe = 1;

 *datalen = 0;
    1826:	fb 01       	movw	r30, r22
    1828:	11 82       	std	Z+1, r1	; 0x01
    182a:	10 82       	st	Z, r1
    182c:	ee 24       	eor	r14, r14
    182e:	ff 24       	eor	r15, r15
    1830:	0f e1       	ldi	r16, 0x1F	; 31
    1832:	10 e0       	ldi	r17, 0x00	; 0
    1834:	f1 e0       	ldi	r31, 0x01	; 1
    1836:	f9 83       	std	Y+1, r31	; 0x01
    1838:	94 c0       	rjmp	.+296    	; 0x1962 <mca25_grab_data+0x164>
 
 while( *datalen==0 || (j<*datalen) || state>99 || state == 12 ) {
   MCA25_STATUS_LED_ON(); 
    183a:	93 98       	cbi	0x12, 3	; 18
   rx = USART_getchar();
    183c:	0e 94 86 0b 	call	0x170c	; 0x170c <USART_Receive>
    1840:	28 2f       	mov	r18, r24
   MCA25_STATUS_LED_OFF(); 
    1842:	93 9a       	sbi	0x12, 3	; 18
   switch(state) {
    1844:	1c 30       	cpi	r17, 0x0C	; 12
    1846:	09 f4       	brne	.+2      	; 0x184a <mca25_grab_data+0x4c>
    1848:	56 c0       	rjmp	.+172    	; 0x18f6 <mca25_grab_data+0xf8>
    184a:	1d 30       	cpi	r17, 0x0D	; 13
    184c:	90 f4       	brcc	.+36     	; 0x1872 <mca25_grab_data+0x74>
    184e:	12 30       	cpi	r17, 0x02	; 2
    1850:	99 f1       	breq	.+102    	; 0x18b8 <mca25_grab_data+0xba>
    1852:	13 30       	cpi	r17, 0x03	; 3
    1854:	30 f4       	brcc	.+12     	; 0x1862 <mca25_grab_data+0x64>
    1856:	11 23       	and	r17, r17
    1858:	19 f1       	breq	.+70     	; 0x18a0 <mca25_grab_data+0xa2>
    185a:	11 30       	cpi	r17, 0x01	; 1
    185c:	09 f0       	breq	.+2      	; 0x1860 <mca25_grab_data+0x62>
    185e:	81 c0       	rjmp	.+258    	; 0x1962 <mca25_grab_data+0x164>
    1860:	23 c0       	rjmp	.+70     	; 0x18a8 <mca25_grab_data+0xaa>
    1862:	1a 30       	cpi	r17, 0x0A	; 10
    1864:	d9 f1       	breq	.+118    	; 0x18dc <mca25_grab_data+0xde>
    1866:	1b 30       	cpi	r17, 0x0B	; 11
    1868:	e8 f5       	brcc	.+122    	; 0x18e4 <mca25_grab_data+0xe6>
    186a:	13 30       	cpi	r17, 0x03	; 3
    186c:	09 f0       	breq	.+2      	; 0x1870 <mca25_grab_data+0x72>
    186e:	79 c0       	rjmp	.+242    	; 0x1962 <mca25_grab_data+0x164>
    1870:	2b c0       	rjmp	.+86     	; 0x18c8 <mca25_grab_data+0xca>
    1872:	1f 30       	cpi	r17, 0x0F	; 15
    1874:	09 f4       	brne	.+2      	; 0x1878 <mca25_grab_data+0x7a>
    1876:	5a c0       	rjmp	.+180    	; 0x192c <mca25_grab_data+0x12e>
    1878:	10 31       	cpi	r17, 0x10	; 16
    187a:	38 f4       	brcc	.+14     	; 0x188a <mca25_grab_data+0x8c>
    187c:	1d 30       	cpi	r17, 0x0D	; 13
    187e:	09 f4       	brne	.+2      	; 0x1882 <mca25_grab_data+0x84>
    1880:	4d c0       	rjmp	.+154    	; 0x191c <mca25_grab_data+0x11e>
    1882:	1e 30       	cpi	r17, 0x0E	; 14
    1884:	09 f0       	breq	.+2      	; 0x1888 <mca25_grab_data+0x8a>
    1886:	6d c0       	rjmp	.+218    	; 0x1962 <mca25_grab_data+0x164>
    1888:	4e c0       	rjmp	.+156    	; 0x1926 <mca25_grab_data+0x128>
    188a:	15 36       	cpi	r17, 0x65	; 101
    188c:	39 f0       	breq	.+14     	; 0x189c <mca25_grab_data+0x9e>
    188e:	16 36       	cpi	r17, 0x66	; 102
    1890:	09 f4       	brne	.+2      	; 0x1894 <mca25_grab_data+0x96>
    1892:	61 c0       	rjmp	.+194    	; 0x1956 <mca25_grab_data+0x158>
    1894:	14 36       	cpi	r17, 0x64	; 100
    1896:	09 f0       	breq	.+2      	; 0x189a <mca25_grab_data+0x9c>
    1898:	64 c0       	rjmp	.+200    	; 0x1962 <mca25_grab_data+0x164>
    189a:	4b c0       	rjmp	.+150    	; 0x1932 <mca25_grab_data+0x134>
    189c:	16 e6       	ldi	r17, 0x66	; 102
    189e:	61 c0       	rjmp	.+194    	; 0x1962 <mca25_grab_data+0x164>

   case 0: 
     if (rx == 0xF9)
    18a0:	89 3f       	cpi	r24, 0xF9	; 249
    18a2:	09 f0       	breq	.+2      	; 0x18a6 <mca25_grab_data+0xa8>
    18a4:	5e c0       	rjmp	.+188    	; 0x1962 <mca25_grab_data+0x164>
    18a6:	5c c0       	rjmp	.+184    	; 0x1960 <mca25_grab_data+0x162>
       state = 1;
     break;

    case 1:
      if (rx == 0x83)
    18a8:	83 38       	cpi	r24, 0x83	; 131
    18aa:	11 f4       	brne	.+4      	; 0x18b0 <mca25_grab_data+0xb2>
    18ac:	12 e0       	ldi	r17, 0x02	; 2
    18ae:	59 c0       	rjmp	.+178    	; 0x1962 <mca25_grab_data+0x164>
        state=2;
      else if (rx == 0xF9) {
    18b0:	89 3f       	cpi	r24, 0xF9	; 249
    18b2:	09 f0       	breq	.+2      	; 0x18b6 <mca25_grab_data+0xb8>
    18b4:	53 c0       	rjmp	.+166    	; 0x195c <mca25_grab_data+0x15e>
    18b6:	55 c0       	rjmp	.+170    	; 0x1962 <mca25_grab_data+0x164>
               state = 0; // we missed something, try again.
             }
      break;

    case 2:
      if (rx == 0xEF) {
    18b8:	8f 3e       	cpi	r24, 0xEF	; 239
    18ba:	11 f4       	brne	.+4      	; 0x18c0 <mca25_grab_data+0xc2>
    18bc:	13 e0       	ldi	r17, 0x03	; 3
    18be:	51 c0       	rjmp	.+162    	; 0x1962 <mca25_grab_data+0x164>
        state = 3;	// packet ok
      } else {
          if (rx == 0xF9) {
    18c0:	89 3f       	cpi	r24, 0xF9	; 249
    18c2:	09 f0       	breq	.+2      	; 0x18c6 <mca25_grab_data+0xc8>
    18c4:	4b c0       	rjmp	.+150    	; 0x195c <mca25_grab_data+0x15e>
    18c6:	4c c0       	rjmp	.+152    	; 0x1960 <mca25_grab_data+0x162>
            }
        }
      break;

    case 3: 	
      togo = (rx-1)>>1; // (rx-1)/2
    18c8:	99 27       	eor	r25, r25
    18ca:	01 97       	sbiw	r24, 0x01	; 1
    18cc:	95 95       	asr	r25
    18ce:	87 95       	ror	r24
    18d0:	08 2f       	mov	r16, r24
      if (firstframe==1)
    18d2:	29 81       	ldd	r18, Y+1	; 0x01
    18d4:	21 30       	cpi	r18, 0x01	; 1
    18d6:	59 f5       	brne	.+86     	; 0x192e <mca25_grab_data+0x130>
    18d8:	1a e0       	ldi	r17, 0x0A	; 10
    18da:	43 c0       	rjmp	.+134    	; 0x1962 <mca25_grab_data+0x164>
      else
        state = 100; //grab data
      break;

    case 10:
      togo--;
    18dc:	01 50       	subi	r16, 0x01	; 1
    18de:	1b e0       	ldi	r17, 0x0B	; 11
    18e0:	19 82       	std	Y+1, r1	; 0x01
    18e2:	3f c0       	rjmp	.+126    	; 0x1962 <mca25_grab_data+0x164>
      state = 11; 
      firstframe = 0;
      break;

    case 11:
      *datalen = (unsigned int)(rx<<8);
    18e4:	99 27       	eor	r25, r25
    18e6:	98 2f       	mov	r25, r24
    18e8:	88 27       	eor	r24, r24
    18ea:	f5 01       	movw	r30, r10
    18ec:	91 83       	std	Z+1, r25	; 0x01
    18ee:	80 83       	st	Z, r24
      togo--;
    18f0:	01 50       	subi	r16, 0x01	; 1
    18f2:	1c e0       	ldi	r17, 0x0C	; 12
    18f4:	36 c0       	rjmp	.+108    	; 0x1962 <mca25_grab_data+0x164>
      state = 12;
      break;

    case 12:
      *datalen = (unsigned int)*datalen + (unsigned int)(rx) - 6; //substract the first
    18f6:	f5 01       	movw	r30, r10
    18f8:	80 81       	ld	r24, Z
    18fa:	91 81       	ldd	r25, Z+1	; 0x01
    18fc:	06 97       	sbiw	r24, 0x06	; 6
    18fe:	82 0f       	add	r24, r18
    1900:	91 1d       	adc	r25, r1
    1902:	91 83       	std	Z+1, r25	; 0x01
    1904:	80 83       	st	Z, r24
      if (*datalen > CAM_BUFFER_LEN) {
    1906:	81 50       	subi	r24, 0x01	; 1
    1908:	92 40       	sbci	r25, 0x02	; 2
    190a:	28 f0       	brcs	.+10     	; 0x1916 <mca25_grab_data+0x118>
        *datalen = CAM_BUFFER_LEN;
    190c:	80 e0       	ldi	r24, 0x00	; 0
    190e:	92 e0       	ldi	r25, 0x02	; 2
    1910:	f5 01       	movw	r30, r10
    1912:	91 83       	std	Z+1, r25	; 0x01
    1914:	80 83       	st	Z, r24
      }
      togo--;
    1916:	01 50       	subi	r16, 0x01	; 1
    1918:	1d e0       	ldi	r17, 0x0D	; 13
    191a:	23 c0       	rjmp	.+70     	; 0x1962 <mca25_grab_data+0x164>
      state = 13;
      break;

    case 13:
      *frametype = rx;
    191c:	f6 01       	movw	r30, r12
    191e:	80 83       	st	Z, r24
      togo--;
    1920:	01 50       	subi	r16, 0x01	; 1
    1922:	1e e0       	ldi	r17, 0x0E	; 14
    1924:	1e c0       	rjmp	.+60     	; 0x1962 <mca25_grab_data+0x164>
      state = 14;
      break;

    case 14:
      togo--;
    1926:	01 50       	subi	r16, 0x01	; 1
    1928:	1f e0       	ldi	r17, 0x0F	; 15
    192a:	1b c0       	rjmp	.+54     	; 0x1962 <mca25_grab_data+0x164>
      state = 15;
      break;

    case 15:
      togo--;
    192c:	01 50       	subi	r16, 0x01	; 1
    192e:	14 e6       	ldi	r17, 0x64	; 100
    1930:	18 c0       	rjmp	.+48     	; 0x1962 <mca25_grab_data+0x164>
      state = 100; //now sample data
      break;

    case 100:
      if (j<CAM_BUFFER_LEN) mca25_buf[j] = rx;
    1932:	f0 e0       	ldi	r31, 0x00	; 0
    1934:	ef 16       	cp	r14, r31
    1936:	f2 e0       	ldi	r31, 0x02	; 2
    1938:	ff 06       	cpc	r15, r31
    193a:	28 f4       	brcc	.+10     	; 0x1946 <mca25_grab_data+0x148>
    193c:	f7 01       	movw	r30, r14
    193e:	e7 51       	subi	r30, 0x17	; 23
    1940:	ff 4f       	sbci	r31, 0xFF	; 255
    1942:	80 83       	st	Z, r24
    1944:	01 c0       	rjmp	.+2      	; 0x1948 <mca25_grab_data+0x14a>
       else MCA25_ERROR_LED_ON(); //printf("ARGHHHHHHHHHHHHHHH\n");
    1946:	95 98       	cbi	0x12, 5	; 18
      j++;
    1948:	08 94       	sec
    194a:	e1 1c       	adc	r14, r1
    194c:	f1 1c       	adc	r15, r1
      togo--;
    194e:	01 50       	subi	r16, 0x01	; 1
      if (togo == 0)
    1950:	41 f4       	brne	.+16     	; 0x1962 <mca25_grab_data+0x164>
    1952:	15 e6       	ldi	r17, 0x65	; 101
    1954:	06 c0       	rjmp	.+12     	; 0x1962 <mca25_grab_data+0x164>
    case 101:
      state = 102;
      break;

    case 102: 
    if (rx != 0xF9) {
    1956:	89 3f       	cpi	r24, 0xF9	; 249
    1958:	09 f0       	breq	.+2      	; 0x195c <mca25_grab_data+0x15e>
      MCA25_ERROR_LED_ON();
    195a:	95 98       	cbi	0x12, 5	; 18
    195c:	10 e0       	ldi	r17, 0x00	; 0
    195e:	01 c0       	rjmp	.+2      	; 0x1962 <mca25_grab_data+0x164>
    1960:	11 e0       	ldi	r17, 0x01	; 1
 unsigned char state=0;
 unsigned char firstframe = 1;

 *datalen = 0;
 
 while( *datalen==0 || (j<*datalen) || state>99 || state == 12 ) {
    1962:	f5 01       	movw	r30, r10
    1964:	80 81       	ld	r24, Z
    1966:	91 81       	ldd	r25, Z+1	; 0x01
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	09 f4       	brne	.+2      	; 0x196e <mca25_grab_data+0x170>
    196c:	66 cf       	rjmp	.-308    	; 0x183a <mca25_grab_data+0x3c>
    196e:	e8 16       	cp	r14, r24
    1970:	f9 06       	cpc	r15, r25
    1972:	08 f4       	brcc	.+2      	; 0x1976 <mca25_grab_data+0x178>
    1974:	62 cf       	rjmp	.-316    	; 0x183a <mca25_grab_data+0x3c>
    1976:	14 36       	cpi	r17, 0x64	; 100
    1978:	08 f0       	brcs	.+2      	; 0x197c <mca25_grab_data+0x17e>
    197a:	5f cf       	rjmp	.-322    	; 0x183a <mca25_grab_data+0x3c>
    197c:	1c 30       	cpi	r17, 0x0C	; 12
    197e:	09 f4       	brne	.+2      	; 0x1982 <mca25_grab_data+0x184>
    1980:	5c cf       	rjmp	.-328    	; 0x183a <mca25_grab_data+0x3c>
    1982:	21 96       	adiw	r28, 0x01	; 1
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	cd bf       	out	0x3d, r28	; 61
    198e:	df 91       	pop	r29
    1990:	cf 91       	pop	r28
    1992:	1f 91       	pop	r17
    1994:	0f 91       	pop	r16
    1996:	ff 90       	pop	r15
    1998:	ef 90       	pop	r14
    199a:	df 90       	pop	r13
    199c:	cf 90       	pop	r12
    199e:	bf 90       	pop	r11
    19a0:	af 90       	pop	r10
    19a2:	08 95       	ret

000019a4 <mca25_read_mux_packet>:
 } 
 return cnt;
}


unsigned char mca25_read_mux_packet(unsigned char *buffer) {
    19a4:	cf 92       	push	r12
    19a6:	df 92       	push	r13
    19a8:	ff 92       	push	r15
    19aa:	0f 93       	push	r16
    19ac:	1f 93       	push	r17
    19ae:	cf 93       	push	r28
    19b0:	df 93       	push	r29
    19b2:	6c 01       	movw	r12, r24
    19b4:	00 e0       	ldi	r16, 0x00	; 0
    19b6:	10 e0       	ldi	r17, 0x00	; 0
    19b8:	f0 2e       	mov	r15, r16

 unsigned char cnt;

 for(cnt=0;cnt < MCA25_COMM_BUFFER_LEN;cnt++) {
 MCA25_STATUS_LED_ON(); 
    19ba:	93 98       	cbi	0x12, 3	; 18
    19bc:	e6 01       	movw	r28, r12
    19be:	c0 0f       	add	r28, r16
    19c0:	d1 1f       	adc	r29, r17
   buffer[cnt] = USART_getchar();
    19c2:	0e 94 86 0b 	call	0x170c	; 0x170c <USART_Receive>
    19c6:	88 83       	st	Y, r24
   MCA25_STATUS_LED_OFF(); 
    19c8:	93 9a       	sbi	0x12, 3	; 18
   if ((cnt>0 && buffer[cnt] == '\xF9') || !usart_timeout) {
    19ca:	00 23       	and	r16, r16
    19cc:	19 f0       	breq	.+6      	; 0x19d4 <mca25_read_mux_packet+0x30>
    19ce:	88 81       	ld	r24, Y
    19d0:	89 3f       	cpi	r24, 0xF9	; 249
    19d2:	51 f0       	breq	.+20     	; 0x19e8 <mca25_read_mux_packet+0x44>
    19d4:	80 91 e8 00 	lds	r24, 0x00E8
    19d8:	88 23       	and	r24, r24
    19da:	31 f0       	breq	.+12     	; 0x19e8 <mca25_read_mux_packet+0x44>
    19dc:	f3 94       	inc	r15
    19de:	0f 5f       	subi	r16, 0xFF	; 255
    19e0:	1f 4f       	sbci	r17, 0xFF	; 255

unsigned char mca25_read_mux_packet(unsigned char *buffer) {

 unsigned char cnt;

 for(cnt=0;cnt < MCA25_COMM_BUFFER_LEN;cnt++) {
    19e2:	08 32       	cpi	r16, 0x28	; 40
    19e4:	11 05       	cpc	r17, r1
    19e6:	41 f7       	brne	.-48     	; 0x19b8 <mca25_read_mux_packet+0x14>
   if ((cnt>0 && buffer[cnt] == '\xF9') || !usart_timeout) {
     break; //we have finished out read.
   }
 }
 return cnt;
}
    19e8:	8f 2d       	mov	r24, r15
    19ea:	99 27       	eor	r25, r25
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	1f 91       	pop	r17
    19f2:	0f 91       	pop	r16
    19f4:	ff 90       	pop	r15
    19f6:	df 90       	pop	r13
    19f8:	cf 90       	pop	r12
    19fa:	08 95       	ret

000019fc <mca25_start_image_grab>:
 }
 mca25_pgm_send(MCA25_START_JPG_2,sizeof(MCA25_START_JPG_2));
}


void mca25_start_image_grab(void) {
    19fc:	2f 92       	push	r2
    19fe:	3f 92       	push	r3
    1a00:	4f 92       	push	r4
    1a02:	5f 92       	push	r5
    1a04:	6f 92       	push	r6
    1a06:	7f 92       	push	r7
    1a08:	8f 92       	push	r8
    1a0a:	9f 92       	push	r9
    1a0c:	af 92       	push	r10
    1a0e:	bf 92       	push	r11
    1a10:	cf 92       	push	r12
    1a12:	df 92       	push	r13
    1a14:	ff 92       	push	r15
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	ff 24       	eor	r15, r15
    1a20:	c9 ee       	ldi	r28, 0xE9	; 233
    1a22:	d0 e0       	ldi	r29, 0x00	; 0
    1a24:	f5 eb       	ldi	r31, 0xB5	; 181
    1a26:	2f 2e       	mov	r2, r31
    1a28:	fa e0       	ldi	r31, 0x0A	; 10
    1a2a:	3f 2e       	mov	r3, r31
    1a2c:	e6 ed       	ldi	r30, 0xD6	; 214
    1a2e:	4e 2e       	mov	r4, r30
    1a30:	ec e0       	ldi	r30, 0x0C	; 12
    1a32:	5e 2e       	mov	r5, r30
//   delay_ms(60);
   mca25_pgm_send(MCA25_START_CAPTURING_3,sizeof(MCA25_START_CAPTURING_3));
//   delay_ms(1);*/
   USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));	  
//   delay_ms(1);
   mca25_send_data_ack();
    1a34:	74 ec       	ldi	r23, 0xC4	; 196
    1a36:	67 2e       	mov	r6, r23
    1a38:	7c e0       	ldi	r23, 0x0C	; 12
    1a3a:	77 2e       	mov	r7, r23
    1a3c:	6f eb       	ldi	r22, 0xBF	; 191
    1a3e:	86 2e       	mov	r8, r22
    1a40:	6c e0       	ldi	r22, 0x0C	; 12
    1a42:	96 2e       	mov	r9, r22
    1a44:	5f ec       	ldi	r21, 0xCF	; 207
    1a46:	a5 2e       	mov	r10, r21
    1a48:	5c e0       	ldi	r21, 0x0C	; 12
    1a4a:	b5 2e       	mov	r11, r21
    1a4c:	49 ec       	ldi	r20, 0xC9	; 201
    1a4e:	c4 2e       	mov	r12, r20
    1a50:	4c e0       	ldi	r20, 0x0C	; 12
    1a52:	d4 2e       	mov	r13, r20
 unsigned char datapos;
 unsigned char i;

 //grab 6 preview pictures:
 for (i=0; i<6; i++) {
   mca25_read_mux_packet(mca25_buf);
    1a54:	ce 01       	movw	r24, r28
    1a56:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
//   delay_ms(1);
   mca25_pgm_send(MCA25_START_CAPTURING,sizeof(MCA25_START_CAPTURING));
    1a5a:	61 e8       	ldi	r22, 0x81	; 129
    1a5c:	70 e0       	ldi	r23, 0x00	; 0
    1a5e:	c1 01       	movw	r24, r2
    1a60:	0e 94 b6 0b 	call	0x176c	; 0x176c <mca25_pgm_send>
/*   delay_ms(18);
   mca25_pgm_send(MCA25_START_CAPTURING_2,sizeof(MCA25_START_CAPTURING_2));
//   delay_ms(60);
   mca25_pgm_send(MCA25_START_CAPTURING_3,sizeof(MCA25_START_CAPTURING_3));
//   delay_ms(1);*/
   USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));	  
    1a64:	c2 01       	movw	r24, r4
    1a66:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
//   delay_ms(1);
   mca25_send_data_ack();
    1a6a:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <mca25_send_data_ack>
    1a6e:	10 e0       	ldi	r17, 0x00	; 0
    1a70:	00 e0       	ldi	r16, 0x00	; 0
   state = 0;
   datapos = 0;
   while (state != 100) {
     mca25_read_mux_packet(mca25_buf); //read MUX packet
    1a72:	ce 01       	movw	r24, r28
    1a74:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
     switch (state) {
    1a78:	11 23       	and	r17, r17
    1a7a:	21 f0       	breq	.+8      	; 0x1a84 <mca25_start_image_grab+0x88>
    1a7c:	11 30       	cpi	r17, 0x01	; 1
    1a7e:	09 f0       	breq	.+2      	; 0x1a82 <mca25_start_image_grab+0x86>
    1a80:	4a c0       	rjmp	.+148    	; 0x1b16 <mca25_start_image_grab+0x11a>
    1a82:	37 c0       	rjmp	.+110    	; 0x1af2 <mca25_start_image_grab+0xf6>
#else
// 512byte buf:
// 90 02 00 C3 00 00 
// 90 02 00 48 01 FD
// A0 01 10 49 01 0D
         if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x3F\x90\x02"),6) == 0) {
    1a84:	46 e0       	ldi	r20, 0x06	; 6
    1a86:	b5 01       	movw	r22, r10
    1a88:	ce 01       	movw	r24, r28
    1a8a:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1a8e:	88 23       	and	r24, r24
    1a90:	d1 f4       	brne	.+52     	; 0x1ac6 <mca25_start_image_grab+0xca>
#endif
           if (mca25_buf[7] == 0xC3 && mca25_buf[8] == 0x00) {
    1a92:	80 91 f0 00 	lds	r24, 0x00F0
    1a96:	83 3c       	cpi	r24, 0xC3	; 195
    1a98:	31 f4       	brne	.+12     	; 0x1aa6 <mca25_start_image_grab+0xaa>
    1a9a:	80 91 f1 00 	lds	r24, 0x00F1
    1a9e:	88 23       	and	r24, r24
    1aa0:	21 f5       	brne	.+72     	; 0x1aea <mca25_start_image_grab+0xee>
    1aa2:	01 e0       	ldi	r16, 0x01	; 1
    1aa4:	22 c0       	rjmp	.+68     	; 0x1aea <mca25_start_image_grab+0xee>
//first frame:
             datapos = 1;
           } else if(mca25_buf[7] == 0x48 && mca25_buf[8] == 0x01) {
    1aa6:	88 34       	cpi	r24, 0x48	; 72
    1aa8:	29 f4       	brne	.+10     	; 0x1ab4 <mca25_start_image_grab+0xb8>
    1aaa:	80 91 f1 00 	lds	r24, 0x00F1
    1aae:	81 30       	cpi	r24, 0x01	; 1
    1ab0:	31 f4       	brne	.+12     	; 0x1abe <mca25_start_image_grab+0xc2>
    1ab2:	07 c0       	rjmp	.+14     	; 0x1ac2 <mca25_start_image_grab+0xc6>
//middle
             datapos = 2;
           } else if(mca25_buf[7] == 0x49 && mca25_buf[8] == 0x01) {
    1ab4:	89 34       	cpi	r24, 0x49	; 73
    1ab6:	c9 f4       	brne	.+50     	; 0x1aea <mca25_start_image_grab+0xee>
    1ab8:	80 91 f1 00 	lds	r24, 0x00F1
    1abc:	13 c0       	rjmp	.+38     	; 0x1ae4 <mca25_start_image_grab+0xe8>
//end:
             datapos = 3;
           } else if(mca25_buf[7] == 0x48 && mca25_buf[8] == 0x00) {
    1abe:	88 23       	and	r24, r24
    1ac0:	a1 f4       	brne	.+40     	; 0x1aea <mca25_start_image_grab+0xee>
    1ac2:	02 e0       	ldi	r16, 0x02	; 2
    1ac4:	12 c0       	rjmp	.+36     	; 0x1aea <mca25_start_image_grab+0xee>
               //printf("buf7=%x, buf8=%x\n\n",buf[7],buf[8]);
             }
             state = 1;
//last data -> send ack!	
             mca25_send_data_ack();
           } else if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x3F\xA0"),5) == 0) {
    1ac6:	45 e0       	ldi	r20, 0x05	; 5
    1ac8:	b6 01       	movw	r22, r12
    1aca:	ce 01       	movw	r24, r28
    1acc:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1ad0:	88 23       	and	r24, r24
    1ad2:	79 f6       	brne	.-98     	; 0x1a72 <mca25_start_image_grab+0x76>
// F9 83 EF 3F A0 00 4C 49 00 49 00 
                  if(mca25_buf[7] == 0x49 && mca25_buf[8] == 0x00) {
    1ad4:	80 91 f0 00 	lds	r24, 0x00F0
    1ad8:	89 34       	cpi	r24, 0x49	; 73
    1ada:	39 f4       	brne	.+14     	; 0x1aea <mca25_start_image_grab+0xee>
    1adc:	80 91 f1 00 	lds	r24, 0x00F1
    1ae0:	88 23       	and	r24, r24
    1ae2:	11 f0       	breq	.+4      	; 0x1ae8 <mca25_start_image_grab+0xec>
//end when CAM_BUF_LEN = 256
                    datapos = 3;
           } else if(mca25_buf[7] == 0x49 && mca25_buf[8] == 0x01) {
    1ae4:	81 30       	cpi	r24, 0x01	; 1
    1ae6:	09 f4       	brne	.+2      	; 0x1aea <mca25_start_image_grab+0xee>
    1ae8:	03 e0       	ldi	r16, 0x03	; 3
           } else {
               //printf("buf7=%x, buf8=%x\n\n",buf[7],buf[8]);
             }
             state = 1;
//last data -> send ack!	
             mca25_send_data_ack();
    1aea:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <mca25_send_data_ack>
    1aee:	11 e0       	ldi	r17, 0x01	; 1
    1af0:	c0 cf       	rjmp	.-128    	; 0x1a72 <mca25_start_image_grab+0x76>
// [F9 83 EF 11 ** ** ** ** ** ** ** ** 3F F9 ]
#if CAM_BUFFER_LEN == 256
         if ( (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x11"),4) == 0) ||
              (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x1D"),4) == 0) ) {
#else
         if ( (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x21"),4) == 0) ||
    1af2:	44 e0       	ldi	r20, 0x04	; 4
    1af4:	b3 01       	movw	r22, r6
    1af6:	ce 01       	movw	r24, r28
    1af8:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1afc:	88 23       	and	r24, r24
    1afe:	41 f0       	breq	.+16     	; 0x1b10 <mca25_start_image_grab+0x114>
              (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x31"),4) == 0) ) {
    1b00:	44 e0       	ldi	r20, 0x04	; 4
    1b02:	b4 01       	movw	r22, r8
    1b04:	ce 01       	movw	r24, r28
    1b06:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
// [F9 83 EF 11 ** ** ** ** ** ** ** ** 3F F9 ]
#if CAM_BUFFER_LEN == 256
         if ( (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x11"),4) == 0) ||
              (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x1D"),4) == 0) ) {
#else
         if ( (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x21"),4) == 0) ||
    1b0a:	88 23       	and	r24, r24
    1b0c:	09 f0       	breq	.+2      	; 0x1b10 <mca25_start_image_grab+0x114>
    1b0e:	b1 cf       	rjmp	.-158    	; 0x1a72 <mca25_start_image_grab+0x76>
              (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x31"),4) == 0) ) {
#endif
           state =0;

           if (datapos == 3) {
    1b10:	03 30       	cpi	r16, 0x03	; 3
    1b12:	49 f4       	brne	.+18     	; 0x1b26 <mca25_start_image_grab+0x12a>
    1b14:	03 c0       	rjmp	.+6      	; 0x1b1c <mca25_start_image_grab+0x120>
   USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));	  
//   delay_ms(1);
   mca25_send_data_ack();
   state = 0;
   datapos = 0;
   while (state != 100) {
    1b16:	14 36       	cpi	r17, 0x64	; 100
    1b18:	09 f0       	breq	.+2      	; 0x1b1c <mca25_start_image_grab+0x120>
    1b1a:	ab cf       	rjmp	.-170    	; 0x1a72 <mca25_start_image_grab+0x76>
 unsigned char state;
 unsigned char datapos;
 unsigned char i;

 //grab 6 preview pictures:
 for (i=0; i<6; i++) {
    1b1c:	f3 94       	inc	r15
    1b1e:	86 e0       	ldi	r24, 0x06	; 6
    1b20:	f8 16       	cp	r15, r24
    1b22:	19 f0       	breq	.+6      	; 0x1b2a <mca25_start_image_grab+0x12e>
    1b24:	97 cf       	rjmp	.-210    	; 0x1a54 <mca25_start_image_grab+0x58>
	 break;
      }
     }
//preview image #i has been grabbed.
   }
}
    1b26:	10 e0       	ldi	r17, 0x00	; 0
    1b28:	a4 cf       	rjmp	.-184    	; 0x1a72 <mca25_start_image_grab+0x76>
    1b2a:	df 91       	pop	r29
    1b2c:	cf 91       	pop	r28
    1b2e:	1f 91       	pop	r17
    1b30:	0f 91       	pop	r16
    1b32:	ff 90       	pop	r15
    1b34:	df 90       	pop	r13
    1b36:	cf 90       	pop	r12
    1b38:	bf 90       	pop	r11
    1b3a:	af 90       	pop	r10
    1b3c:	9f 90       	pop	r9
    1b3e:	8f 90       	pop	r8
    1b40:	7f 90       	pop	r7
    1b42:	6f 90       	pop	r6
    1b44:	5f 90       	pop	r5
    1b46:	4f 90       	pop	r4
    1b48:	3f 90       	pop	r3
    1b4a:	2f 90       	pop	r2
    1b4c:	08 95       	ret

00001b4e <mca25_copy_data>:
/*======================================================================
| copy the image data to the (tcp) data buffer, 
| buffer must be at least CAM_BUFFER_LEN byte long !
`======================================================================*/

unsigned char mca25_copy_data(char *buffer, unsigned int *len) {
    1b4e:	ef 92       	push	r14
    1b50:	ff 92       	push	r15
    1b52:	0f 93       	push	r16
    1b54:	1f 93       	push	r17
    1b56:	cf 93       	push	r28
    1b58:	df 93       	push	r29
    1b5a:	cd b7       	in	r28, 0x3d	; 61
    1b5c:	de b7       	in	r29, 0x3e	; 62
    1b5e:	21 97       	sbiw	r28, 0x01	; 1
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	de bf       	out	0x3e, r29	; 62
    1b66:	0f be       	out	0x3f, r0	; 63
    1b68:	cd bf       	out	0x3d, r28	; 61
    1b6a:	7c 01       	movw	r14, r24
    1b6c:	8b 01       	movw	r16, r22

 //unsigned int len = 0;
 unsigned char frametype = 0;
    1b6e:	19 82       	std	Y+1, r1	; 0x01

 *len=0;
    1b70:	fb 01       	movw	r30, r22
    1b72:	11 82       	std	Z+1, r1	; 0x01
    1b74:	10 82       	st	Z, r1

 if(mca25_stat.first_data) {
    1b76:	80 91 e7 00 	lds	r24, 0x00E7
    1b7a:	86 ff       	sbrs	r24, 6
    1b7c:	0b c0       	rjmp	.+22     	; 0x1b94 <mca25_copy_data+0x46>
   mca25_start_image_grab();
    1b7e:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <mca25_start_image_grab>
   mca25_grab_jpeg(2);
    1b82:	82 e0       	ldi	r24, 0x02	; 2
    1b84:	0e 94 ce 0b 	call	0x179c	; 0x179c <mca25_grab_jpeg>
   mca25_stat.first_data = 0;
    1b88:	80 91 e7 00 	lds	r24, 0x00E7
    1b8c:	8f 7b       	andi	r24, 0xBF	; 191
    1b8e:	80 93 e7 00 	sts	0x00E7, r24
    1b92:	02 c0       	rjmp	.+4      	; 0x1b98 <mca25_copy_data+0x4a>
 } else { mca25_send_data_ack();
    1b94:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <mca25_send_data_ack>
   }
 mca25_grab_data(buffer, len, &frametype); 
    1b98:	ae 01       	movw	r20, r28
    1b9a:	4f 5f       	subi	r20, 0xFF	; 255
    1b9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1b9e:	b8 01       	movw	r22, r16
    1ba0:	c7 01       	movw	r24, r14
    1ba2:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <mca25_grab_data>
 if (*len == 0) *len = CAM_BUFFER_LEN;
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	80 81       	ld	r24, Z
    1baa:	91 81       	ldd	r25, Z+1	; 0x01
    1bac:	89 2b       	or	r24, r25
    1bae:	21 f4       	brne	.+8      	; 0x1bb8 <mca25_copy_data+0x6a>
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	92 e0       	ldi	r25, 0x02	; 2
    1bb4:	91 83       	std	Z+1, r25	; 0x01
    1bb6:	80 83       	st	Z, r24

 // last picture is XX SH SL CC 00 
 // CC = 0x48 -> more data (?)
 //    = 0x49 -> last data
 if (frametype!=0x48) {
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	88 34       	cpi	r24, 0x48	; 72
    1bbc:	19 f4       	brne	.+6      	; 0x1bc4 <mca25_copy_data+0x76>
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	0b c0       	rjmp	.+22     	; 0x1bda <mca25_copy_data+0x8c>
 // this is important ! after the image grad
 // we need to do this! without this the camera
 // sometimes hangs while grabbing another image ... strange
 // reconfig mux (?)
   USART_pstr_P(PSTR("\xF9\x01\xEF\x0B\xE3\x07\x23\x0C\x01\x79\xF9"));
    1bc4:	83 eb       	ldi	r24, 0xB3	; 179
    1bc6:	9c e0       	ldi	r25, 0x0C	; 12
    1bc8:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
   mca25_stat.first_data = 1;
    1bcc:	80 91 e7 00 	lds	r24, 0x00E7
    1bd0:	80 64       	ori	r24, 0x40	; 64
    1bd2:	80 93 e7 00 	sts	0x00E7, r24
    1bd6:	80 e0       	ldi	r24, 0x00	; 0
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	21 96       	adiw	r28, 0x01	; 1
    1bdc:	0f b6       	in	r0, 0x3f	; 63
    1bde:	f8 94       	cli
    1be0:	de bf       	out	0x3e, r29	; 62
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	cd bf       	out	0x3d, r28	; 61
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	1f 91       	pop	r17
    1bec:	0f 91       	pop	r16
    1bee:	ff 90       	pop	r15
    1bf0:	ef 90       	pop	r14
    1bf2:	08 95       	ret

00001bf4 <mca25_configure>:
}


char mca25_configure(void) {

 mca25_read_mux_packet(mca25_buf); //read MUX packet
    1bf4:	89 ee       	ldi	r24, 0xE9	; 233
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 mca25_pgm_send(MCA25_CONFIG_640x480,sizeof(MCA25_CONFIG_640x480));
    1bfc:	6d e7       	ldi	r22, 0x7D	; 125
    1bfe:	71 e0       	ldi	r23, 0x01	; 1
    1c00:	86 e3       	ldi	r24, 0x36	; 54
    1c02:	9b e0       	ldi	r25, 0x0B	; 11
    1c04:	0e 94 b6 0b 	call	0x176c	; 0x176c <mca25_pgm_send>
 mca25_read_mux_packet(mca25_buf);
    1c08:	89 ee       	ldi	r24, 0xE9	; 233
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x07\xA0\x00\x03\xC7\xF9"),9)) return 7;
    1c10:	49 e0       	ldi	r20, 0x09	; 9
    1c12:	62 e2       	ldi	r22, 0x22	; 34
    1c14:	7d e0       	ldi	r23, 0x0D	; 13
    1c16:	89 ee       	ldi	r24, 0xE9	; 233
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1c1e:	88 23       	and	r24, r24
    1c20:	69 f5       	brne	.+90     	; 0x1c7c <mca25_configure+0x88>
 USART_pstr_P(PSTR("\xF9\x81\xEF\x2F\x83"));
    1c22:	8c e1       	ldi	r24, 0x1C	; 28
    1c24:	9d e0       	ldi	r25, 0x0D	; 13
    1c26:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
    1c2c:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x17\x42"));
    1c30:	89 e1       	ldi	r24, 0x19	; 25
    1c32:	9d e0       	ldi	r25, 0x0D	; 13
    1c34:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1c38:	80 e0       	ldi	r24, 0x00	; 0
    1c3a:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x14\x78\x2D\x62\x74\x2F\x63\x61\x6D\x65\x72\x61"));  
    1c3e:	8c e0       	ldi	r24, 0x0C	; 12
    1c40:	9d e0       	ldi	r25, 0x0D	; 13
    1c42:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\x2D\x69\x6E\x66\x6F"));  
    1c46:	86 e0       	ldi	r24, 0x06	; 6
    1c48:	9d e0       	ldi	r25, 0x0D	; 13
    1c4a:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1c4e:	80 e0       	ldi	r24, 0x00	; 0
    1c50:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x90\xF9"));
    1c54:	83 e0       	ldi	r24, 0x03	; 3
    1c56:	9d e0       	ldi	r25, 0x0D	; 13
    1c58:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1c5c:	89 ee       	ldi	r24, 0xE9	; 233
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (!memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x33\x79\x65\x72\x3D\x22\x31\x30\x22"
    1c64:	4f e1       	ldi	r20, 0x1F	; 31
    1c66:	63 ee       	ldi	r22, 0xE3	; 227
    1c68:	7c e0       	ldi	r23, 0x0C	; 12
    1c6a:	89 ee       	ldi	r24, 0xE9	; 233
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1c72:	88 23       	and	r24, r24
    1c74:	19 f0       	breq	.+6      	; 0x1c7c <mca25_configure+0x88>
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	08 95       	ret
    1c7c:	87 e0       	ldi	r24, 0x07	; 7
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
                              "\x2F\x3E\x3C\x2F\x63\x61\x6D\x65\x72\x61\x2D\x69"
                              "\x6E\x66\x6F\x3E\x00\xE4\xF9"),31)) return 7;
 return 0;
}
    1c80:	08 95       	ret

00001c82 <mca25_read_at_command>:
 delay_ms(10);
 MCA25_RESET_HI();
}


unsigned char mca25_read_at_command(unsigned char *buffer) {
    1c82:	cf 92       	push	r12
    1c84:	df 92       	push	r13
    1c86:	ff 92       	push	r15
    1c88:	0f 93       	push	r16
    1c8a:	1f 93       	push	r17
    1c8c:	cf 93       	push	r28
    1c8e:	df 93       	push	r29
    1c90:	6c 01       	movw	r12, r24
    1c92:	c0 e0       	ldi	r28, 0x00	; 0
    1c94:	d0 e0       	ldi	r29, 0x00	; 0
    1c96:	fc 2e       	mov	r15, r28

unsigned char cnt;
 
 for(cnt=0;cnt<MCA25_COMM_BUFFER_LEN;cnt++) {
   MCA25_STATUS_LED_ON();
    1c98:	93 98       	cbi	0x12, 3	; 18
    1c9a:	86 01       	movw	r16, r12
    1c9c:	0c 0f       	add	r16, r28
    1c9e:	1d 1f       	adc	r17, r29
   buffer[cnt] = USART_getchar();
    1ca0:	0e 94 86 0b 	call	0x170c	; 0x170c <USART_Receive>
    1ca4:	f8 01       	movw	r30, r16
    1ca6:	80 83       	st	Z, r24
   MCA25_STATUS_LED_OFF();
    1ca8:	93 9a       	sbi	0x12, 3	; 18
   if (buffer[cnt] == '\r' || !usart_timeout) break; 
    1caa:	80 81       	ld	r24, Z
    1cac:	8d 30       	cpi	r24, 0x0D	; 13
    1cae:	49 f0       	breq	.+18     	; 0x1cc2 <mca25_read_at_command+0x40>
    1cb0:	80 91 e8 00 	lds	r24, 0x00E8
    1cb4:	88 23       	and	r24, r24
    1cb6:	29 f0       	breq	.+10     	; 0x1cc2 <mca25_read_at_command+0x40>
    1cb8:	f3 94       	inc	r15
    1cba:	21 96       	adiw	r28, 0x01	; 1

unsigned char mca25_read_at_command(unsigned char *buffer) {

unsigned char cnt;
 
 for(cnt=0;cnt<MCA25_COMM_BUFFER_LEN;cnt++) {
    1cbc:	c8 32       	cpi	r28, 0x28	; 40
    1cbe:	d1 05       	cpc	r29, r1
    1cc0:	51 f7       	brne	.-44     	; 0x1c96 <mca25_read_at_command+0x14>
   buffer[cnt] = USART_getchar();
   MCA25_STATUS_LED_OFF();
   if (buffer[cnt] == '\r' || !usart_timeout) break; 
 } 
 return cnt;
}
    1cc2:	8f 2d       	mov	r24, r15
    1cc4:	99 27       	eor	r25, r25
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	1f 91       	pop	r17
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	df 90       	pop	r13
    1cd2:	cf 90       	pop	r12
    1cd4:	08 95       	ret

00001cd6 <MCA25_Reset>:
}


void MCA25_Reset(void) {

 MCA25_RESET_LO();
    1cd6:	96 98       	cbi	0x12, 6	; 18
 delay_ms(10);
    1cd8:	8a e0       	ldi	r24, 0x0A	; 10
    1cda:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
 MCA25_RESET_HI();
    1cde:	96 9a       	sbi	0x12, 6	; 18
    1ce0:	08 95       	ret

00001ce2 <mca25_init>:
}


char mca25_init(void) {

 MCA25_RESET_PORT_DIR=(1<<MCA25_RESET_PIN);
    1ce2:	80 e4       	ldi	r24, 0x40	; 64
    1ce4:	81 bb       	out	0x11, r24	; 17
 MCA25_RESET_PORT=(unsigned char)~(1<<MCA25_RESET_PIN); 
    1ce6:	8f eb       	ldi	r24, 0xBF	; 191
    1ce8:	82 bb       	out	0x12, r24	; 18
 delay_ms(10);
    1cea:	8a e0       	ldi	r24, 0x0A	; 10
    1cec:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>

 MCA25_Reset();
    1cf0:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <MCA25_Reset>
#if USE_WEBCAM_LEDS
	MCA25_RESET_PORT_DIR |=  (1<<MCA25_STATUS_PIN); 
    1cf4:	8b 9a       	sbi	0x11, 3	; 17
	MCA25_RESET_PORT_DIR |=  (1<<MCA25_CLOCK_PIN); 
    1cf6:	8c 9a       	sbi	0x11, 4	; 17
	MCA25_RESET_PORT_DIR |=  (1<<MCA25_ERROR_PIN); 
    1cf8:	8d 9a       	sbi	0x11, 5	; 17
#endif 

 delay_ms(1);
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
 USART_Flush();
    1d00:	0e 94 96 0b 	call	0x172c	; 0x172c <USART_Flush>
 mca25_read_at_command(mca25_buf);
    1d04:	89 ee       	ldi	r24, 0xE9	; 233
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <mca25_read_at_command>
 if (memcmp_P_mca(mca25_buf+2,PSTR("AT&F"),4)) return 1;
    1d0c:	44 e0       	ldi	r20, 0x04	; 4
    1d0e:	6c e2       	ldi	r22, 0x2C	; 44
    1d10:	7f e0       	ldi	r23, 0x0F	; 15
    1d12:	8b ee       	ldi	r24, 0xEB	; 235
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1d1a:	88 23       	and	r24, r24
    1d1c:	19 f0       	breq	.+6      	; 0x1d24 <mca25_init+0x42>
    1d1e:	81 e0       	ldi	r24, 0x01	; 1
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	08 95       	ret
 USART_pstr_P(PSTR("\r\r\nOK\r\n"));
    1d24:	84 e2       	ldi	r24, 0x24	; 36
    1d26:	9f e0       	ldi	r25, 0x0F	; 15
    1d28:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_at_command(mca25_buf);
    1d2c:	89 ee       	ldi	r24, 0xE9	; 233
    1d2e:	90 e0       	ldi	r25, 0x00	; 0
    1d30:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <mca25_read_at_command>
 if (memcmp_P_mca(mca25_buf,PSTR("AT+IPR=?"),8)) return 2;
    1d34:	48 e0       	ldi	r20, 0x08	; 8
    1d36:	6b e1       	ldi	r22, 0x1B	; 27
    1d38:	7f e0       	ldi	r23, 0x0F	; 15
    1d3a:	89 ee       	ldi	r24, 0xE9	; 233
    1d3c:	90 e0       	ldi	r25, 0x00	; 0
    1d3e:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1d42:	88 23       	and	r24, r24
    1d44:	09 f0       	breq	.+2      	; 0x1d48 <mca25_init+0x66>
    1d46:	32 c1       	rjmp	.+612    	; 0x1fac <mca25_init+0x2ca>
 USART_pstr_P(PSTR("+IPR: (),(1200,2400,4800,9600,19200,38400,57600,460800)\r\n\r\nOK\r\n"));
    1d48:	8b ed       	ldi	r24, 0xDB	; 219
    1d4a:	9e e0       	ldi	r25, 0x0E	; 14
    1d4c:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_at_command(mca25_buf);
    1d50:	89 ee       	ldi	r24, 0xE9	; 233
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <mca25_read_at_command>
 if (memcmp_P_mca(mca25_buf,PSTR("AT+IPR=460800"),13)) return 2;
    1d58:	4d e0       	ldi	r20, 0x0D	; 13
    1d5a:	6d ec       	ldi	r22, 0xCD	; 205
    1d5c:	7e e0       	ldi	r23, 0x0E	; 14
    1d5e:	89 ee       	ldi	r24, 0xE9	; 233
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1d66:	88 23       	and	r24, r24
    1d68:	09 f0       	breq	.+2      	; 0x1d6c <mca25_init+0x8a>
    1d6a:	20 c1       	rjmp	.+576    	; 0x1fac <mca25_init+0x2ca>
 USART_pstr_P(PSTR("\r\nOK\r\n"));
    1d6c:	86 ec       	ldi	r24, 0xC6	; 198
    1d6e:	9e e0       	ldi	r25, 0x0E	; 14
    1d70:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 delay_ms(10);
    1d74:	8a e0       	ldi	r24, 0x0A	; 10
    1d76:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
 SET_USART_460800();
    1d7a:	60 e0       	ldi	r22, 0x00	; 0
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	0e 94 76 0b 	call	0x16ec	; 0x16ec <USART_Init>
 delay_ms(1);
    1d84:	81 e0       	ldi	r24, 0x01	; 1
    1d86:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
 USART_Flush();
    1d8a:	0e 94 96 0b 	call	0x172c	; 0x172c <USART_Flush>
 mca25_read_at_command(mca25_buf);
    1d8e:	89 ee       	ldi	r24, 0xE9	; 233
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <mca25_read_at_command>
 if (memcmp_P_mca(mca25_buf,PSTR("AT+CMUX=?"),9)) return 3;
    1d96:	49 e0       	ldi	r20, 0x09	; 9
    1d98:	6c eb       	ldi	r22, 0xBC	; 188
    1d9a:	7e e0       	ldi	r23, 0x0E	; 14
    1d9c:	89 ee       	ldi	r24, 0xE9	; 233
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1da4:	88 23       	and	r24, r24
    1da6:	19 f0       	breq	.+6      	; 0x1dae <mca25_init+0xcc>
    1da8:	83 e0       	ldi	r24, 0x03	; 3
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	08 95       	ret
 USART_pstr_P(PSTR("\r\r\n+CMUX: (0),(0),(1-7),(31),(10),(3),(30),(10),(1-7)\r"));
    1dae:	85 e8       	ldi	r24, 0x85	; 133
    1db0:	9e e0       	ldi	r25, 0x0E	; 14
    1db2:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_at_command(mca25_buf);
    1db6:	89 ee       	ldi	r24, 0xE9	; 233
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <mca25_read_at_command>
 if (memcmp_P_mca(mca25_buf,PSTR("AT+CMUX=0,0,7,31"),16)) return 4;
    1dbe:	40 e1       	ldi	r20, 0x10	; 16
    1dc0:	64 e7       	ldi	r22, 0x74	; 116
    1dc2:	7e e0       	ldi	r23, 0x0E	; 14
    1dc4:	89 ee       	ldi	r24, 0xE9	; 233
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1dcc:	88 23       	and	r24, r24
    1dce:	19 f0       	breq	.+6      	; 0x1dd6 <mca25_init+0xf4>
    1dd0:	84 e0       	ldi	r24, 0x04	; 4
    1dd2:	90 e0       	ldi	r25, 0x00	; 0
    1dd4:	08 95       	ret
 USART_pstr_P(PSTR("\r\r\nOK\r\n"));
    1dd6:	8c e6       	ldi	r24, 0x6C	; 108
    1dd8:	9e e0       	ldi	r25, 0x0E	; 14
    1dda:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1dde:	89 ee       	ldi	r24, 0xE9	; 233
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x03\x3F\x01\x1C\xF9"),6)) return 5;
    1de6:	46 e0       	ldi	r20, 0x06	; 6
    1de8:	65 e6       	ldi	r22, 0x65	; 101
    1dea:	7e e0       	ldi	r23, 0x0E	; 14
    1dec:	89 ee       	ldi	r24, 0xE9	; 233
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1df4:	88 23       	and	r24, r24
    1df6:	09 f0       	breq	.+2      	; 0x1dfa <mca25_init+0x118>
    1df8:	dc c0       	rjmp	.+440    	; 0x1fb2 <mca25_init+0x2d0>
 USART_pstr_P(PSTR("\xF9\x03\x73\x01\xD7\xF9"));
    1dfa:	8e e5       	ldi	r24, 0x5E	; 94
    1dfc:	9e e0       	ldi	r25, 0x0E	; 14
    1dfe:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1e02:	89 ee       	ldi	r24, 0xE9	; 233
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x23\x3F\x01\xC9\xF9"),6)) return 5;
    1e0a:	46 e0       	ldi	r20, 0x06	; 6
    1e0c:	67 e5       	ldi	r22, 0x57	; 87
    1e0e:	7e e0       	ldi	r23, 0x0E	; 14
    1e10:	89 ee       	ldi	r24, 0xE9	; 233
    1e12:	90 e0       	ldi	r25, 0x00	; 0
    1e14:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1e18:	88 23       	and	r24, r24
    1e1a:	09 f0       	breq	.+2      	; 0x1e1e <mca25_init+0x13c>
    1e1c:	ca c0       	rjmp	.+404    	; 0x1fb2 <mca25_init+0x2d0>
 USART_pstr_P(PSTR("\xF9\x23\x73\x01\x02\xF9"));
    1e1e:	80 e5       	ldi	r24, 0x50	; 80
    1e20:	9e e0       	ldi	r25, 0x0E	; 14
    1e22:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1e26:	89 ee       	ldi	r24, 0xE9	; 233
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x03\xEF\x09\xE3\x05\x23\x8D\xFB\xF9"),10)) return 5;
    1e2e:	4a e0       	ldi	r20, 0x0A	; 10
    1e30:	65 e4       	ldi	r22, 0x45	; 69
    1e32:	7e e0       	ldi	r23, 0x0E	; 14
    1e34:	89 ee       	ldi	r24, 0xE9	; 233
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1e3c:	88 23       	and	r24, r24
    1e3e:	09 f0       	breq	.+2      	; 0x1e42 <mca25_init+0x160>
    1e40:	b8 c0       	rjmp	.+368    	; 0x1fb2 <mca25_init+0x2d0>
 USART_pstr_P(PSTR("\xF9\x01\xEF\x0B\xE3\x07\x23\x0C\x01\x79\xF9"));
    1e42:	89 e3       	ldi	r24, 0x39	; 57
    1e44:	9e e0       	ldi	r25, 0x0E	; 14
    1e46:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1e4a:	89 ee       	ldi	r24, 0xE9	; 233
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x03\xEF\x09\xE1\x07\x23\x0C\x01\xFB\xF9"),11)) return 5;
    1e52:	4b e0       	ldi	r20, 0x0B	; 11
    1e54:	6d e2       	ldi	r22, 0x2D	; 45
    1e56:	7e e0       	ldi	r23, 0x0E	; 14
    1e58:	89 ee       	ldi	r24, 0xE9	; 233
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1e60:	88 23       	and	r24, r24
    1e62:	09 f0       	breq	.+2      	; 0x1e66 <mca25_init+0x184>
    1e64:	a6 c0       	rjmp	.+332    	; 0x1fb2 <mca25_init+0x2d0>
 USART_pstr_P(PSTR("\xF9\x01\xEF\x09\xE1\x05\x23\x8D\x9A\xF9"));
    1e66:	82 e2       	ldi	r24, 0x22	; 34
    1e68:	9e e0       	ldi	r25, 0x0E	; 14
    1e6a:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1e6e:	89 ee       	ldi	r24, 0xE9	; 233
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x23\xEF\x1B\x41\x54\x2A\x45\x41\x43\x53"
    1e76:	43 e1       	ldi	r20, 0x13	; 19
    1e78:	6e e0       	ldi	r22, 0x0E	; 14
    1e7a:	7e e0       	ldi	r23, 0x0E	; 14
    1e7c:	89 ee       	ldi	r24, 0xE9	; 233
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1e84:	88 23       	and	r24, r24
    1e86:	09 f0       	breq	.+2      	; 0x1e8a <mca25_init+0x1a8>
    1e88:	94 c0       	rjmp	.+296    	; 0x1fb2 <mca25_init+0x2d0>
                             "\x3D\x31\x37\x2C\x31\x0D\xD1\xF9"),19)) return 5;
 USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	9e e0       	ldi	r25, 0x0E	; 14
    1e8e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1e92:	89 ee       	ldi	r24, 0xE9	; 233
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x23\xEF\x1D\x41\x54\x2B\x43\x53\x43\x43"
    1e9a:	44 e1       	ldi	r20, 0x14	; 20
    1e9c:	6c ee       	ldi	r22, 0xEC	; 236
    1e9e:	7d e0       	ldi	r23, 0x0D	; 13
    1ea0:	89 ee       	ldi	r24, 0xE9	; 233
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1ea8:	88 23       	and	r24, r24
    1eaa:	09 f0       	breq	.+2      	; 0x1eae <mca25_init+0x1cc>
    1eac:	82 c0       	rjmp	.+260    	; 0x1fb2 <mca25_init+0x2d0>
                             "\x3D\x31\x2C\x31\x39\x39\x0D\x35\xF9"),20)) return 5;
 USART_pstr_P(PSTR("\xF9\x21\xEF\x1B\x0D\x0A\x2B\x43\x53\x43\x43\x3A\x20\x45\x33\x0D\x0A\xB0\xF9"));
    1eae:	88 ed       	ldi	r24, 0xD8	; 216
    1eb0:	9d e0       	ldi	r25, 0x0D	; 13
    1eb2:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));
    1eb6:	8b ec       	ldi	r24, 0xCB	; 203
    1eb8:	9d e0       	ldi	r25, 0x0D	; 13
    1eba:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1ebe:	89 ee       	ldi	r24, 0xE9	; 233
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x23\xEF\x23\x41\x54\x2B\x43\x53\x43\x43\x3D"
    1ec6:	47 e1       	ldi	r20, 0x17	; 23
    1ec8:	63 eb       	ldi	r22, 0xB3	; 179
    1eca:	7d e0       	ldi	r23, 0x0D	; 13
    1ecc:	89 ee       	ldi	r24, 0xE9	; 233
    1ece:	90 e0       	ldi	r25, 0x00	; 0
    1ed0:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1ed4:	88 23       	and	r24, r24
    1ed6:	09 f0       	breq	.+2      	; 0x1eda <mca25_init+0x1f8>
    1ed8:	6c c0       	rjmp	.+216    	; 0x1fb2 <mca25_init+0x2d0>
                             "\x32\x2C\x31\x39\x39\x2C\x42\x39\x0D\xFB\xF9"),23)) return 5;
 USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));
    1eda:	86 ea       	ldi	r24, 0xA6	; 166
    1edc:	9d e0       	ldi	r25, 0x0D	; 13
    1ede:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\xF9\x81\x3F\x01\xAB\xF9"));
    1ee2:	8f e9       	ldi	r24, 0x9F	; 159
    1ee4:	9d e0       	ldi	r25, 0x0D	; 13
    1ee6:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1eea:	89 ee       	ldi	r24, 0xE9	; 233
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x81\x73\x01\x60\xF9"),6)) return 5;
    1ef2:	46 e0       	ldi	r20, 0x06	; 6
    1ef4:	68 e9       	ldi	r22, 0x98	; 152
    1ef6:	7d e0       	ldi	r23, 0x0D	; 13
    1ef8:	89 ee       	ldi	r24, 0xE9	; 233
    1efa:	90 e0       	ldi	r25, 0x00	; 0
    1efc:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1f00:	88 23       	and	r24, r24
    1f02:	09 f0       	breq	.+2      	; 0x1f06 <mca25_init+0x224>
    1f04:	56 c0       	rjmp	.+172    	; 0x1fb2 <mca25_init+0x2d0>
 mca25_read_mux_packet(mca25_buf);
    1f06:	89 ee       	ldi	r24, 0xE9	; 233
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x03\xEF\x09\xE3\x05\x83\x8D\xFB\xF9"),10)) return 5;
    1f0e:	4a e0       	ldi	r20, 0x0A	; 10
    1f10:	6d e8       	ldi	r22, 0x8D	; 141
    1f12:	7d e0       	ldi	r23, 0x0D	; 13
    1f14:	89 ee       	ldi	r24, 0xE9	; 233
    1f16:	90 e0       	ldi	r25, 0x00	; 0
    1f18:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1f1c:	88 23       	and	r24, r24
    1f1e:	09 f0       	breq	.+2      	; 0x1f22 <mca25_init+0x240>
    1f20:	48 c0       	rjmp	.+144    	; 0x1fb2 <mca25_init+0x2d0>
 USART_pstr_P(PSTR("\xF9\x01\xEF\x09\xE1\x05\x83\x8D\x9A\xF9"));
    1f22:	82 e8       	ldi	r24, 0x82	; 130
    1f24:	9d e0       	ldi	r25, 0x0D	; 13
    1f26:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\xF9\x81\xEF\x37\x80"));
    1f2a:	8c e7       	ldi	r24, 0x7C	; 124
    1f2c:	9d e0       	ldi	r25, 0x0D	; 13
    1f2e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1f32:	80 e0       	ldi	r24, 0x00	; 0
    1f34:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x1A\x10"));
    1f38:	89 e7       	ldi	r24, 0x79	; 121
    1f3a:	9d e0       	ldi	r25, 0x0D	; 13
    1f3c:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1f40:	80 e0       	ldi	r24, 0x00	; 0
    1f42:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x02"));
    1f46:	87 e7       	ldi	r24, 0x77	; 119
    1f48:	9d e0       	ldi	r25, 0x0D	; 13
    1f4a:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1f4e:	80 e0       	ldi	r24, 0x00	; 0
    1f50:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x46"));
    1f54:	85 e7       	ldi	r24, 0x75	; 117
    1f56:	9d e0       	ldi	r25, 0x0D	; 13
    1f58:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_putchar('\x00');
    1f5c:	80 e0       	ldi	r24, 0x00	; 0
    1f5e:	0e 94 82 0b 	call	0x1704	; 0x1704 <USART_Transmit>
 USART_pstr_P(PSTR("\x13\xE3\x3D\x95\x45\x83\x74\x4A\xD7"));
    1f62:	8b e6       	ldi	r24, 0x6B	; 107
    1f64:	9d e0       	ldi	r25, 0x0D	; 13
    1f66:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\x9E\xC5\xC1\x6B\xE3\x1E\xDE\x8E\x61\x82\xF9"));
    1f6a:	8f e5       	ldi	r24, 0x5F	; 95
    1f6c:	9d e0       	ldi	r25, 0x0D	; 13
    1f6e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 USART_pstr_P(PSTR("\xF9\x21\xEF\x0D\x0D\x0A\x4F\x4B\x0D\x0A\x48\xF9"));	  
    1f72:	82 e5       	ldi	r24, 0x52	; 82
    1f74:	9d e0       	ldi	r25, 0x0D	; 13
    1f76:	0e 94 9b 0b 	call	0x1736	; 0x1736 <USART_pstr_P>
 mca25_read_mux_packet(mca25_buf);
    1f7a:	89 ee       	ldi	r24, 0xE9	; 233
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <mca25_read_mux_packet>
 if (memcmp_P_mca(mca25_buf,PSTR("\xF9\x83\xEF\x3F\xA0\x00\x1F\x10\x00\x20\x00\xCB\x00"
    1f82:	45 e2       	ldi	r20, 0x25	; 37
    1f84:	6c e2       	ldi	r22, 0x2C	; 44
    1f86:	7d e0       	ldi	r23, 0x0D	; 13
    1f88:	89 ee       	ldi	r24, 0xE9	; 233
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	0e 94 a5 0b 	call	0x174a	; 0x174a <memcmp_P_mca>
    1f90:	88 23       	and	r24, r24
    1f92:	19 f0       	breq	.+6      	; 0x1f9a <mca25_init+0x2b8>
    1f94:	86 e0       	ldi	r24, 0x06	; 6
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	08 95       	ret
                             "\x00\x00\x01\x4A\x00\x13\xE3\x3D\x95\x45\x83\x74\x4A"
                             "\xD7\x9E\xC5\xC1\x6B\xE3\x1E\xDE\x8E\xED\xF9"),37)) return 6;
 mca25_stat.busy=0;
    1f9a:	80 91 e7 00 	lds	r24, 0x00E7
 mca25_stat.skip_pic=0;
    1f9e:	87 7e       	andi	r24, 0xE7	; 231
 mca25_stat.first_data = 1;
    1fa0:	80 64       	ori	r24, 0x40	; 64
    1fa2:	80 93 e7 00 	sts	0x00E7, r24
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	08 95       	ret
 return 0;
    1fac:	82 e0       	ldi	r24, 0x02	; 2
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	08 95       	ret
    1fb2:	85 e0       	ldi	r24, 0x05	; 5
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
}
    1fb6:	08 95       	ret

00001fb8 <servo_prepare_pos>:
//	servo_set_pos(127);
servo_set_pos(127);
}

void servo_prepare_pos(unsigned char val){
	servo_pos = val;
    1fb8:	80 93 e9 02 	sts	0x02E9, r24
	servo_need_update = 1;
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	80 93 77 00 	sts	0x0077, r24
    1fc2:	08 95       	ret

00001fc4 <servo_move>:
#if defined (__AVR_ATmega644__)
	OCR2A = CALC_1MS-1 + (unsigned char)(((unsigned int)servo_pos*CALC_1MS)/255);
#endif	

#if defined (__AVR_ATmega32__)
	OCR2 = ((F_CPU/1024/1000)-1) + (unsigned char)((unsigned int)servo_pos*(F_CPU/1024/1000)/255);
    1fc4:	60 91 e9 02 	lds	r22, 0x02E9
    1fc8:	77 27       	eor	r23, r23
    1fca:	88 27       	eor	r24, r24
    1fcc:	99 27       	eor	r25, r25
    1fce:	2e e0       	ldi	r18, 0x0E	; 14
    1fd0:	30 e0       	ldi	r19, 0x00	; 0
    1fd2:	40 e0       	ldi	r20, 0x00	; 0
    1fd4:	50 e0       	ldi	r21, 0x00	; 0
    1fd6:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <__mulsi3>
    1fda:	2f ef       	ldi	r18, 0xFF	; 255
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e0       	ldi	r20, 0x00	; 0
    1fe0:	50 e0       	ldi	r21, 0x00	; 0
    1fe2:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__divmodsi4>
    1fe6:	23 5f       	subi	r18, 0xF3	; 243
    1fe8:	23 bd       	out	0x23, r18	; 35
#endif

//    #define CALC_1MS SYSCLK/256/1000
//    OCR0 = (CALC_1MS-5 + (unsigned char)(((double)servo_pos/255.0)*CALC_1MS));
	servo_need_update = 0;
    1fea:	10 92 77 00 	sts	0x0077, r1
    1fee:	08 95       	ret

00001ff0 <servo_set_pos>:
	servo_pos = val;
	servo_need_update = 1;
}

void servo_set_pos(unsigned char val){
	servo_pos = val;
    1ff0:	80 93 e9 02 	sts	0x02E9, r24
	servo_move();
    1ff4:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <servo_move>
    1ff8:	08 95       	ret

00001ffa <servo_init>:
	TCCR2A = 1<<WGM00|1<<WGM01|1<<COM2A1; 
	TCCR2B = 1<<CS00|1<<CS01|1<<CS02;
#endif	

#if defined (__AVR_ATmega32__)
	TCCR2 = 1<<WGM00|1<<WGM01|1<<COM01|1<<CS00|1<<CS01|1<<CS02;
    1ffa:	8f e6       	ldi	r24, 0x6F	; 111
    1ffc:	85 bd       	out	0x25, r24	; 37
//	#define WGM_CFG (1<<WGM00 | 1<<WGM01) //fast pwm
//	#define COM_CFG (1<<COM0A1 | 0<<COM0A0) //clr on match, set on max
//	#define CLK_CFG (1<<CS00 | 1<<CS01 | 1<<CS02) //set up clock source clk/1024
//	TCCR2A = WGM_CFG | COM_CFG ; 
//	TCCR2B = CLK_CFG;
	DDRD |= 0x80;
    1ffe:	8f 9a       	sbi	0x11, 7	; 17
//	servo_set_pos(127);
servo_set_pos(127);
    2000:	8f e7       	ldi	r24, 0x7F	; 127
    2002:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <servo_set_pos>
    2006:	08 95       	ret

00002008 <rtl8019Write>:
#if NIC_CONNECTION == GENERAL_IO

void rtl8019Write(unsigned char address, unsigned char data)
{
    // assert the address, leaving the non-address pins intact
    address |= (RTL8019_ADDRESS_PORT & ~RTL8019_ADDRESS_MASK);
    2008:	9b b3       	in	r25, 0x1b	; 27
    200a:	90 7e       	andi	r25, 0xE0	; 224
    200c:	98 2b       	or	r25, r24
    RTL8019_ADDRESS_PORT = address;
    200e:	9b bb       	out	0x1b, r25	; 27

	// set data bus as output and place data on bus
    RTL8019_DATA_DDR = 0xFF;
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	84 bb       	out	0x14, r24	; 20
    RTL8019_DATA_PORT = data;
    2014:	65 bb       	out	0x15, r22	; 21

	// toggle write pin
    RTL8019_CONTROL_PORT &= ~_BV(RTL8019_CONTROL_WRITEPIN);
    2016:	c1 98       	cbi	0x18, 1	; 24
    nop();
    2018:	00 00       	nop
    nop();
    201a:	00 00       	nop
    RTL8019_CONTROL_PORT |= _BV(RTL8019_CONTROL_WRITEPIN);
    201c:	c1 9a       	sbi	0x18, 1	; 24

	// set data port back to input with pullups enabled
    RTL8019_DATA_DDR = 0x00;
    201e:	14 ba       	out	0x14, r1	; 20
    RTL8019_DATA_PORT = 0xFF;
    2020:	85 bb       	out	0x15, r24	; 21
    2022:	08 95       	ret

00002024 <rtl8019Read>:
unsigned char rtl8019Read(unsigned char address)
{
    unsigned char byte;

    // assert the address, leaving the non-address pins intact
    address |= (RTL8019_ADDRESS_PORT & ~RTL8019_ADDRESS_MASK);
    2024:	9b b3       	in	r25, 0x1b	; 27
    2026:	90 7e       	andi	r25, 0xE0	; 224
    2028:	98 2b       	or	r25, r24
    RTL8019_ADDRESS_PORT = address;
    202a:	9b bb       	out	0x1b, r25	; 27

    // assert read
    RTL8019_CONTROL_PORT &= ~_BV(RTL8019_CONTROL_READPIN);
    202c:	c2 98       	cbi	0x18, 2	; 24
    nop();
    202e:	00 00       	nop
    nop();
    2030:	00 00       	nop
    // read in the data
    byte = RTL8019_DATA_PIN;
    2032:	83 b3       	in	r24, 0x13	; 19

    // negate read
    RTL8019_CONTROL_PORT |= _BV(RTL8019_CONTROL_READPIN);
    2034:	c2 9a       	sbi	0x18, 2	; 24

    return byte;
}
    2036:	99 27       	eor	r25, r25
    2038:	08 95       	ret

0000203a <rtl8019SetupPorts>:
{

#if NIC_CONNECTION == GENERAL_IO

    // make the address port output
    RTL8019_ADDRESS_DDR |= RTL8019_ADDRESS_MASK;
    203a:	8a b3       	in	r24, 0x1a	; 26
    203c:	8f 61       	ori	r24, 0x1F	; 31
    203e:	8a bb       	out	0x1a, r24	; 26

    // make the data port input with pull-ups
    RTL8019_DATA_PORT = 0xFF;
    2040:	8f ef       	ldi	r24, 0xFF	; 255
    2042:	85 bb       	out	0x15, r24	; 21

    // make the control port read and write pins outputs and asserted
    RTL8019_CONTROL_DDR |= _BV(RTL8019_CONTROL_READPIN);
    2044:	ba 9a       	sbi	0x17, 2	; 23
    RTL8019_CONTROL_DDR |= _BV(RTL8019_CONTROL_WRITEPIN);
    2046:	b9 9a       	sbi	0x17, 1	; 23

    RTL8019_CONTROL_PORT |= _BV(RTL8019_CONTROL_READPIN);
    2048:	c2 9a       	sbi	0x18, 2	; 24
    RTL8019_CONTROL_PORT |= _BV(RTL8019_CONTROL_WRITEPIN);
    204a:	c1 9a       	sbi	0x18, 1	; 24
    MCUCR |= _BV(SRE);

#endif

    // enable output pin for Resetting the RTL8019
    RTL8019_RESET_DDR |= _BV(RTL8019_RESET_PIN);
    204c:	b8 9a       	sbi	0x17, 0	; 23
    204e:	08 95       	ret

00002050 <rtl8019BeginPacketSend>:
#define RXSTOP_INIT     0x60



void rtl8019BeginPacketSend(unsigned int packetLength)
{
    2050:	0f 93       	push	r16
    2052:	1f 93       	push	r17
    2054:	cf 93       	push	r28
    2056:	df 93       	push	r29
    2058:	ec 01       	movw	r28, r24
	unsigned int sendPacketLength;
	sendPacketLength = (packetLength>=ETHERNET_MIN_PACKET_LENGTH) ?
    205a:	8c 01       	movw	r16, r24
    205c:	cc 97       	sbiw	r24, 0x3c	; 60
    205e:	10 f4       	brcc	.+4      	; 0x2064 <rtl8019BeginPacketSend+0x14>
    2060:	cc e3       	ldi	r28, 0x3C	; 60
    2062:	d0 e0       	ldi	r29, 0x00	; 0
	                 packetLength : ETHERNET_MIN_PACKET_LENGTH ;

	//start the NIC
	rtl8019Write(CR,0x22);
    2064:	62 e2       	ldi	r22, 0x22	; 34
    2066:	80 e0       	ldi	r24, 0x00	; 0
    2068:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	// still transmitting a packet - wait for it to finish
	while( rtl8019Read(CR) & 0x04 );
    206c:	80 e0       	ldi	r24, 0x00	; 0
    206e:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    2072:	82 fd       	sbrc	r24, 2
    2074:	fb cf       	rjmp	.-10     	; 0x206c <rtl8019BeginPacketSend+0x1c>

	//load beginning page for transmit buffer
	rtl8019Write(TPSR,TXSTART_INIT);
    2076:	60 e4       	ldi	r22, 0x40	; 64
    2078:	84 e0       	ldi	r24, 0x04	; 4
    207a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	//set start address for remote DMA operation
	rtl8019Write(RSAR0,0x00);
    207e:	60 e0       	ldi	r22, 0x00	; 0
    2080:	88 e0       	ldi	r24, 0x08	; 8
    2082:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RSAR1,0x40);
    2086:	60 e4       	ldi	r22, 0x40	; 64
    2088:	89 e0       	ldi	r24, 0x09	; 9
    208a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	//clear the packet stored interrupt
	rtl8019Write(ISR8019,(1<<ISR_PTX));
    208e:	62 e0       	ldi	r22, 0x02	; 2
    2090:	87 e0       	ldi	r24, 0x07	; 7
    2092:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	//load data byte count for remote DMA
	rtl8019Write(RBCR0, (unsigned char)(packetLength));
    2096:	60 2f       	mov	r22, r16
    2098:	8a e0       	ldi	r24, 0x0A	; 10
    209a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RBCR1, (unsigned char)(packetLength>>8));
    209e:	61 2f       	mov	r22, r17
    20a0:	77 27       	eor	r23, r23
    20a2:	8b e0       	ldi	r24, 0x0B	; 11
    20a4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	rtl8019Write(TBCR0, (unsigned char)(sendPacketLength));
    20a8:	6c 2f       	mov	r22, r28
    20aa:	85 e0       	ldi	r24, 0x05	; 5
    20ac:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(TBCR1, (unsigned char)((sendPacketLength)>>8));
    20b0:	6d 2f       	mov	r22, r29
    20b2:	77 27       	eor	r23, r23
    20b4:	86 e0       	ldi	r24, 0x06	; 6
    20b6:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	//do remote write operation
	rtl8019Write(CR,0x12);
    20ba:	62 e1       	ldi	r22, 0x12	; 18
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    20be:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    20c2:	df 91       	pop	r29
    20c4:	cf 91       	pop	r28
    20c6:	1f 91       	pop	r17
    20c8:	0f 91       	pop	r16
    20ca:	08 95       	ret

000020cc <rtl8019SendPacketData>:
}



void rtl8019SendPacketData(unsigned char * localBuffer, unsigned int length)
{
    20cc:	ef 92       	push	r14
    20ce:	ff 92       	push	r15
    20d0:	0f 93       	push	r16
    20d2:	1f 93       	push	r17
    20d4:	cf 93       	push	r28
    20d6:	df 93       	push	r29
    20d8:	7c 01       	movw	r14, r24
    20da:	8b 01       	movw	r16, r22
    20dc:	c0 e0       	ldi	r28, 0x00	; 0
    20de:	d0 e0       	ldi	r29, 0x00	; 0
    20e0:	08 c0       	rjmp	.+16     	; 0x20f2 <rtl8019SendPacketData+0x26>
	unsigned int i;

	for(i=0;i<length;i++)
		rtl8019Write(RDMAPORT, localBuffer[i]);
    20e2:	f7 01       	movw	r30, r14
    20e4:	ec 0f       	add	r30, r28
    20e6:	fd 1f       	adc	r31, r29
    20e8:	60 81       	ld	r22, Z
    20ea:	80 e1       	ldi	r24, 0x10	; 16
    20ec:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

void rtl8019SendPacketData(unsigned char * localBuffer, unsigned int length)
{
	unsigned int i;

	for(i=0;i<length;i++)
    20f0:	21 96       	adiw	r28, 0x01	; 1
    20f2:	c0 17       	cp	r28, r16
    20f4:	d1 07       	cpc	r29, r17
    20f6:	a9 f7       	brne	.-22     	; 0x20e2 <rtl8019SendPacketData+0x16>
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	1f 91       	pop	r17
    20fe:	0f 91       	pop	r16
    2100:	ff 90       	pop	r15
    2102:	ef 90       	pop	r14
    2104:	08 95       	ret

00002106 <rtl8019EndPacketSend>:


void rtl8019EndPacketSend(void)
{
	//send the contents of the transmit buffer onto the network
	rtl8019Write(CR,0x24);
    2106:	64 e2       	ldi	r22, 0x24	; 36
    2108:	80 e0       	ldi	r24, 0x00	; 0
    210a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	// clear the remote DMA interrupt
	rtl8019Write(ISR8019, (1<<ISR_RDC));
    210e:	60 e4       	ldi	r22, 0x40	; 64
    2110:	87 e0       	ldi	r24, 0x07	; 7
    2112:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2116:	08 95       	ret

00002118 <rtl8019RetreivePacketData>:
    return rxlen-4;
}


void rtl8019RetreivePacketData(unsigned char * localBuffer, unsigned int length)
{
    2118:	cf 92       	push	r12
    211a:	df 92       	push	r13
    211c:	ef 92       	push	r14
    211e:	ff 92       	push	r15
    2120:	0f 93       	push	r16
    2122:	1f 93       	push	r17
    2124:	cf 93       	push	r28
    2126:	df 93       	push	r29
    2128:	6c 01       	movw	r12, r24
    212a:	8b 01       	movw	r16, r22
	unsigned int i;

	// initiate DMA to transfer the data
    rtl8019Write(RBCR0, (unsigned char)length);
    212c:	8a e0       	ldi	r24, 0x0A	; 10
    212e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RBCR1, (unsigned char)(length>>8));
    2132:	61 2f       	mov	r22, r17
    2134:	77 27       	eor	r23, r23
    2136:	8b e0       	ldi	r24, 0x0B	; 11
    2138:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RSAR0, (unsigned char)currentRetreiveAddress);
    213c:	e0 90 79 00 	lds	r14, 0x0079
    2140:	f0 90 7a 00 	lds	r15, 0x007A
    2144:	6e 2d       	mov	r22, r14
    2146:	88 e0       	ldi	r24, 0x08	; 8
    2148:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RSAR1, (unsigned char)(currentRetreiveAddress>>8));
    214c:	6f 2d       	mov	r22, r15
    214e:	77 27       	eor	r23, r23
    2150:	89 e0       	ldi	r24, 0x09	; 9
    2152:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(CR, 0x0A);
    2156:	6a e0       	ldi	r22, 0x0A	; 10
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    215e:	c0 e0       	ldi	r28, 0x00	; 0
    2160:	d0 e0       	ldi	r29, 0x00	; 0
    2162:	08 c0       	rjmp	.+16     	; 0x2174 <rtl8019RetreivePacketData+0x5c>
	for(i=0;i<length;i++)
		localBuffer[i] = rtl8019Read(RDMAPORT);
    2164:	80 e1       	ldi	r24, 0x10	; 16
    2166:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    216a:	f6 01       	movw	r30, r12
    216c:	ec 0f       	add	r30, r28
    216e:	fd 1f       	adc	r31, r29
    2170:	80 83       	st	Z, r24
    rtl8019Write(RBCR0, (unsigned char)length);
    rtl8019Write(RBCR1, (unsigned char)(length>>8));
    rtl8019Write(RSAR0, (unsigned char)currentRetreiveAddress);
    rtl8019Write(RSAR1, (unsigned char)(currentRetreiveAddress>>8));
    rtl8019Write(CR, 0x0A);
	for(i=0;i<length;i++)
    2172:	21 96       	adiw	r28, 0x01	; 1
    2174:	c0 17       	cp	r28, r16
    2176:	d1 07       	cpc	r29, r17
    2178:	a9 f7       	brne	.-22     	; 0x2164 <rtl8019RetreivePacketData+0x4c>
		localBuffer[i] = rtl8019Read(RDMAPORT);

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    217a:	62 e2       	ldi	r22, 0x22	; 34
    217c:	80 e0       	ldi	r24, 0x00	; 0
    217e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2182:	c0 e0       	ldi	r28, 0x00	; 0
    2184:	d0 e0       	ldi	r29, 0x00	; 0
    for(i = 0; i <= 20; i++)
        if(rtl8019Read(ISR8019) & 1<<6)
    2186:	87 e0       	ldi	r24, 0x07	; 7
    2188:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    218c:	86 fd       	sbrc	r24, 6
    218e:	04 c0       	rjmp	.+8      	; 0x2198 <rtl8019RetreivePacketData+0x80>
	for(i=0;i<length;i++)
		localBuffer[i] = rtl8019Read(RDMAPORT);

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    for(i = 0; i <= 20; i++)
    2190:	21 96       	adiw	r28, 0x01	; 1
    2192:	c5 31       	cpi	r28, 0x15	; 21
    2194:	d1 05       	cpc	r29, r1
    2196:	b9 f7       	brne	.-18     	; 0x2186 <rtl8019RetreivePacketData+0x6e>
        if(rtl8019Read(ISR8019) & 1<<6)
            break;
    rtl8019Write(ISR8019, 1<<6);
    2198:	60 e4       	ldi	r22, 0x40	; 64
    219a:	87 e0       	ldi	r24, 0x07	; 7
    219c:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    currentRetreiveAddress += length;
    21a0:	b8 01       	movw	r22, r16
    21a2:	6e 0d       	add	r22, r14
    21a4:	7f 1d       	adc	r23, r15
    21a6:	70 93 7a 00 	sts	0x007A, r23
    21aa:	60 93 79 00 	sts	0x0079, r22
    if( currentRetreiveAddress >= 0x6000 )
    21ae:	80 e6       	ldi	r24, 0x60	; 96
    21b0:	60 30       	cpi	r22, 0x00	; 0
    21b2:	78 07       	cpc	r23, r24
    21b4:	30 f0       	brcs	.+12     	; 0x21c2 <rtl8019RetreivePacketData+0xaa>
    	currentRetreiveAddress = currentRetreiveAddress - (0x6000-0x4600) ;
    21b6:	60 50       	subi	r22, 0x00	; 0
    21b8:	7a 41       	sbci	r23, 0x1A	; 26
    21ba:	70 93 7a 00 	sts	0x007A, r23
    21be:	60 93 79 00 	sts	0x0079, r22
    21c2:	df 91       	pop	r29
    21c4:	cf 91       	pop	r28
    21c6:	1f 91       	pop	r17
    21c8:	0f 91       	pop	r16
    21ca:	ff 90       	pop	r15
    21cc:	ef 90       	pop	r14
    21ce:	df 90       	pop	r13
    21d0:	cf 90       	pop	r12
    21d2:	08 95       	ret

000021d4 <rtl8019EndPacketRetreive>:
}



void rtl8019EndPacketRetreive(void)
{
    21d4:	1f 93       	push	r17
	unsigned char i;

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    21d6:	62 e2       	ldi	r22, 0x22	; 34
    21d8:	80 e0       	ldi	r24, 0x00	; 0
    21da:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    21de:	10 e0       	ldi	r17, 0x00	; 0
    for(i = 0; i <= 20; i++)
        if(rtl8019Read(ISR8019) & 1<<6)
    21e0:	87 e0       	ldi	r24, 0x07	; 7
    21e2:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    21e6:	86 fd       	sbrc	r24, 6
    21e8:	03 c0       	rjmp	.+6      	; 0x21f0 <rtl8019EndPacketRetreive+0x1c>
{
	unsigned char i;

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    for(i = 0; i <= 20; i++)
    21ea:	1f 5f       	subi	r17, 0xFF	; 255
    21ec:	15 31       	cpi	r17, 0x15	; 21
    21ee:	c1 f7       	brne	.-16     	; 0x21e0 <rtl8019EndPacketRetreive+0xc>
        if(rtl8019Read(ISR8019) & 1<<6)
            break;
    rtl8019Write(ISR8019, 1<<6);
    21f0:	60 e4       	ldi	r22, 0x40	; 64
    21f2:	87 e0       	ldi	r24, 0x07	; 7
    21f4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	// set the boundary register to point to the start of the next packet
    rtl8019Write(BNRY, nextPage);
    21f8:	60 91 78 00 	lds	r22, 0x0078
    21fc:	83 e0       	ldi	r24, 0x03	; 3
    21fe:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2202:	1f 91       	pop	r17
    2204:	08 95       	ret

00002206 <rtl8019_read_eeprom_word>:
*  Description: Read the 93LC46 EEPROM containing Ethernet MAC (NE2000 Standard)
*               connected to the rtl8019
*****************************************************************************/
#ifdef MAC_FROM_EEPROM
unsigned int rtl8019_read_eeprom_word(unsigned char adr)
{
    2206:	0f 93       	push	r16
    2208:	1f 93       	push	r17
    220a:	cf 93       	push	r28
    220c:	df 93       	push	r29
	unsigned char i, temp;
	unsigned int  result;

	temp = ((adr & 0x1F) | 0x80);
    220e:	18 2f       	mov	r17, r24
    2210:	1f 71       	andi	r17, 0x1F	; 31
    2212:	10 68       	ori	r17, 0x80	; 128

	rtl8019Write(CR, 0xE1);			// Page 3
    2214:	61 ee       	ldi	r22, 0xE1	; 225
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RTL_EECR, 0x80); // 9346 programming
    221c:	60 e8       	ldi	r22, 0x80	; 128
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RTL_EECR, 0x84); // 9346 programming CLK on
    2224:	64 e8       	ldi	r22, 0x84	; 132
    2226:	81 e0       	ldi	r24, 0x01	; 1
    2228:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RTL_EECR, 0x80); // 9346 programming CKL off
    222c:	60 e8       	ldi	r22, 0x80	; 128
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	rtl8019Write(RTL_EECR, 0x8A); // 9346 programming CS on Data on
    2234:	6a e8       	ldi	r22, 0x8A	; 138
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RTL_EECR, 0x8E); // 9346 programming CLK on
    223c:	6e e8       	ldi	r22, 0x8E	; 142
    223e:	81 e0       	ldi	r24, 0x01	; 1
    2240:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RTL_EECR, 0x8A); // 9346 programming CKL off
    2244:	6a e8       	ldi	r22, 0x8A	; 138
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    224c:	c7 e0       	ldi	r28, 0x07	; 7
    224e:	d0 e0       	ldi	r29, 0x00	; 0

	for(i=0;i<8;i++)  // Write "read" Command and Word-Adress
	{
		if( (temp >> (7-i)) & 0x01 )
    2250:	01 2f       	mov	r16, r17
    2252:	11 27       	eor	r17, r17
    2254:	c8 01       	movw	r24, r16
    2256:	0c 2e       	mov	r0, r28
    2258:	02 c0       	rjmp	.+4      	; 0x225e <rtl8019_read_eeprom_word+0x58>
    225a:	95 95       	asr	r25
    225c:	87 95       	ror	r24
    225e:	0a 94       	dec	r0
    2260:	e2 f7       	brpl	.-8      	; 0x225a <rtl8019_read_eeprom_word+0x54>
    2262:	80 ff       	sbrs	r24, 0
    2264:	0a c0       	rjmp	.+20     	; 0x227a <rtl8019_read_eeprom_word+0x74>
		{
			rtl8019Write(RTL_EECR, 0x8A); // 9346 programming DI on
    2266:	6a e8       	ldi	r22, 0x8A	; 138
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
			rtl8019Write(RTL_EECR, 0x8E); // 9346 programming CLK on
    226e:	6e e8       	ldi	r22, 0x8E	; 142
    2270:	81 e0       	ldi	r24, 0x01	; 1
    2272:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
			rtl8019Write(RTL_EECR, 0x8A); // 9346 programming CKL off
    2276:	6a e8       	ldi	r22, 0x8A	; 138
    2278:	09 c0       	rjmp	.+18     	; 0x228c <rtl8019_read_eeprom_word+0x86>
			}
		else
		{
			rtl8019Write(RTL_EECR, 0x88); // 9346 programming DI off
    227a:	68 e8       	ldi	r22, 0x88	; 136
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
			rtl8019Write(RTL_EECR, 0x8C); // 9346 programming CLK on
    2282:	6c e8       	ldi	r22, 0x8C	; 140
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
			rtl8019Write(RTL_EECR, 0x88); // 9346 programming CKL off
    228a:	68 e8       	ldi	r22, 0x88	; 136
    228c:	81 e0       	ldi	r24, 0x01	; 1
    228e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2292:	21 97       	sbiw	r28, 0x01	; 1

	rtl8019Write(RTL_EECR, 0x8A); // 9346 programming CS on Data on
	rtl8019Write(RTL_EECR, 0x8E); // 9346 programming CLK on
	rtl8019Write(RTL_EECR, 0x8A); // 9346 programming CKL off

	for(i=0;i<8;i++)  // Write "read" Command and Word-Adress
    2294:	8f ef       	ldi	r24, 0xFF	; 255
    2296:	cf 3f       	cpi	r28, 0xFF	; 255
    2298:	d8 07       	cpc	r29, r24
    229a:	e1 f6       	brne	.-72     	; 0x2254 <rtl8019_read_eeprom_word+0x4e>
			rtl8019Write(RTL_EECR, 0x88); // 9346 programming DI off
			rtl8019Write(RTL_EECR, 0x8C); // 9346 programming CLK on
			rtl8019Write(RTL_EECR, 0x88); // 9346 programming CKL off
		}
	}
	rtl8019Write(RTL_EECR, 0x88); // 9346 programming DI off
    229c:	68 e8       	ldi	r22, 0x88	; 136
    229e:	81 e0       	ldi	r24, 0x01	; 1
    22a0:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    22a4:	00 e0       	ldi	r16, 0x00	; 0
    22a6:	10 e0       	ldi	r17, 0x00	; 0
    22a8:	cf e0       	ldi	r28, 0x0F	; 15
    22aa:	d0 e0       	ldi	r29, 0x00	; 0

	result = 0;

	for(i=0;i<16;i++)	// Read 16 Bits of Data
	{
		rtl8019Write(RTL_EECR, 0x8C); // 9346 programming CLK on
    22ac:	6c e8       	ldi	r22, 0x8C	; 140
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
		rtl8019Write(RTL_EECR, 0x88); // 9346 programming CKL off
    22b4:	68 e8       	ldi	r22, 0x88	; 136
    22b6:	81 e0       	ldi	r24, 0x01	; 1
    22b8:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
		if( (rtl8019Read(RTL_EECR)) & 0x01)
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    22c2:	80 ff       	sbrs	r24, 0
    22c4:	0a c0       	rjmp	.+20     	; 0x22da <rtl8019_read_eeprom_word+0xd4>
		{
			result |= (1 << (15-i));
    22c6:	81 e0       	ldi	r24, 0x01	; 1
    22c8:	90 e0       	ldi	r25, 0x00	; 0
    22ca:	0c 2e       	mov	r0, r28
    22cc:	02 c0       	rjmp	.+4      	; 0x22d2 <rtl8019_read_eeprom_word+0xcc>
    22ce:	88 0f       	add	r24, r24
    22d0:	99 1f       	adc	r25, r25
    22d2:	0a 94       	dec	r0
    22d4:	e2 f7       	brpl	.-8      	; 0x22ce <rtl8019_read_eeprom_word+0xc8>
    22d6:	08 2b       	or	r16, r24
    22d8:	19 2b       	or	r17, r25
    22da:	21 97       	sbiw	r28, 0x01	; 1
	}
	rtl8019Write(RTL_EECR, 0x88); // 9346 programming DI off

	result = 0;

	for(i=0;i<16;i++)	// Read 16 Bits of Data
    22dc:	8f ef       	ldi	r24, 0xFF	; 255
    22de:	cf 3f       	cpi	r28, 0xFF	; 255
    22e0:	d8 07       	cpc	r29, r24
    22e2:	21 f7       	brne	.-56     	; 0x22ac <rtl8019_read_eeprom_word+0xa6>
		if( (rtl8019Read(RTL_EECR)) & 0x01)
		{
			result |= (1 << (15-i));
		}
	}
	rtl8019Write(RTL_EECR, 0x80); // 9346 programming CS off
    22e4:	60 e8       	ldi	r22, 0x80	; 128
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	return result;
}
    22ec:	c8 01       	movw	r24, r16
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	1f 91       	pop	r17
    22f4:	0f 91       	pop	r16
    22f6:	08 95       	ret

000022f8 <rtl8019Init>:
#endif


void rtl8019Init(void)
{
    22f8:	ef 92       	push	r14
    22fa:	ff 92       	push	r15
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	cd b7       	in	r28, 0x3d	; 61
    2306:	de b7       	in	r29, 0x3e	; 62
    2308:	26 97       	sbiw	r28, 0x06	; 6
    230a:	0f b6       	in	r0, 0x3f	; 63
    230c:	f8 94       	cli
    230e:	de bf       	out	0x3e, r29	; 62
    2310:	0f be       	out	0x3f, r0	; 63
    2312:	cd bf       	out	0x3d, r28	; 61
	struct uip_eth_addr eth_adr;
	unsigned char i;
	unsigned int  temp;
#endif

	rtl8019SetupPorts();
    2314:	0e 94 1d 10 	call	0x203a	; 0x203a <rtl8019SetupPorts>

	HARD_RESET_RTL8019();
    2318:	c0 9a       	sbi	0x18, 0	; 24
    231a:	8a e0       	ldi	r24, 0x0A	; 10
    231c:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
    2320:	c0 98       	cbi	0x18, 0	; 24

	// do soft reset
	rtl8019Write( ISR8019, rtl8019Read(ISR8019) ) ;
    2322:	87 e0       	ldi	r24, 0x07	; 7
    2324:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    2328:	68 2f       	mov	r22, r24
    232a:	87 e0       	ldi	r24, 0x07	; 7
    232c:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	delay_ms(20);
    2330:	84 e1       	ldi	r24, 0x14	; 20
    2332:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>

    // switch to page 3 to load config registers
    rtl8019Write(CR, 0xE1);
    2336:	61 ee       	ldi	r22, 0xE1	; 225
    2338:	80 e0       	ldi	r24, 0x00	; 0
    233a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    // disable EEPROM write protect of config registers
    rtl8019Write(RTL_EECR, 0xC0);
    233e:	60 ec       	ldi	r22, 0xC0	; 192
    2340:	81 e0       	ldi	r24, 0x01	; 1
    2342:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    // set network type to 10 Base-T link test
  	 rtl8019Write(CONFIG2, 0x20);
    2346:	60 e2       	ldi	r22, 0x20	; 32
    2348:	85 e0       	ldi	r24, 0x05	; 5
    234a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    // disable powerdown and sleep
  	  rtl8019Write(CONFIG3, 0x00);
    234e:	60 e0       	ldi	r22, 0x00	; 0
    2350:	86 e0       	ldi	r24, 0x06	; 6
    2352:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    delay_ms(20);
    2356:	84 e1       	ldi	r24, 0x14	; 20
    2358:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
    235c:	8e 01       	movw	r16, r28
    235e:	0f 5f       	subi	r16, 0xFF	; 255
    2360:	1f 4f       	sbci	r17, 0xFF	; 255
    2362:	52 e0       	ldi	r21, 0x02	; 2
    2364:	f5 2e       	mov	r15, r21

#ifdef MAC_FROM_EEPROM
	// read Ethernet MAC from EEPROM
	for(i=0;i<3;i++)
	{
		temp = rtl8019_read_eeprom_word(0x02+i);
    2366:	8f 2d       	mov	r24, r15
    2368:	0e 94 03 11 	call	0x2206	; 0x2206 <rtl8019_read_eeprom_word>
		eth_adr.addr[(2*i)+1] = temp >> 8;
    236c:	29 2f       	mov	r18, r25
    236e:	33 27       	eor	r19, r19
    2370:	f8 01       	movw	r30, r16
    2372:	21 83       	std	Z+1, r18	; 0x01
		eth_adr.addr[(2*i)] = temp & 0x00FF;
    2374:	80 83       	st	Z, r24
    2376:	f3 94       	inc	r15
    2378:	0e 5f       	subi	r16, 0xFE	; 254
    237a:	1f 4f       	sbci	r17, 0xFF	; 255
  	  rtl8019Write(CONFIG3, 0x00);
    delay_ms(20);

#ifdef MAC_FROM_EEPROM
	// read Ethernet MAC from EEPROM
	for(i=0;i<3;i++)
    237c:	f5 e0       	ldi	r31, 0x05	; 5
    237e:	ff 16       	cp	r15, r31
    2380:	91 f7       	brne	.-28     	; 0x2366 <rtl8019Init+0x6e>
		eth_adr.addr[(2*i)] = temp & 0x00FF;
	}
#endif

    // reenable EEPROM write protect
    rtl8019Write(RTL_EECR, 0x00);
    2382:	60 e0       	ldi	r22, 0x00	; 0
    2384:	81 e0       	ldi	r24, 0x01	; 1
    2386:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    // go back to page 0

   rtl8019Write(CR,0x21);       // stop the NIC, abort DMA, page 0
    238a:	61 e2       	ldi	r22, 0x21	; 33
    238c:	80 e0       	ldi	r24, 0x00	; 0
    238e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	delay_ms(2);               // make sure nothing is coming in or going out
    2392:	82 e0       	ldi	r24, 0x02	; 2
    2394:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
	rtl8019Write(DCR, DCR_INIT);    // 0x58
    2398:	68 e5       	ldi	r22, 0x58	; 88
    239a:	8e e0       	ldi	r24, 0x0E	; 14
    239c:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RBCR0,0x00);
    23a0:	60 e0       	ldi	r22, 0x00	; 0
    23a2:	8a e0       	ldi	r24, 0x0A	; 10
    23a4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RBCR1,0x00);
    23a8:	60 e0       	ldi	r22, 0x00	; 0
    23aa:	8b e0       	ldi	r24, 0x0B	; 11
    23ac:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RCR,0x04);
    23b0:	64 e0       	ldi	r22, 0x04	; 4
    23b2:	8c e0       	ldi	r24, 0x0C	; 12
    23b4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(TPSR, TXSTART_INIT);
    23b8:	60 e4       	ldi	r22, 0x40	; 64
    23ba:	84 e0       	ldi	r24, 0x04	; 4
    23bc:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(TCR,0x02);
    23c0:	62 e0       	ldi	r22, 0x02	; 2
    23c2:	8d e0       	ldi	r24, 0x0D	; 13
    23c4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(PSTART, RXSTART_INIT);
    23c8:	66 e4       	ldi	r22, 0x46	; 70
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(BNRY, RXSTART_INIT);
    23d0:	66 e4       	ldi	r22, 0x46	; 70
    23d2:	83 e0       	ldi	r24, 0x03	; 3
    23d4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(PSTOP, RXSTOP_INIT);
    23d8:	60 e6       	ldi	r22, 0x60	; 96
    23da:	82 e0       	ldi	r24, 0x02	; 2
    23dc:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CR, 0x61);
    23e0:	61 e6       	ldi	r22, 0x61	; 97
    23e2:	80 e0       	ldi	r24, 0x00	; 0
    23e4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	delay_ms(2);
    23e8:	82 e0       	ldi	r24, 0x02	; 2
    23ea:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
	rtl8019Write(CURR, RXSTART_INIT);
    23ee:	66 e4       	ldi	r22, 0x46	; 70
    23f0:	87 e0       	ldi	r24, 0x07	; 7
    23f2:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	rtl8019Write(CR, 0x61); //Page 1
    23f6:	61 e6       	ldi	r22, 0x61	; 97
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    23fe:	7e 01       	movw	r14, r28
    2400:	08 94       	sec
    2402:	e1 1c       	adc	r14, r1
    2404:	f1 1c       	adc	r15, r1
    2406:	10 e0       	ldi	r17, 0x00	; 0

#ifdef MAC_FROM_EEPROM
	for(i=0;i<6;i++)			// write MAC from EEPROM to rtl8019 Registers
	{
		rtl8019Write((PAR0+i)<<ADDRESS_SHIFT,eth_adr.addr[i]);
    2408:	1f 5f       	subi	r17, 0xFF	; 255
    240a:	f7 01       	movw	r30, r14
    240c:	61 91       	ld	r22, Z+
    240e:	7f 01       	movw	r14, r30
    2410:	81 2f       	mov	r24, r17
    2412:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CURR, RXSTART_INIT);

	rtl8019Write(CR, 0x61); //Page 1

#ifdef MAC_FROM_EEPROM
	for(i=0;i<6;i++)			// write MAC from EEPROM to rtl8019 Registers
    2416:	16 30       	cpi	r17, 0x06	; 6
    2418:	b9 f7       	brne	.-18     	; 0x2408 <rtl8019Init+0x110>
#ifdef DISPLAY_MAC
	lcd_puts_P(PSTR("   "));
#endif

#ifdef MAC_FROM_EEPROM	// write MAC to the ARP-Module
	uip_setethaddr(eth_adr);
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	80 93 6d 00 	sts	0x006D, r24
    2420:	8a 81       	ldd	r24, Y+2	; 0x02
    2422:	80 93 6e 00 	sts	0x006E, r24
    2426:	8b 81       	ldd	r24, Y+3	; 0x03
    2428:	80 93 6f 00 	sts	0x006F, r24
    242c:	8c 81       	ldd	r24, Y+4	; 0x04
    242e:	80 93 70 00 	sts	0x0070, r24
    2432:	8d 81       	ldd	r24, Y+5	; 0x05
    2434:	80 93 71 00 	sts	0x0071, r24
    2438:	8e 81       	ldd	r24, Y+6	; 0x06
    243a:	80 93 72 00 	sts	0x0072, r24
#endif

	rtl8019Write(CR,0x21);
    243e:	61 e2       	ldi	r22, 0x21	; 33
    2440:	80 e0       	ldi	r24, 0x00	; 0
    2442:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(DCR, DCR_INIT);
    2446:	68 e5       	ldi	r22, 0x58	; 88
    2448:	8e e0       	ldi	r24, 0x0E	; 14
    244a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CR,0x22);
    244e:	62 e2       	ldi	r22, 0x22	; 34
    2450:	80 e0       	ldi	r24, 0x00	; 0
    2452:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(ISR8019,0xFF);
    2456:	6f ef       	ldi	r22, 0xFF	; 255
    2458:	87 e0       	ldi	r24, 0x07	; 7
    245a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(IMR, IMR_INIT);
    245e:	61 e1       	ldi	r22, 0x11	; 17
    2460:	8f e0       	ldi	r24, 0x0F	; 15
    2462:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(TCR, TCR_INIT);
    2466:	60 e0       	ldi	r22, 0x00	; 0
    2468:	8d e0       	ldi	r24, 0x0D	; 13
    246a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	rtl8019Write(CR, 0x22);	// start the NIC
    246e:	62 e2       	ldi	r22, 0x22	; 34
    2470:	80 e0       	ldi	r24, 0x00	; 0
    2472:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2476:	26 96       	adiw	r28, 0x06	; 6
    2478:	0f b6       	in	r0, 0x3f	; 63
    247a:	f8 94       	cli
    247c:	de bf       	out	0x3e, r29	; 62
    247e:	0f be       	out	0x3f, r0	; 63
    2480:	cd bf       	out	0x3d, r28	; 61
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	1f 91       	pop	r17
    2488:	0f 91       	pop	r16
    248a:	ff 90       	pop	r15
    248c:	ef 90       	pop	r14
    248e:	08 95       	ret

00002490 <rtl8019Overrun>:
    rtl8019Write(BNRY, nextPage);
}


void rtl8019Overrun(void)
{
    2490:	1f 93       	push	r17
	unsigned char data_L, resend;

	data_L = rtl8019Read(CR);
    2492:	80 e0       	ldi	r24, 0x00	; 0
    2494:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    2498:	18 2f       	mov	r17, r24
	rtl8019Write(CR, 0x21);
    249a:	61 e2       	ldi	r22, 0x21	; 33
    249c:	80 e0       	ldi	r24, 0x00	; 0
    249e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	delay_ms(2);
    24a2:	82 e0       	ldi	r24, 0x02	; 2
    24a4:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <delay_ms>
	rtl8019Write(RBCR0, 0x00);
    24a8:	60 e0       	ldi	r22, 0x00	; 0
    24aa:	8a e0       	ldi	r24, 0x0A	; 10
    24ac:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(RBCR1, 0x00);
    24b0:	60 e0       	ldi	r22, 0x00	; 0
    24b2:	8b e0       	ldi	r24, 0x0B	; 11
    24b4:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	if(!(data_L & 0x04))
    24b8:	12 ff       	sbrs	r17, 2
    24ba:	0a c0       	rjmp	.+20     	; 0x24d0 <rtl8019Overrun+0x40>
		resend = 0;
	else if(data_L & 0x04)
	{
		data_L = rtl8019Read(ISR8019);
    24bc:	87 e0       	ldi	r24, 0x07	; 7
    24be:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
		if((data_L & 0x02) || (data_L & 0x08))
    24c2:	99 27       	eor	r25, r25
    24c4:	81 fd       	sbrc	r24, 1
    24c6:	04 c0       	rjmp	.+8      	; 0x24d0 <rtl8019Overrun+0x40>
    24c8:	83 fd       	sbrc	r24, 3
    24ca:	02 c0       	rjmp	.+4      	; 0x24d0 <rtl8019Overrun+0x40>
    24cc:	11 e0       	ldi	r17, 0x01	; 1
    24ce:	01 c0       	rjmp	.+2      	; 0x24d2 <rtl8019Overrun+0x42>
    24d0:	10 e0       	ldi	r17, 0x00	; 0
	    	resend = 0;
	    else
	    	resend = 1;
	}

	rtl8019Write(TCR, 0x02);
    24d2:	62 e0       	ldi	r22, 0x02	; 2
    24d4:	8d e0       	ldi	r24, 0x0D	; 13
    24d6:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CR, 0x22);
    24da:	62 e2       	ldi	r22, 0x22	; 34
    24dc:	80 e0       	ldi	r24, 0x00	; 0
    24de:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(BNRY, RXSTART_INIT);
    24e2:	66 e4       	ldi	r22, 0x46	; 70
    24e4:	83 e0       	ldi	r24, 0x03	; 3
    24e6:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CR, 0x62);
    24ea:	62 e6       	ldi	r22, 0x62	; 98
    24ec:	80 e0       	ldi	r24, 0x00	; 0
    24ee:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CURR, RXSTART_INIT);
    24f2:	66 e4       	ldi	r22, 0x46	; 70
    24f4:	87 e0       	ldi	r24, 0x07	; 7
    24f6:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(CR, 0x22);
    24fa:	62 e2       	ldi	r22, 0x22	; 34
    24fc:	80 e0       	ldi	r24, 0x00	; 0
    24fe:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(ISR8019, 0x10);
    2502:	60 e1       	ldi	r22, 0x10	; 16
    2504:	87 e0       	ldi	r24, 0x07	; 7
    2506:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	rtl8019Write(TCR, TCR_INIT);
    250a:	60 e0       	ldi	r22, 0x00	; 0
    250c:	8d e0       	ldi	r24, 0x0D	; 13
    250e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    if(resend)
    2512:	11 23       	and	r17, r17
    2514:	21 f0       	breq	.+8      	; 0x251e <rtl8019Overrun+0x8e>
        rtl8019Write(CR, 0x26);
    2516:	66 e2       	ldi	r22, 0x26	; 38
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

    rtl8019Write(ISR8019, 0xFF);
    251e:	6f ef       	ldi	r22, 0xFF	; 255
    2520:	87 e0       	ldi	r24, 0x07	; 7
    2522:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2526:	1f 91       	pop	r17
    2528:	08 95       	ret

0000252a <rtl8019ProcessInterrupt>:
}


void rtl8019ProcessInterrupt(void)
{
	unsigned char byte = rtl8019Read(ISR8019);
    252a:	87 e0       	ldi	r24, 0x07	; 7
    252c:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>

	if( byte & (1<<ISR_OVW) )
    2530:	84 ff       	sbrs	r24, 4
    2532:	02 c0       	rjmp	.+4      	; 0x2538 <rtl8019ProcessInterrupt+0xe>
		rtl8019Overrun();
    2534:	0e 94 48 12 	call	0x2490	; 0x2490 <rtl8019Overrun>
    2538:	08 95       	ret

0000253a <rtl8019BeginPacketRetreive>:
#define	 enetpacketLenL       0x02
#define	 enetpacketLenH       0x03


unsigned int rtl8019BeginPacketRetreive(void)
{
    253a:	df 92       	push	r13
    253c:	ef 92       	push	r14
    253e:	ff 92       	push	r15
    2540:	0f 93       	push	r16
    2542:	1f 93       	push	r17
    2544:	cf 93       	push	r28
    2546:	df 93       	push	r29
    2548:	cd b7       	in	r28, 0x3d	; 61
    254a:	de b7       	in	r29, 0x3e	; 62
    254c:	24 97       	sbiw	r28, 0x04	; 4
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	de bf       	out	0x3e, r29	; 62
    2554:	0f be       	out	0x3f, r0	; 63
    2556:	cd bf       	out	0x3d, r28	; 61

	unsigned char pageheader[4];
	unsigned int rxlen;

	// check for and handle an overflow
	rtl8019ProcessInterrupt();
    2558:	0e 94 95 12 	call	0x252a	; 0x252a <rtl8019ProcessInterrupt>

	// read CURR from page 1
	rtl8019Write(CR,0x62);
    255c:	62 e6       	ldi	r22, 0x62	; 98
    255e:	80 e0       	ldi	r24, 0x00	; 0
    2560:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
	i = rtl8019Read(CURR);
    2564:	87 e0       	ldi	r24, 0x07	; 7
    2566:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    256a:	18 2f       	mov	r17, r24

	// return to page 0
	rtl8019Write(CR,0x22);
    256c:	62 e2       	ldi	r22, 0x22	; 34
    256e:	80 e0       	ldi	r24, 0x00	; 0
    2570:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	// read the boundary register - pointing to the beginning of the packet
	bnry = rtl8019Read(BNRY) ;
    2574:	83 e0       	ldi	r24, 0x03	; 3
    2576:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    257a:	d8 2e       	mov	r13, r24

	// return if there is no packet in the buffer
	if( bnry == i )
    257c:	81 17       	cp	r24, r17
    257e:	09 f4       	brne	.+2      	; 0x2582 <rtl8019BeginPacketRetreive+0x48>
    2580:	68 c0       	rjmp	.+208    	; 0x2652 <rtl8019BeginPacketRetreive+0x118>
		return 0;


	// clear the packet received interrupt flag
	rtl8019Write(ISR8019, (1<<ISR_PRX));
    2582:	61 e0       	ldi	r22, 0x01	; 1
    2584:	87 e0       	ldi	r24, 0x07	; 7
    2586:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>

	// the boundary pointer is invalid, reset the contents of the buffer and exit
	if( (bnry >= RXSTOP_INIT) || (bnry < RXSTART_INIT) )
    258a:	8d 2d       	mov	r24, r13
    258c:	86 54       	subi	r24, 0x46	; 70
    258e:	8a 31       	cpi	r24, 0x1A	; 26
    2590:	88 f0       	brcs	.+34     	; 0x25b4 <rtl8019BeginPacketRetreive+0x7a>
	{
		rtl8019Write(BNRY, RXSTART_INIT);
    2592:	66 e4       	ldi	r22, 0x46	; 70
    2594:	83 e0       	ldi	r24, 0x03	; 3
    2596:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
		rtl8019Write(CR, 0x62);
    259a:	62 e6       	ldi	r22, 0x62	; 98
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
		rtl8019Write(CURR, RXSTART_INIT);
    25a2:	66 e4       	ldi	r22, 0x46	; 70
    25a4:	87 e0       	ldi	r24, 0x07	; 7
    25a6:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
		rtl8019Write(CR, 0x22);
    25aa:	62 e2       	ldi	r22, 0x22	; 34
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    25b2:	4f c0       	rjmp	.+158    	; 0x2652 <rtl8019BeginPacketRetreive+0x118>

		return 0;
	}

	// initiate DMA to transfer the RTL8019 packet header
    rtl8019Write(RBCR0, 4);
    25b4:	64 e0       	ldi	r22, 0x04	; 4
    25b6:	8a e0       	ldi	r24, 0x0A	; 10
    25b8:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RBCR1, 0);
    25bc:	60 e0       	ldi	r22, 0x00	; 0
    25be:	8b e0       	ldi	r24, 0x0B	; 11
    25c0:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RSAR0, 0);
    25c4:	60 e0       	ldi	r22, 0x00	; 0
    25c6:	88 e0       	ldi	r24, 0x08	; 8
    25c8:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(RSAR1, bnry);
    25cc:	6d 2d       	mov	r22, r13
    25ce:	89 e0       	ldi	r24, 0x09	; 9
    25d0:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    rtl8019Write(CR, 0x0A);
    25d4:	6a e0       	ldi	r22, 0x0A	; 10
    25d6:	80 e0       	ldi	r24, 0x00	; 0
    25d8:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    25dc:	8e 01       	movw	r16, r28
    25de:	0f 5f       	subi	r16, 0xFF	; 255
    25e0:	1f 4f       	sbci	r17, 0xFF	; 255
	for(i=0;i<4;i++)
    25e2:	e5 e0       	ldi	r30, 0x05	; 5
    25e4:	ee 2e       	mov	r14, r30
    25e6:	f1 2c       	mov	r15, r1
    25e8:	ec 0e       	add	r14, r28
    25ea:	fd 1e       	adc	r15, r29
		pageheader[i] = rtl8019Read(RDMAPORT);
    25ec:	80 e1       	ldi	r24, 0x10	; 16
    25ee:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    25f2:	f8 01       	movw	r30, r16
    25f4:	81 93       	st	Z+, r24
    25f6:	8f 01       	movw	r16, r30
    rtl8019Write(RBCR0, 4);
    rtl8019Write(RBCR1, 0);
    rtl8019Write(RSAR0, 0);
    rtl8019Write(RSAR1, bnry);
    rtl8019Write(CR, 0x0A);
	for(i=0;i<4;i++)
    25f8:	ee 15       	cp	r30, r14
    25fa:	ff 05       	cpc	r31, r15
    25fc:	b9 f7       	brne	.-18     	; 0x25ec <rtl8019BeginPacketRetreive+0xb2>
		pageheader[i] = rtl8019Read(RDMAPORT);

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    25fe:	62 e2       	ldi	r22, 0x22	; 34
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>
    2606:	10 e0       	ldi	r17, 0x00	; 0
    for(i = 0; i <= 20; i++)
        if(rtl8019Read(ISR8019) & 1<<6)
    2608:	87 e0       	ldi	r24, 0x07	; 7
    260a:	0e 94 12 10 	call	0x2024	; 0x2024 <rtl8019Read>
    260e:	86 fd       	sbrc	r24, 6
    2610:	03 c0       	rjmp	.+6      	; 0x2618 <rtl8019BeginPacketRetreive+0xde>
	for(i=0;i<4;i++)
		pageheader[i] = rtl8019Read(RDMAPORT);

	// end the DMA operation
    rtl8019Write(CR, 0x22);
    for(i = 0; i <= 20; i++)
    2612:	1f 5f       	subi	r17, 0xFF	; 255
    2614:	15 31       	cpi	r17, 0x15	; 21
    2616:	c1 f7       	brne	.-16     	; 0x2608 <rtl8019BeginPacketRetreive+0xce>
        if(rtl8019Read(ISR8019) & 1<<6)
            break;
    rtl8019Write(ISR8019, 1<<6);
    2618:	60 e4       	ldi	r22, 0x40	; 64
    261a:	87 e0       	ldi	r24, 0x07	; 7
    261c:	0e 94 04 10 	call	0x2008	; 0x2008 <rtl8019Write>


	rxlen = (pageheader[enetpacketLenH]<<8) + pageheader[enetpacketLenL];
    2620:	3c 81       	ldd	r19, Y+4	; 0x04
    2622:	4b 81       	ldd	r20, Y+3	; 0x03
	nextPage = pageheader[nextblock_ptr] ;
    2624:	2a 81       	ldd	r18, Y+2	; 0x02
    2626:	20 93 78 00 	sts	0x0078, r18

	currentRetreiveAddress = (bnry<<8) + 4;
    262a:	8d 2d       	mov	r24, r13
    262c:	99 27       	eor	r25, r25
    262e:	98 2f       	mov	r25, r24
    2630:	88 27       	eor	r24, r24
    2632:	04 96       	adiw	r24, 0x04	; 4
    2634:	90 93 7a 00 	sts	0x007A, r25
    2638:	80 93 79 00 	sts	0x0079, r24

	// if the nextPage pointer is invalid, the packet is not ready yet - exit
	if( (nextPage >= RXSTOP_INIT) || (nextPage < RXSTART_INIT) )
    263c:	26 54       	subi	r18, 0x46	; 70
    263e:	2a 31       	cpi	r18, 0x1A	; 26
    2640:	40 f4       	brcc	.+16     	; 0x2652 <rtl8019BeginPacketRetreive+0x118>
		return 0;

    return rxlen-4;
    2642:	83 2f       	mov	r24, r19
    2644:	99 27       	eor	r25, r25
    2646:	98 2f       	mov	r25, r24
    2648:	88 27       	eor	r24, r24
    264a:	84 0f       	add	r24, r20
    264c:	91 1d       	adc	r25, r1
    264e:	04 97       	sbiw	r24, 0x04	; 4
    2650:	02 c0       	rjmp	.+4      	; 0x2656 <rtl8019BeginPacketRetreive+0x11c>
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	24 96       	adiw	r28, 0x04	; 4
    2658:	0f b6       	in	r0, 0x3f	; 63
    265a:	f8 94       	cli
    265c:	de bf       	out	0x3e, r29	; 62
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	cd bf       	out	0x3d, r28	; 61
    2662:	df 91       	pop	r29
    2664:	cf 91       	pop	r28
    2666:	1f 91       	pop	r17
    2668:	0f 91       	pop	r16
    266a:	ff 90       	pop	r15
    266c:	ef 90       	pop	r14
    266e:	df 90       	pop	r13
    2670:	08 95       	ret

00002672 <nic_poll>:
#if UIP_BUFSIZE > 255
unsigned int nic_poll(void)
#else 
unsigned char nic_poll(void)
#endif /* UIP_BUFSIZE > 255 */
{
    2672:	cf 93       	push	r28
    2674:	df 93       	push	r29
	unsigned int packetLength;
	
	packetLength = NICBeginPacketRetreive();
    2676:	0e 94 9d 12 	call	0x253a	; 0x253a <rtl8019BeginPacketRetreive>
    267a:	ec 01       	movw	r28, r24

	// if there's no packet or an error - exit without ending the operation
	if( !packetLength )
    267c:	89 2b       	or	r24, r25
    267e:	81 f0       	breq	.+32     	; 0x26a0 <nic_poll+0x2e>
	  return 0;

	// drop anything too big for the buffer
	if( packetLength > UIP_BUFSIZE )
    2680:	82 e0       	ldi	r24, 0x02	; 2
    2682:	c7 33       	cpi	r28, 0x37	; 55
    2684:	d8 07       	cpc	r29, r24
    2686:	28 f0       	brcs	.+10     	; 0x2692 <nic_poll+0x20>
	{
	  NICEndPacketRetreive();
    2688:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <rtl8019EndPacketRetreive>
    268c:	c0 e0       	ldi	r28, 0x00	; 0
    268e:	d0 e0       	ldi	r29, 0x00	; 0
    2690:	07 c0       	rjmp	.+14     	; 0x26a0 <nic_poll+0x2e>
          return 0;
	}
	
	// copy the packet data into the uIP packet buffer
	NICRetreivePacketData( uip_buf, packetLength );
    2692:	be 01       	movw	r22, r28
    2694:	8a e6       	ldi	r24, 0x6A	; 106
    2696:	93 e0       	ldi	r25, 0x03	; 3
    2698:	0e 94 8c 10 	call	0x2118	; 0x2118 <rtl8019RetreivePacketData>
	NICEndPacketRetreive();
    269c:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <rtl8019EndPacketRetreive>
	return packetLength;
#else 
	return (unsigned char)packetLength;
#endif /* UIP_BUFSIZE > 255 */
		
}
    26a0:	ce 01       	movw	r24, r28
    26a2:	df 91       	pop	r29
    26a4:	cf 91       	pop	r28
    26a6:	08 95       	ret

000026a8 <nic_send>:
}


void nic_send(void)
{
	NICBeginPacketSend(uip_len);
    26a8:	80 91 ea 02 	lds	r24, 0x02EA
    26ac:	90 91 eb 02 	lds	r25, 0x02EB
    26b0:	0e 94 28 10 	call	0x2050	; 0x2050 <rtl8019BeginPacketSend>
	
	// send packet, using data in uip_appdata if over the IP+TCP header size
	if( uip_len <= TOTAL_HEADER_LENGTH )
    26b4:	80 91 ea 02 	lds	r24, 0x02EA
    26b8:	90 91 eb 02 	lds	r25, 0x02EB
    26bc:	c7 97       	sbiw	r24, 0x37	; 55
    26be:	38 f4       	brcc	.+14     	; 0x26ce <nic_send+0x26>
	{
      NICSendPacketData(uip_buf, uip_len);
    26c0:	60 91 ea 02 	lds	r22, 0x02EA
    26c4:	70 91 eb 02 	lds	r23, 0x02EB
    26c8:	8a e6       	ldi	r24, 0x6A	; 106
    26ca:	93 e0       	ldi	r25, 0x03	; 3
    26cc:	17 c0       	rjmp	.+46     	; 0x26fc <nic_send+0x54>
	}
	else
	{
      uip_len -= TOTAL_HEADER_LENGTH;
    26ce:	80 91 ea 02 	lds	r24, 0x02EA
    26d2:	90 91 eb 02 	lds	r25, 0x02EB
    26d6:	c6 97       	sbiw	r24, 0x36	; 54
    26d8:	90 93 eb 02 	sts	0x02EB, r25
    26dc:	80 93 ea 02 	sts	0x02EA, r24
      NICSendPacketData(uip_buf, TOTAL_HEADER_LENGTH);
    26e0:	66 e3       	ldi	r22, 0x36	; 54
    26e2:	70 e0       	ldi	r23, 0x00	; 0
    26e4:	8a e6       	ldi	r24, 0x6A	; 106
    26e6:	93 e0       	ldi	r25, 0x03	; 3
    26e8:	0e 94 66 10 	call	0x20cc	; 0x20cc <rtl8019SendPacketData>
	  NICSendPacketData((unsigned char *)uip_appdata, uip_len);
    26ec:	60 91 ea 02 	lds	r22, 0x02EA
    26f0:	70 91 eb 02 	lds	r23, 0x02EB
    26f4:	80 91 f3 02 	lds	r24, 0x02F3
    26f8:	90 91 f4 02 	lds	r25, 0x02F4
    26fc:	0e 94 66 10 	call	0x20cc	; 0x20cc <rtl8019SendPacketData>
	}

	NICEndPacketSend();
    2700:	0e 94 83 10 	call	0x2106	; 0x2106 <rtl8019EndPacketSend>
    2704:	08 95       	ret

00002706 <nic_init>:
#define TOTAL_HEADER_LENGTH (IP_TCP_HEADER_LENGTH+ETHERNET_HEADER_LENGTH)


void nic_init(void)
{
	NICInit();
    2706:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <rtl8019Init>
    270a:	08 95       	ret

0000270c <uip_init>:
#endif /* UIP_LOGGING == 1 */

/*-----------------------------------------------------------------------------------*/
void
uip_init(void)
{
    270c:	80 e0       	ldi	r24, 0x00	; 0
    270e:	09 c0       	rjmp	.+18     	; 0x2722 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    2710:	e8 2f       	mov	r30, r24
    2712:	ff 27       	eor	r31, r31
    2714:	ee 0f       	add	r30, r30
    2716:	ff 1f       	adc	r31, r31
    2718:	e0 5a       	subi	r30, 0xA0	; 160
    271a:	fc 4f       	sbci	r31, 0xFC	; 252
    271c:	11 82       	std	Z+1, r1	; 0x01
    271e:	10 82       	st	Z, r1
    2720:	8f 5f       	subi	r24, 0xFF	; 255

/*-----------------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2722:	85 30       	cpi	r24, 0x05	; 5
    2724:	a8 f3       	brcs	.-22     	; 0x2710 <uip_init+0x4>
    2726:	40 e0       	ldi	r20, 0x00	; 0
    2728:	0f c0       	rjmp	.+30     	; 0x2748 <uip_init+0x3c>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = CLOSED;
    272a:	24 2f       	mov	r18, r20
    272c:	33 27       	eor	r19, r19
    272e:	83 e2       	ldi	r24, 0x23	; 35
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	28 9f       	mul	r18, r24
    2734:	f0 01       	movw	r30, r0
    2736:	29 9f       	mul	r18, r25
    2738:	f0 0d       	add	r31, r0
    273a:	38 9f       	mul	r19, r24
    273c:	f0 0d       	add	r31, r0
    273e:	11 24       	eor	r1, r1
    2740:	e9 50       	subi	r30, 0x09	; 9
    2742:	fd 4f       	sbci	r31, 0xFD	; 253
    2744:	11 8e       	std	Z+25, r1	; 0x19
    2746:	4f 5f       	subi	r20, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    2748:	43 30       	cpi	r20, 0x03	; 3
    274a:	78 f3       	brcs	.-34     	; 0x272a <uip_init+0x1e>
    274c:	40 93 83 00 	sts	0x0083, r20
    uip_conns[c].tcpstateflags = CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    2750:	80 e0       	ldi	r24, 0x00	; 0
    2752:	94 e0       	ldi	r25, 0x04	; 4
    2754:	90 93 82 00 	sts	0x0082, r25
    2758:	80 93 81 00 	sts	0x0081, r24
    275c:	08 95       	ret

0000275e <uip_unlisten>:
}
#endif /* UIP_UDP */
/*-----------------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
    275e:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2760:	10 92 83 00 	sts	0x0083, r1
    2764:	20 e0       	ldi	r18, 0x00	; 0
    2766:	13 c0       	rjmp	.+38     	; 0x278e <uip_unlisten+0x30>
    if(uip_listenports[c] == port) {
    2768:	e2 2f       	mov	r30, r18
    276a:	ff 27       	eor	r31, r31
    276c:	32 2f       	mov	r19, r18
    276e:	3f 5f       	subi	r19, 0xFF	; 255
    2770:	ee 0f       	add	r30, r30
    2772:	ff 1f       	adc	r31, r31
    2774:	e0 5a       	subi	r30, 0xA0	; 160
    2776:	fc 4f       	sbci	r31, 0xFC	; 252
    2778:	80 81       	ld	r24, Z
    277a:	91 81       	ldd	r25, Z+1	; 0x01
    277c:	84 17       	cp	r24, r20
    277e:	95 07       	cpc	r25, r21
    2780:	29 f4       	brne	.+10     	; 0x278c <uip_unlisten+0x2e>
    2782:	20 93 83 00 	sts	0x0083, r18
      uip_listenports[c] = 0;
    2786:	11 82       	std	Z+1, r1	; 0x01
    2788:	10 82       	st	Z, r1
    278a:	08 95       	ret
      return;
    278c:	23 2f       	mov	r18, r19
#endif /* UIP_UDP */
/*-----------------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    278e:	25 30       	cpi	r18, 0x05	; 5
    2790:	58 f3       	brcs	.-42     	; 0x2768 <uip_unlisten+0xa>
    2792:	20 93 83 00 	sts	0x0083, r18
    2796:	08 95       	ret

00002798 <uip_listen>:
  }
}
/*-----------------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    2798:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    279a:	10 92 83 00 	sts	0x0083, r1
    279e:	20 e0       	ldi	r18, 0x00	; 0
    27a0:	12 c0       	rjmp	.+36     	; 0x27c6 <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    27a2:	e2 2f       	mov	r30, r18
    27a4:	ff 27       	eor	r31, r31
    27a6:	32 2f       	mov	r19, r18
    27a8:	3f 5f       	subi	r19, 0xFF	; 255
    27aa:	ee 0f       	add	r30, r30
    27ac:	ff 1f       	adc	r31, r31
    27ae:	e0 5a       	subi	r30, 0xA0	; 160
    27b0:	fc 4f       	sbci	r31, 0xFC	; 252
    27b2:	80 81       	ld	r24, Z
    27b4:	91 81       	ldd	r25, Z+1	; 0x01
    27b6:	89 2b       	or	r24, r25
    27b8:	29 f4       	brne	.+10     	; 0x27c4 <uip_listen+0x2c>
    27ba:	20 93 83 00 	sts	0x0083, r18
      uip_listenports[c] = port;
    27be:	51 83       	std	Z+1, r21	; 0x01
    27c0:	40 83       	st	Z, r20
    27c2:	08 95       	ret
      return;
    27c4:	23 2f       	mov	r18, r19
}
/*-----------------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    27c6:	25 30       	cpi	r18, 0x05	; 5
    27c8:	60 f3       	brcs	.-40     	; 0x27a2 <uip_listen+0xa>
    27ca:	20 93 83 00 	sts	0x0083, r18
    27ce:	08 95       	ret

000027d0 <htons>:
  return;
}
/*-----------------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    27d0:	9c 01       	movw	r18, r24
    27d2:	89 2f       	mov	r24, r25
    27d4:	99 27       	eor	r25, r25
    27d6:	32 2f       	mov	r19, r18
    27d8:	22 27       	eor	r18, r18
  return HTONS(val);
}
    27da:	82 2b       	or	r24, r18
    27dc:	93 2b       	or	r25, r19
    27de:	08 95       	ret

000027e0 <uip_connect>:
}
/*-----------------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(u16_t *ripaddr, u16_t rport)
{
    27e0:	af 92       	push	r10
    27e2:	bf 92       	push	r11
    27e4:	cf 92       	push	r12
    27e6:	df 92       	push	r13
    27e8:	ef 92       	push	r14
    27ea:	ff 92       	push	r15
    27ec:	0f 93       	push	r16
    27ee:	1f 93       	push	r17
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	6c 01       	movw	r12, r24
    27f6:	5b 01       	movw	r10, r22
    27f8:	00 91 81 00 	lds	r16, 0x0081
    27fc:	10 91 82 00 	lds	r17, 0x0082
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    2800:	0f 5f       	subi	r16, 0xFF	; 255
    2802:	1f 4f       	sbci	r17, 0xFF	; 255

  if(lastport >= 32000) {
    2804:	8d e7       	ldi	r24, 0x7D	; 125
    2806:	00 30       	cpi	r16, 0x00	; 0
    2808:	18 07       	cpc	r17, r24
    280a:	10 f0       	brcs	.+4      	; 0x2810 <uip_connect+0x30>
    280c:	00 e0       	ldi	r16, 0x00	; 0
    280e:	10 e1       	ldi	r17, 0x10	; 16
    2810:	ee 24       	eor	r14, r14
    2812:	ff 24       	eor	r15, r15
    2814:	14 c0       	rjmp	.+40     	; 0x283e <uip_connect+0x5e>
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    2816:	83 e2       	ldi	r24, 0x23	; 35
    2818:	98 9f       	mul	r25, r24
    281a:	e0 01       	movw	r28, r0
    281c:	11 24       	eor	r1, r1
    281e:	c9 50       	subi	r28, 0x09	; 9
    2820:	dd 4f       	sbci	r29, 0xFD	; 253
    if(conn->tcpstateflags != CLOSED &&
    2822:	89 8d       	ldd	r24, Y+25	; 0x19
    2824:	88 23       	and	r24, r24
    2826:	41 f0       	breq	.+16     	; 0x2838 <uip_connect+0x58>
    2828:	c8 01       	movw	r24, r16
    282a:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <htons>
    282e:	2c 81       	ldd	r18, Y+4	; 0x04
    2830:	3d 81       	ldd	r19, Y+5	; 0x05
    2832:	28 17       	cp	r18, r24
    2834:	39 07       	cpc	r19, r25
    2836:	21 f3       	breq	.-56     	; 0x2800 <uip_connect+0x20>
       conn->lport == htons(lastport)) {
      goto again;
    2838:	08 94       	sec
    283a:	e1 1c       	adc	r14, r1
    283c:	f1 1c       	adc	r15, r1
    283e:	9e 2d       	mov	r25, r14
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    2840:	e3 e0       	ldi	r30, 0x03	; 3
    2842:	ee 16       	cp	r14, r30
    2844:	f1 04       	cpc	r15, r1
    2846:	39 f7       	brne	.-50     	; 0x2816 <uip_connect+0x36>
    2848:	10 93 82 00 	sts	0x0082, r17
    284c:	00 93 81 00 	sts	0x0081, r16
    }
  }


  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2850:	10 92 83 00 	sts	0x0083, r1
    if(cconn->tcpstateflags == CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == TIME_WAIT) {
      if(conn == 0 ||
    2854:	a0 91 f5 02 	lds	r26, 0x02F5
    2858:	b0 91 f6 02 	lds	r27, 0x02F6
    285c:	c0 e0       	ldi	r28, 0x00	; 0
    285e:	d0 e0       	ldi	r29, 0x00	; 0
    2860:	20 e0       	ldi	r18, 0x00	; 0
    2862:	19 c0       	rjmp	.+50     	; 0x2896 <uip_connect+0xb6>
  }


  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c]; 
    2864:	83 e2       	ldi	r24, 0x23	; 35
    2866:	28 9f       	mul	r18, r24
    2868:	f0 01       	movw	r30, r0
    286a:	11 24       	eor	r1, r1
    286c:	e9 50       	subi	r30, 0x09	; 9
    286e:	fd 4f       	sbci	r31, 0xFD	; 253
    if(cconn->tcpstateflags == CLOSED) {
    2870:	81 8d       	ldd	r24, Z+25	; 0x19
    2872:	88 23       	and	r24, r24
    2874:	21 f4       	brne	.+8      	; 0x287e <uip_connect+0x9e>
    2876:	20 93 83 00 	sts	0x0083, r18
    287a:	ef 01       	movw	r28, r30
    287c:	10 c0       	rjmp	.+32     	; 0x289e <uip_connect+0xbe>
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == TIME_WAIT) {
    287e:	87 30       	cpi	r24, 0x07	; 7
    2880:	49 f4       	brne	.+18     	; 0x2894 <uip_connect+0xb4>
      if(conn == 0 ||
    2882:	20 97       	sbiw	r28, 0x00	; 0
    2884:	31 f0       	breq	.+12     	; 0x2892 <uip_connect+0xb2>
    2886:	92 8d       	ldd	r25, Z+26	; 0x1a
    2888:	5a 96       	adiw	r26, 0x1a	; 26
    288a:	8c 91       	ld	r24, X
    288c:	5a 97       	sbiw	r26, 0x1a	; 26
    288e:	89 17       	cp	r24, r25
    2890:	08 f4       	brcc	.+2      	; 0x2894 <uip_connect+0xb4>
    2892:	ef 01       	movw	r28, r30
    2894:	2f 5f       	subi	r18, 0xFF	; 255
    }
  }


  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2896:	23 30       	cpi	r18, 0x03	; 3
    2898:	28 f3       	brcs	.-54     	; 0x2864 <uip_connect+0x84>
    289a:	20 93 83 00 	sts	0x0083, r18
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    289e:	20 97       	sbiw	r28, 0x00	; 0
    28a0:	81 f1       	breq	.+96     	; 0x2902 <uip_connect+0x122>
    return 0;
  }
  
  conn->tcpstateflags = SYN_SENT;
    28a2:	82 e0       	ldi	r24, 0x02	; 2
    28a4:	89 8f       	std	Y+25, r24	; 0x19

  conn->snd_nxt[0] = iss[0];
    28a6:	80 91 7d 00 	lds	r24, 0x007D
    28aa:	8c 87       	std	Y+12, r24	; 0x0c
  conn->snd_nxt[1] = iss[1];
    28ac:	80 91 7e 00 	lds	r24, 0x007E
    28b0:	8d 87       	std	Y+13, r24	; 0x0d
  conn->snd_nxt[2] = iss[2];
    28b2:	80 91 7f 00 	lds	r24, 0x007F
    28b6:	8e 87       	std	Y+14, r24	; 0x0e
  conn->snd_nxt[3] = iss[3];
    28b8:	80 91 80 00 	lds	r24, 0x0080
    28bc:	8f 87       	std	Y+15, r24	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    28be:	80 e0       	ldi	r24, 0x00	; 0
    28c0:	92 e0       	ldi	r25, 0x02	; 2
    28c2:	9b 8b       	std	Y+19, r25	; 0x13
    28c4:	8a 8b       	std	Y+18, r24	; 0x12
    28c6:	9d 8b       	std	Y+21, r25	; 0x15
    28c8:	8c 8b       	std	Y+20, r24	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    28ca:	81 e0       	ldi	r24, 0x01	; 1
    28cc:	90 e0       	ldi	r25, 0x00	; 0
    28ce:	99 8b       	std	Y+17, r25	; 0x11
    28d0:	88 8b       	std	Y+16, r24	; 0x10
  conn->nrtx = 0;
    28d2:	1b 8e       	std	Y+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    28d4:	81 e0       	ldi	r24, 0x01	; 1
    28d6:	8a 8f       	std	Y+26, r24	; 0x1a
  conn->rto = UIP_RTO;
    28d8:	83 e0       	ldi	r24, 0x03	; 3
    28da:	88 8f       	std	Y+24, r24	; 0x18
  conn->sa = 0;
    28dc:	1e 8a       	std	Y+22, r1	; 0x16
  conn->sv = 16;
    28de:	80 e1       	ldi	r24, 0x10	; 16
    28e0:	8f 8b       	std	Y+23, r24	; 0x17
  conn->lport = htons(lastport);
    28e2:	c8 01       	movw	r24, r16
    28e4:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <htons>
    28e8:	9d 83       	std	Y+5, r25	; 0x05
    28ea:	8c 83       	std	Y+4, r24	; 0x04
  conn->rport = rport;
    28ec:	bf 82       	std	Y+7, r11	; 0x07
    28ee:	ae 82       	std	Y+6, r10	; 0x06
  conn->ripaddr[0] = ripaddr[0];
    28f0:	f6 01       	movw	r30, r12
    28f2:	80 81       	ld	r24, Z
    28f4:	91 81       	ldd	r25, Z+1	; 0x01
    28f6:	99 83       	std	Y+1, r25	; 0x01
    28f8:	88 83       	st	Y, r24
  conn->ripaddr[1] = ripaddr[1];
    28fa:	82 81       	ldd	r24, Z+2	; 0x02
    28fc:	93 81       	ldd	r25, Z+3	; 0x03
    28fe:	9b 83       	std	Y+3, r25	; 0x03
    2900:	8a 83       	std	Y+2, r24	; 0x02
  
  return conn;
}
    2902:	ce 01       	movw	r24, r28
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	1f 91       	pop	r17
    290a:	0f 91       	pop	r16
    290c:	ff 90       	pop	r15
    290e:	ef 90       	pop	r14
    2910:	df 90       	pop	r13
    2912:	cf 90       	pop	r12
    2914:	bf 90       	pop	r11
    2916:	af 90       	pop	r10
    2918:	08 95       	ret

0000291a <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBL */
/*-----------------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    291a:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    291c:	80 91 f5 02 	lds	r24, 0x02F5
    2920:	90 91 f6 02 	lds	r25, 0x02F6
    2924:	08 96       	adiw	r24, 0x08	; 8
    2926:	0e 94 7d 1d 	call	0x3afa	; 0x3afa <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    292a:	80 91 ee 02 	lds	r24, 0x02EE
    292e:	e0 91 f5 02 	lds	r30, 0x02F5
    2932:	f0 91 f6 02 	lds	r31, 0x02F6
    2936:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    2938:	80 91 ef 02 	lds	r24, 0x02EF
    293c:	e0 91 f5 02 	lds	r30, 0x02F5
    2940:	f0 91 f6 02 	lds	r31, 0x02F6
    2944:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    2946:	80 91 f0 02 	lds	r24, 0x02F0
    294a:	e0 91 f5 02 	lds	r30, 0x02F5
    294e:	f0 91 f6 02 	lds	r31, 0x02F6
    2952:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    2954:	80 91 f1 02 	lds	r24, 0x02F1
    2958:	e0 91 f5 02 	lds	r30, 0x02F5
    295c:	f0 91 f6 02 	lds	r31, 0x02F6
    2960:	83 87       	std	Z+11, r24	; 0x0b
    2962:	08 95       	ret

00002964 <uip_process>:
}
/*-----------------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    296c:	c0 91 f5 02 	lds	r28, 0x02F5
    2970:	d0 91 f6 02 	lds	r29, 0x02F6
  
  uip_appdata = &uip_buf[40 + UIP_LLH_LEN];
    2974:	20 ea       	ldi	r18, 0xA0	; 160
    2976:	33 e0       	ldi	r19, 0x03	; 3
    2978:	30 93 f4 02 	sts	0x02F4, r19
    297c:	20 93 f3 02 	sts	0x02F3, r18

  
  /* Check if we were invoked because of the perodic timer fireing. */
  if(flag == UIP_TIMER) {
    2980:	82 30       	cpi	r24, 0x02	; 2
    2982:	09 f0       	breq	.+2      	; 0x2986 <uip_process+0x22>
    2984:	96 c0       	rjmp	.+300    	; 0x2ab2 <uip_process+0x14e>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    2986:	80 91 80 00 	lds	r24, 0x0080
    298a:	8f 5f       	subi	r24, 0xFF	; 255
    298c:	80 93 80 00 	sts	0x0080, r24
    2990:	88 23       	and	r24, r24
    2992:	99 f4       	brne	.+38     	; 0x29ba <uip_process+0x56>
      if(++iss[2] == 0) {
    2994:	80 91 7f 00 	lds	r24, 0x007F
    2998:	8f 5f       	subi	r24, 0xFF	; 255
    299a:	80 93 7f 00 	sts	0x007F, r24
    299e:	88 23       	and	r24, r24
    29a0:	61 f4       	brne	.+24     	; 0x29ba <uip_process+0x56>
	if(++iss[1] == 0) {
    29a2:	80 91 7e 00 	lds	r24, 0x007E
    29a6:	8f 5f       	subi	r24, 0xFF	; 255
    29a8:	80 93 7e 00 	sts	0x007E, r24
    29ac:	88 23       	and	r24, r24
    29ae:	29 f4       	brne	.+10     	; 0x29ba <uip_process+0x56>
	  ++iss[0];
    29b0:	80 91 7d 00 	lds	r24, 0x007D
    29b4:	8f 5f       	subi	r24, 0xFF	; 255
    29b6:	80 93 7d 00 	sts	0x007D, r24
	}
      }
    }    
    uip_len = 0;
    29ba:	10 92 eb 02 	sts	0x02EB, r1
    29be:	10 92 ea 02 	sts	0x02EA, r1
    if(uip_connr->tcpstateflags == TIME_WAIT ||
    29c2:	29 8d       	ldd	r18, Y+25	; 0x19
    29c4:	27 30       	cpi	r18, 0x07	; 7
    29c6:	11 f0       	breq	.+4      	; 0x29cc <uip_process+0x68>
    29c8:	25 30       	cpi	r18, 0x05	; 5
    29ca:	41 f4       	brne	.+16     	; 0x29dc <uip_process+0x78>
       uip_connr->tcpstateflags == FIN_WAIT_2) {
      ++(uip_connr->timer);
    29cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29ce:	8f 5f       	subi	r24, 0xFF	; 255
    29d0:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    29d2:	88 37       	cpi	r24, 0x78	; 120
    29d4:	09 f0       	breq	.+2      	; 0x29d8 <uip_process+0x74>
    29d6:	ea c5       	rjmp	.+3028   	; 0x35ac <uip_process+0xc48>
	uip_connr->tcpstateflags = CLOSED;
    29d8:	19 8e       	std	Y+25, r1	; 0x19
    29da:	e8 c5       	rjmp	.+3024   	; 0x35ac <uip_process+0xc48>
      }
    } else if(uip_connr->tcpstateflags != CLOSED) {
    29dc:	22 23       	and	r18, r18
    29de:	09 f4       	brne	.+2      	; 0x29e2 <uip_process+0x7e>
    29e0:	e5 c5       	rjmp	.+3018   	; 0x35ac <uip_process+0xc48>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    29e2:	88 89       	ldd	r24, Y+16	; 0x10
    29e4:	99 89       	ldd	r25, Y+17	; 0x11
    29e6:	89 2b       	or	r24, r25
    29e8:	09 f4       	brne	.+2      	; 0x29ec <uip_process+0x88>
    29ea:	53 c0       	rjmp	.+166    	; 0x2a92 <uip_process+0x12e>
	if(uip_connr->timer-- == 0) {
    29ec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29ee:	81 50       	subi	r24, 0x01	; 1
    29f0:	8a 8f       	std	Y+26, r24	; 0x1a
    29f2:	8f 3f       	cpi	r24, 0xFF	; 255
    29f4:	09 f0       	breq	.+2      	; 0x29f8 <uip_process+0x94>
    29f6:	da c5       	rjmp	.+2996   	; 0x35ac <uip_process+0xc48>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    29f8:	3b 8d       	ldd	r19, Y+27	; 0x1b
    29fa:	38 30       	cpi	r19, 0x08	; 8
    29fc:	29 f0       	breq	.+10     	; 0x2a08 <uip_process+0xa4>
    29fe:	21 50       	subi	r18, 0x01	; 1
    2a00:	22 30       	cpi	r18, 0x02	; 2
    2a02:	48 f4       	brcc	.+18     	; 0x2a16 <uip_process+0xb2>
    2a04:	33 30       	cpi	r19, 0x03	; 3
    2a06:	39 f4       	brne	.+14     	; 0x2a16 <uip_process+0xb2>
	     ((uip_connr->tcpstateflags == SYN_SENT ||
	       uip_connr->tcpstateflags == SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = CLOSED;
    2a08:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    2a0a:	80 e8       	ldi	r24, 0x80	; 128
    2a0c:	80 93 f2 02 	sts	0x02F2, r24
	    UIP_APPCALL();
    2a10:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>
    2a14:	71 c4       	rjmp	.+2274   	; 0x32f8 <uip_process+0x994>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    2a16:	35 30       	cpi	r19, 0x05	; 5
    2a18:	10 f0       	brcs	.+4      	; 0x2a1e <uip_process+0xba>
    2a1a:	80 e3       	ldi	r24, 0x30	; 48
    2a1c:	07 c0       	rjmp	.+14     	; 0x2a2c <uip_process+0xc8>
    2a1e:	83 e0       	ldi	r24, 0x03	; 3
    2a20:	90 e0       	ldi	r25, 0x00	; 0
    2a22:	02 c0       	rjmp	.+4      	; 0x2a28 <uip_process+0xc4>
    2a24:	88 0f       	add	r24, r24
    2a26:	99 1f       	adc	r25, r25
    2a28:	3a 95       	dec	r19
    2a2a:	e2 f7       	brpl	.-8      	; 0x2a24 <uip_process+0xc0>
    2a2c:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    2a2e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a30:	8f 5f       	subi	r24, 0xFF	; 255
    2a32:	8b 8f       	std	Y+27, r24	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & TS_MASK) {
    2a34:	89 8d       	ldd	r24, Y+25	; 0x19
    2a36:	99 27       	eor	r25, r25
    2a38:	8f 70       	andi	r24, 0x0F	; 15
    2a3a:	90 70       	andi	r25, 0x00	; 0
    2a3c:	83 30       	cpi	r24, 0x03	; 3
    2a3e:	91 05       	cpc	r25, r1
    2a40:	d1 f0       	breq	.+52     	; 0x2a76 <uip_process+0x112>
    2a42:	84 30       	cpi	r24, 0x04	; 4
    2a44:	91 05       	cpc	r25, r1
    2a46:	44 f4       	brge	.+16     	; 0x2a58 <uip_process+0xf4>
    2a48:	81 30       	cpi	r24, 0x01	; 1
    2a4a:	91 05       	cpc	r25, r1
    2a4c:	09 f4       	brne	.+2      	; 0x2a50 <uip_process+0xec>
    2a4e:	50 c2       	rjmp	.+1184   	; 0x2ef0 <uip_process+0x58c>
    2a50:	02 97       	sbiw	r24, 0x02	; 2
    2a52:	09 f0       	breq	.+2      	; 0x2a56 <uip_process+0xf2>
    2a54:	ab c5       	rjmp	.+2902   	; 0x35ac <uip_process+0xc48>
    2a56:	0c c0       	rjmp	.+24     	; 0x2a70 <uip_process+0x10c>
    2a58:	86 30       	cpi	r24, 0x06	; 6
    2a5a:	91 05       	cpc	r25, r1
    2a5c:	09 f4       	brne	.+2      	; 0x2a60 <uip_process+0xfc>
    2a5e:	e0 c3       	rjmp	.+1984   	; 0x3220 <uip_process+0x8bc>
    2a60:	88 30       	cpi	r24, 0x08	; 8
    2a62:	91 05       	cpc	r25, r1
    2a64:	09 f4       	brne	.+2      	; 0x2a68 <uip_process+0x104>
    2a66:	dc c3       	rjmp	.+1976   	; 0x3220 <uip_process+0x8bc>
    2a68:	04 97       	sbiw	r24, 0x04	; 4
    2a6a:	09 f0       	breq	.+2      	; 0x2a6e <uip_process+0x10a>
    2a6c:	9f c5       	rjmp	.+2878   	; 0x35ac <uip_process+0xc48>
    2a6e:	d8 c3       	rjmp	.+1968   	; 0x3220 <uip_process+0x8bc>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    2a70:	10 92 99 03 	sts	0x0399, r1
    2a74:	40 c2       	rjmp	.+1152   	; 0x2ef6 <uip_process+0x592>
	  case ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_len = 0;
    2a76:	10 92 eb 02 	sts	0x02EB, r1
    2a7a:	10 92 ea 02 	sts	0x02EA, r1
	    uip_slen = 0;
    2a7e:	10 92 a3 05 	sts	0x05A3, r1
    2a82:	10 92 a2 05 	sts	0x05A2, r1
	    uip_flags = UIP_REXMIT;
    2a86:	84 e0       	ldi	r24, 0x04	; 4
    2a88:	80 93 f2 02 	sts	0x02F2, r24
	    UIP_APPCALL();
    2a8c:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>
    2a90:	6f c4       	rjmp	.+2270   	; 0x3370 <uip_process+0xa0c>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & TS_MASK) == ESTABLISHED) {
    2a92:	2f 70       	andi	r18, 0x0F	; 15
    2a94:	23 30       	cpi	r18, 0x03	; 3
    2a96:	09 f0       	breq	.+2      	; 0x2a9a <uip_process+0x136>
    2a98:	89 c5       	rjmp	.+2834   	; 0x35ac <uip_process+0xc48>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = 0;
    2a9a:	10 92 eb 02 	sts	0x02EB, r1
    2a9e:	10 92 ea 02 	sts	0x02EA, r1
	uip_slen = 0;
    2aa2:	10 92 a3 05 	sts	0x05A3, r1
    2aa6:	10 92 a2 05 	sts	0x05A2, r1
	uip_flags = UIP_POLL;
    2aaa:	88 e0       	ldi	r24, 0x08	; 8
    2aac:	80 93 f2 02 	sts	0x02F2, r24
    2ab0:	18 c4       	rjmp	.+2096   	; 0x32e2 <uip_process+0x97e>


  /* Start of IPv4 input header processing code. */
  
  /* Check validity of the IP header. */  
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    2ab2:	89 01       	movw	r16, r18
    2ab4:	08 52       	subi	r16, 0x28	; 40
    2ab6:	10 40       	sbci	r17, 0x00	; 0
    2ab8:	80 91 78 03 	lds	r24, 0x0378
    2abc:	85 34       	cpi	r24, 0x45	; 69
    2abe:	09 f0       	breq	.+2      	; 0x2ac2 <uip_process+0x15e>
    2ac0:	75 c5       	rjmp	.+2794   	; 0x35ac <uip_process+0xc48>
  
  /* Check the size of the packet. If the size reported to us in
     uip_len doesn't match the size reported in the IP header, there
     has been a transmission error and we drop the packet. */
  
  if(BUF->len[0] != (uip_len >> 8)) { /* IP length, high byte. */
    2ac2:	20 91 7a 03 	lds	r18, 0x037A
    2ac6:	80 91 ea 02 	lds	r24, 0x02EA
    2aca:	90 91 eb 02 	lds	r25, 0x02EB
    2ace:	33 27       	eor	r19, r19
    2ad0:	89 2f       	mov	r24, r25
    2ad2:	99 27       	eor	r25, r25
    2ad4:	28 17       	cp	r18, r24
    2ad6:	39 07       	cpc	r19, r25
    2ad8:	69 f0       	breq	.+26     	; 0x2af4 <uip_process+0x190>
    uip_len = (uip_len & 0xff) | (BUF->len[0] << 8);
    2ada:	80 91 ea 02 	lds	r24, 0x02EA
    2ade:	90 91 eb 02 	lds	r25, 0x02EB
    2ae2:	32 2f       	mov	r19, r18
    2ae4:	22 27       	eor	r18, r18
    2ae6:	90 70       	andi	r25, 0x00	; 0
    2ae8:	28 2b       	or	r18, r24
    2aea:	39 2b       	or	r19, r25
    2aec:	30 93 eb 02 	sts	0x02EB, r19
    2af0:	20 93 ea 02 	sts	0x02EA, r18
  }
  if(BUF->len[1] != (uip_len & 0xff)) { /* IP length, low byte. */
    2af4:	20 91 7b 03 	lds	r18, 0x037B
    2af8:	80 91 ea 02 	lds	r24, 0x02EA
    2afc:	90 91 eb 02 	lds	r25, 0x02EB
    2b00:	33 27       	eor	r19, r19
    2b02:	90 70       	andi	r25, 0x00	; 0
    2b04:	28 17       	cp	r18, r24
    2b06:	39 07       	cpc	r19, r25
    2b08:	59 f0       	breq	.+22     	; 0x2b20 <uip_process+0x1bc>
    uip_len = (uip_len & 0xff00) | BUF->len[1];
    2b0a:	80 91 ea 02 	lds	r24, 0x02EA
    2b0e:	90 91 eb 02 	lds	r25, 0x02EB
    2b12:	80 70       	andi	r24, 0x00	; 0
    2b14:	28 2b       	or	r18, r24
    2b16:	39 2b       	or	r19, r25
    2b18:	30 93 eb 02 	sts	0x02EB, r19
    2b1c:	20 93 ea 02 	sts	0x02EA, r18
  }

  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2b20:	80 91 7e 03 	lds	r24, 0x037E
    2b24:	99 27       	eor	r25, r25
    2b26:	8f 73       	andi	r24, 0x3F	; 63
    2b28:	90 70       	andi	r25, 0x00	; 0
    2b2a:	89 2b       	or	r24, r25
    2b2c:	09 f0       	breq	.+2      	; 0x2b30 <uip_process+0x1cc>
    2b2e:	3e c5       	rjmp	.+2684   	; 0x35ac <uip_process+0xc48>
    2b30:	80 91 7f 03 	lds	r24, 0x037F
    2b34:	88 23       	and	r24, r24
    2b36:	09 f0       	breq	.+2      	; 0x2b3a <uip_process+0x1d6>
    2b38:	39 c5       	rjmp	.+2674   	; 0x35ac <uip_process+0xc48>
    }
  }
#endif /* UIP_PINGADDRCONF */
  
  /* Check if the packet is destined for our IP address. */  
  if(BUF->destipaddr[0] != uip_hostaddr[0]) {
    2b3a:	80 91 88 03 	lds	r24, 0x0388
    2b3e:	90 91 89 03 	lds	r25, 0x0389
    2b42:	8e 50       	subi	r24, 0x0E	; 14
    2b44:	97 42       	sbci	r25, 0x27	; 39
    2b46:	09 f0       	breq	.+2      	; 0x2b4a <uip_process+0x1e6>
    2b48:	31 c5       	rjmp	.+2658   	; 0x35ac <uip_process+0xc48>
    UIP_STAT(++uip_stat.ip.drop);
    UIP_LOG("ip: packet not for us.");        
    goto drop;
  }
  if(BUF->destipaddr[1] != uip_hostaddr[1]) {
    2b4a:	80 91 8a 03 	lds	r24, 0x038A
    2b4e:	90 91 8b 03 	lds	r25, 0x038B
    2b52:	8f 57       	subi	r24, 0x7F	; 127
    2b54:	90 42       	sbci	r25, 0x20	; 32
    2b56:	09 f0       	breq	.+2      	; 0x2b5a <uip_process+0x1f6>
    2b58:	29 c5       	rjmp	.+2642   	; 0x35ac <uip_process+0xc48>
    UIP_STAT(++uip_stat.ip.drop);
    UIP_LOG("ip: packet not for us.");        
    goto drop;
  }

  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    2b5a:	0e 94 a7 1d 	call	0x3b4e	; 0x3b4e <uip_ipchksum>
    2b5e:	8f 5f       	subi	r24, 0xFF	; 255
    2b60:	9f 4f       	sbci	r25, 0xFF	; 255
    2b62:	09 f0       	breq	.+2      	; 0x2b66 <uip_process+0x202>
    2b64:	23 c5       	rjmp	.+2630   	; 0x35ac <uip_process+0xc48>
    UIP_STAT(++uip_stat.ip.chkerr);
    UIP_LOG("ip: bad checksum.");    
    goto drop;
  }

  if(BUF->proto == UIP_PROTO_TCP)  /* Check for TCP packet. If so, jump
    2b66:	80 91 81 03 	lds	r24, 0x0381
    2b6a:	86 30       	cpi	r24, 0x06	; 6
    2b6c:	b9 f1       	breq	.+110    	; 0x2bdc <uip_process+0x278>
#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP)
    goto udp_input;
#endif /* UIP_UDP */

  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    2b6e:	81 30       	cpi	r24, 0x01	; 1
    2b70:	09 f0       	breq	.+2      	; 0x2b74 <uip_process+0x210>
    2b72:	1c c5       	rjmp	.+2616   	; 0x35ac <uip_process+0xc48>
  UIP_STAT(++uip_stat.icmp.recv);
  
  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    2b74:	80 91 8c 03 	lds	r24, 0x038C
    2b78:	88 30       	cpi	r24, 0x08	; 8
    2b7a:	09 f0       	breq	.+2      	; 0x2b7e <uip_process+0x21a>
    2b7c:	17 c5       	rjmp	.+2606   	; 0x35ac <uip_process+0xc48>
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */  
  
  ICMPBUF->type = ICMP_ECHO_REPLY;
    2b7e:	10 92 8c 03 	sts	0x038C, r1
  
  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    2b82:	80 91 8e 03 	lds	r24, 0x038E
    2b86:	90 91 8f 03 	lds	r25, 0x038F
    2b8a:	2f ef       	ldi	r18, 0xFF	; 255
    2b8c:	87 3f       	cpi	r24, 0xF7	; 247
    2b8e:	92 07       	cpc	r25, r18
    2b90:	10 f0       	brcs	.+4      	; 0x2b96 <uip_process+0x232>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    2b92:	09 96       	adiw	r24, 0x09	; 9
    2b94:	01 c0       	rjmp	.+2      	; 0x2b98 <uip_process+0x234>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    2b96:	08 96       	adiw	r24, 0x08	; 8
    2b98:	90 93 8f 03 	sts	0x038F, r25
    2b9c:	80 93 8e 03 	sts	0x038E, r24
  }
  
  /* Swap IP addresses. */
  tmp16 = BUF->destipaddr[0];
    2ba0:	20 91 88 03 	lds	r18, 0x0388
    2ba4:	30 91 89 03 	lds	r19, 0x0389
  BUF->destipaddr[0] = BUF->srcipaddr[0];
    2ba8:	80 91 84 03 	lds	r24, 0x0384
    2bac:	90 91 85 03 	lds	r25, 0x0385
    2bb0:	f8 01       	movw	r30, r16
    2bb2:	91 8b       	std	Z+17, r25	; 0x11
    2bb4:	80 8b       	std	Z+16, r24	; 0x10
  BUF->srcipaddr[0] = tmp16;
    2bb6:	35 87       	std	Z+13, r19	; 0x0d
    2bb8:	24 87       	std	Z+12, r18	; 0x0c
  tmp16 = BUF->destipaddr[1];
    2bba:	20 91 8a 03 	lds	r18, 0x038A
    2bbe:	30 91 8b 03 	lds	r19, 0x038B
    2bc2:	30 93 86 00 	sts	0x0086, r19
    2bc6:	20 93 85 00 	sts	0x0085, r18
  BUF->destipaddr[1] = BUF->srcipaddr[1];
    2bca:	80 91 86 03 	lds	r24, 0x0386
    2bce:	90 91 87 03 	lds	r25, 0x0387
    2bd2:	93 8b       	std	Z+19, r25	; 0x13
    2bd4:	82 8b       	std	Z+18, r24	; 0x12
  BUF->srcipaddr[1] = tmp16;
    2bd6:	37 87       	std	Z+15, r19	; 0x0f
    2bd8:	26 87       	std	Z+14, r18	; 0x0e
    2bda:	ec c4       	rjmp	.+2520   	; 0x35b4 <uip_process+0xc50>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2bdc:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <uip_tcpchksum>
    2be0:	8f 5f       	subi	r24, 0xFF	; 255
    2be2:	9f 4f       	sbci	r25, 0xFF	; 255
    2be4:	09 f0       	breq	.+2      	; 0x2be8 <uip_process+0x284>
    2be6:	e2 c4       	rjmp	.+2500   	; 0x35ac <uip_process+0xc48>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");    
    goto drop;
    2be8:	c7 ef       	ldi	r28, 0xF7	; 247
    2bea:	d2 e0       	ldi	r29, 0x02	; 2
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr < &uip_conns[UIP_CONNS]; ++uip_connr) {
    if(uip_connr->tcpstateflags != CLOSED &&
    2bec:	89 8d       	ldd	r24, Y+25	; 0x19
    2bee:	88 23       	and	r24, r24
    2bf0:	29 f1       	breq	.+74     	; 0x2c3c <uip_process+0x2d8>
    2bf2:	20 91 8e 03 	lds	r18, 0x038E
    2bf6:	30 91 8f 03 	lds	r19, 0x038F
    2bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    2bfc:	9d 81       	ldd	r25, Y+5	; 0x05
    2bfe:	28 17       	cp	r18, r24
    2c00:	39 07       	cpc	r19, r25
    2c02:	e1 f4       	brne	.+56     	; 0x2c3c <uip_process+0x2d8>
    2c04:	20 91 8c 03 	lds	r18, 0x038C
    2c08:	30 91 8d 03 	lds	r19, 0x038D
    2c0c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c0e:	9f 81       	ldd	r25, Y+7	; 0x07
    2c10:	28 17       	cp	r18, r24
    2c12:	39 07       	cpc	r19, r25
    2c14:	99 f4       	brne	.+38     	; 0x2c3c <uip_process+0x2d8>
    2c16:	20 91 84 03 	lds	r18, 0x0384
    2c1a:	30 91 85 03 	lds	r19, 0x0385
    2c1e:	88 81       	ld	r24, Y
    2c20:	99 81       	ldd	r25, Y+1	; 0x01
    2c22:	28 17       	cp	r18, r24
    2c24:	39 07       	cpc	r19, r25
    2c26:	51 f4       	brne	.+20     	; 0x2c3c <uip_process+0x2d8>
    2c28:	20 91 86 03 	lds	r18, 0x0386
    2c2c:	30 91 87 03 	lds	r19, 0x0387
    2c30:	8a 81       	ldd	r24, Y+2	; 0x02
    2c32:	9b 81       	ldd	r25, Y+3	; 0x03
    2c34:	28 17       	cp	r18, r24
    2c36:	39 07       	cpc	r19, r25
    2c38:	09 f4       	brne	.+2      	; 0x2c3c <uip_process+0x2d8>
    2c3a:	74 c1       	rjmp	.+744    	; 0x2f24 <uip_process+0x5c0>
    goto drop;
  }
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr < &uip_conns[UIP_CONNS]; ++uip_connr) {
    2c3c:	a3 96       	adiw	r28, 0x23	; 35
    2c3e:	23 e0       	ldi	r18, 0x03	; 3
    2c40:	c0 36       	cpi	r28, 0x60	; 96
    2c42:	d2 07       	cpc	r29, r18
    2c44:	99 f6       	brne	.-90     	; 0x2bec <uip_process+0x288>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN)
    2c46:	80 91 99 03 	lds	r24, 0x0399
    2c4a:	8f 73       	andi	r24, 0x3F	; 63
    2c4c:	82 30       	cpi	r24, 0x02	; 2
    2c4e:	e9 f4       	brne	.+58     	; 0x2c8a <uip_process+0x326>
    goto reset;
  
  tmp16 = BUF->destport;
    2c50:	40 91 8e 03 	lds	r20, 0x038E
    2c54:	50 91 8f 03 	lds	r21, 0x038F
    2c58:	50 93 86 00 	sts	0x0086, r21
    2c5c:	40 93 85 00 	sts	0x0085, r20
  /* Next, check listening connections. */  
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2c60:	10 92 83 00 	sts	0x0083, r1
    2c64:	20 e0       	ldi	r18, 0x00	; 0
    2c66:	0d c0       	rjmp	.+26     	; 0x2c82 <uip_process+0x31e>
    if(tmp16 == uip_listenports[c])
    2c68:	e2 2f       	mov	r30, r18
    2c6a:	ff 27       	eor	r31, r31
    2c6c:	ee 0f       	add	r30, r30
    2c6e:	ff 1f       	adc	r31, r31
    2c70:	e0 5a       	subi	r30, 0xA0	; 160
    2c72:	fc 4f       	sbci	r31, 0xFC	; 252
    2c74:	80 81       	ld	r24, Z
    2c76:	91 81       	ldd	r25, Z+1	; 0x01
    2c78:	2f 5f       	subi	r18, 0xFF	; 255
    2c7a:	48 17       	cp	r20, r24
    2c7c:	59 07       	cpc	r21, r25
    2c7e:	09 f4       	brne	.+2      	; 0x2c82 <uip_process+0x31e>
    2c80:	66 c0       	rjmp	.+204    	; 0x2d4e <uip_process+0x3ea>
  if((BUF->flags & TCP_CTL) != TCP_SYN)
    goto reset;
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */  
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2c82:	25 30       	cpi	r18, 0x05	; 5
    2c84:	88 f3       	brcs	.-30     	; 0x2c68 <uip_process+0x304>
    2c86:	20 93 83 00 	sts	0x0083, r18
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) 
    2c8a:	80 91 99 03 	lds	r24, 0x0399
    2c8e:	82 fd       	sbrc	r24, 2
    2c90:	8d c4       	rjmp	.+2330   	; 0x35ac <uip_process+0xc48>
    goto drop;

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
    2c92:	84 e1       	ldi	r24, 0x14	; 20
    2c94:	f8 01       	movw	r30, r16
    2c96:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = 40;
    2c98:	88 e2       	ldi	r24, 0x28	; 40
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	90 93 eb 02 	sts	0x02EB, r25
    2ca0:	80 93 ea 02 	sts	0x02EA, r24
  BUF->tcpoffset = 5 << 4;
    2ca4:	80 e5       	ldi	r24, 0x50	; 80
    2ca6:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    2ca8:	90 91 93 03 	lds	r25, 0x0393
  BUF->seqno[3] = BUF->ackno[3];  
    2cac:	80 91 97 03 	lds	r24, 0x0397
    2cb0:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    2cb2:	30 91 92 03 	lds	r19, 0x0392
  BUF->seqno[2] = BUF->ackno[2];  
    2cb6:	80 91 96 03 	lds	r24, 0x0396
    2cba:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    2cbc:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    2cbe:	40 91 91 03 	lds	r20, 0x0391
  BUF->seqno[1] = BUF->ackno[1];
    2cc2:	80 91 95 03 	lds	r24, 0x0395
    2cc6:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    2cc8:	45 8f       	std	Z+29, r20	; 0x1d
  
  c = BUF->seqno[0];
    2cca:	20 91 90 03 	lds	r18, 0x0390
    2cce:	20 93 83 00 	sts	0x0083, r18
  BUF->seqno[0] = BUF->ackno[0];  
    2cd2:	80 91 94 03 	lds	r24, 0x0394
    2cd6:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    2cd8:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    2cda:	9f 5f       	subi	r25, 0xFF	; 255
    2cdc:	97 8f       	std	Z+31, r25	; 0x1f
    2cde:	99 23       	and	r25, r25
    2ce0:	61 f4       	brne	.+24     	; 0x2cfa <uip_process+0x396>
    if(++BUF->ackno[2] == 0) {
    2ce2:	83 2f       	mov	r24, r19
    2ce4:	8f 5f       	subi	r24, 0xFF	; 255
    2ce6:	86 8f       	std	Z+30, r24	; 0x1e
    2ce8:	88 23       	and	r24, r24
    2cea:	39 f4       	brne	.+14     	; 0x2cfa <uip_process+0x396>
      if(++BUF->ackno[1] == 0) {
    2cec:	84 2f       	mov	r24, r20
    2cee:	8f 5f       	subi	r24, 0xFF	; 255
    2cf0:	85 8f       	std	Z+29, r24	; 0x1d
    2cf2:	88 23       	and	r24, r24
    2cf4:	11 f4       	brne	.+4      	; 0x2cfa <uip_process+0x396>
	++BUF->ackno[0];
    2cf6:	2f 5f       	subi	r18, 0xFF	; 255
    2cf8:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2cfa:	20 91 8c 03 	lds	r18, 0x038C
    2cfe:	30 91 8d 03 	lds	r19, 0x038D
  BUF->srcport = BUF->destport;
    2d02:	80 91 8e 03 	lds	r24, 0x038E
    2d06:	90 91 8f 03 	lds	r25, 0x038F
    2d0a:	f8 01       	movw	r30, r16
    2d0c:	95 8b       	std	Z+21, r25	; 0x15
    2d0e:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    2d10:	37 8b       	std	Z+23, r19	; 0x17
    2d12:	26 8b       	std	Z+22, r18	; 0x16
  
  /* Swap IP addresses. */
  tmp16 = BUF->destipaddr[0];
    2d14:	20 91 88 03 	lds	r18, 0x0388
    2d18:	30 91 89 03 	lds	r19, 0x0389
  BUF->destipaddr[0] = BUF->srcipaddr[0];
    2d1c:	80 91 84 03 	lds	r24, 0x0384
    2d20:	90 91 85 03 	lds	r25, 0x0385
    2d24:	91 8b       	std	Z+17, r25	; 0x11
    2d26:	80 8b       	std	Z+16, r24	; 0x10
  BUF->srcipaddr[0] = tmp16;
    2d28:	35 87       	std	Z+13, r19	; 0x0d
    2d2a:	24 87       	std	Z+12, r18	; 0x0c
  tmp16 = BUF->destipaddr[1];
    2d2c:	20 91 8a 03 	lds	r18, 0x038A
    2d30:	30 91 8b 03 	lds	r19, 0x038B
    2d34:	30 93 86 00 	sts	0x0086, r19
    2d38:	20 93 85 00 	sts	0x0085, r18
  BUF->destipaddr[1] = BUF->srcipaddr[1];
    2d3c:	80 91 86 03 	lds	r24, 0x0386
    2d40:	90 91 87 03 	lds	r25, 0x0387
    2d44:	93 8b       	std	Z+19, r25	; 0x13
    2d46:	82 8b       	std	Z+18, r24	; 0x12
  BUF->srcipaddr[1] = tmp16;
    2d48:	37 87       	std	Z+15, r19	; 0x0f
    2d4a:	26 87       	std	Z+14, r18	; 0x0e
    2d4c:	ed c3       	rjmp	.+2010   	; 0x3528 <uip_process+0xbc4>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2d4e:	10 92 83 00 	sts	0x0083, r1
    2d52:	c0 e0       	ldi	r28, 0x00	; 0
    2d54:	d0 e0       	ldi	r29, 0x00	; 0
    2d56:	40 e0       	ldi	r20, 0x00	; 0
    2d58:	28 c0       	rjmp	.+80     	; 0x2daa <uip_process+0x446>
    if(uip_conns[c].tcpstateflags == CLOSED) {
    2d5a:	24 2f       	mov	r18, r20
    2d5c:	33 27       	eor	r19, r19
    2d5e:	83 e2       	ldi	r24, 0x23	; 35
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	28 9f       	mul	r18, r24
    2d64:	f0 01       	movw	r30, r0
    2d66:	29 9f       	mul	r18, r25
    2d68:	f0 0d       	add	r31, r0
    2d6a:	38 9f       	mul	r19, r24
    2d6c:	f0 0d       	add	r31, r0
    2d6e:	11 24       	eor	r1, r1
    2d70:	e9 50       	subi	r30, 0x09	; 9
    2d72:	fd 4f       	sbci	r31, 0xFD	; 253
    2d74:	81 8d       	ldd	r24, Z+25	; 0x19
    2d76:	88 23       	and	r24, r24
    2d78:	49 f4       	brne	.+18     	; 0x2d8c <uip_process+0x428>
    2d7a:	40 93 83 00 	sts	0x0083, r20
      uip_connr = &uip_conns[c];
    2d7e:	83 e2       	ldi	r24, 0x23	; 35
    2d80:	48 9f       	mul	r20, r24
    2d82:	e0 01       	movw	r28, r0
    2d84:	11 24       	eor	r1, r1
    2d86:	c9 50       	subi	r28, 0x09	; 9
    2d88:	dd 4f       	sbci	r29, 0xFD	; 253
    2d8a:	13 c0       	rjmp	.+38     	; 0x2db2 <uip_process+0x44e>
      break;
    }
    if(uip_conns[c].tcpstateflags == TIME_WAIT) {
    2d8c:	87 30       	cpi	r24, 0x07	; 7
    2d8e:	61 f4       	brne	.+24     	; 0x2da8 <uip_process+0x444>
      if(uip_connr == 0 ||
    2d90:	20 97       	sbiw	r28, 0x00	; 0
    2d92:	21 f0       	breq	.+8      	; 0x2d9c <uip_process+0x438>
    2d94:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d96:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d98:	89 17       	cp	r24, r25
    2d9a:	30 f4       	brcc	.+12     	; 0x2da8 <uip_process+0x444>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    2d9c:	83 e2       	ldi	r24, 0x23	; 35
    2d9e:	48 9f       	mul	r20, r24
    2da0:	e0 01       	movw	r28, r0
    2da2:	11 24       	eor	r1, r1
    2da4:	c9 50       	subi	r28, 0x09	; 9
    2da6:	dd 4f       	sbci	r29, 0xFD	; 253
    2da8:	4f 5f       	subi	r20, 0xFF	; 255
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2daa:	43 30       	cpi	r20, 0x03	; 3
    2dac:	b0 f2       	brcs	.-84     	; 0x2d5a <uip_process+0x3f6>
    2dae:	40 93 83 00 	sts	0x0083, r20
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    2db2:	20 97       	sbiw	r28, 0x00	; 0
    2db4:	09 f4       	brne	.+2      	; 0x2db8 <uip_process+0x454>
    2db6:	fa c3       	rjmp	.+2036   	; 0x35ac <uip_process+0xc48>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    2db8:	d0 93 f6 02 	sts	0x02F6, r29
    2dbc:	c0 93 f5 02 	sts	0x02F5, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    2dc0:	83 e0       	ldi	r24, 0x03	; 3
    2dc2:	8a 8f       	std	Y+26, r24	; 0x1a
    2dc4:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    2dc6:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;  
    2dc8:	84 e0       	ldi	r24, 0x04	; 4
    2dca:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    2dcc:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    2dce:	80 91 8e 03 	lds	r24, 0x038E
    2dd2:	90 91 8f 03 	lds	r25, 0x038F
    2dd6:	9d 83       	std	Y+5, r25	; 0x05
    2dd8:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    2dda:	80 91 8c 03 	lds	r24, 0x038C
    2dde:	90 91 8d 03 	lds	r25, 0x038D
    2de2:	9f 83       	std	Y+7, r25	; 0x07
    2de4:	8e 83       	std	Y+6, r24	; 0x06
  uip_connr->ripaddr[0] = BUF->srcipaddr[0];
    2de6:	80 91 84 03 	lds	r24, 0x0384
    2dea:	90 91 85 03 	lds	r25, 0x0385
    2dee:	99 83       	std	Y+1, r25	; 0x01
    2df0:	88 83       	st	Y, r24
  uip_connr->ripaddr[1] = BUF->srcipaddr[1];
    2df2:	80 91 86 03 	lds	r24, 0x0386
    2df6:	90 91 87 03 	lds	r25, 0x0387
    2dfa:	9b 83       	std	Y+3, r25	; 0x03
    2dfc:	8a 83       	std	Y+2, r24	; 0x02
  uip_connr->tcpstateflags = SYN_RCVD;
    2dfe:	81 e0       	ldi	r24, 0x01	; 1
    2e00:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    2e02:	80 91 7d 00 	lds	r24, 0x007D
    2e06:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    2e08:	80 91 7e 00 	lds	r24, 0x007E
    2e0c:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    2e0e:	80 91 7f 00 	lds	r24, 0x007F
    2e12:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    2e14:	80 91 80 00 	lds	r24, 0x0080
    2e18:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    2e1a:	81 e0       	ldi	r24, 0x01	; 1
    2e1c:	90 e0       	ldi	r25, 0x00	; 0
    2e1e:	99 8b       	std	Y+17, r25	; 0x11
    2e20:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2e22:	80 91 93 03 	lds	r24, 0x0393
    2e26:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2e28:	80 91 92 03 	lds	r24, 0x0392
    2e2c:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2e2e:	80 91 91 03 	lds	r24, 0x0391
    2e32:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2e34:	80 91 90 03 	lds	r24, 0x0390
    2e38:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    2e3a:	81 e0       	ldi	r24, 0x01	; 1
    2e3c:	90 e0       	ldi	r25, 0x00	; 0
    2e3e:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    2e42:	80 91 98 03 	lds	r24, 0x0398
    2e46:	99 27       	eor	r25, r25
    2e48:	80 7f       	andi	r24, 0xF0	; 240
    2e4a:	90 70       	andi	r25, 0x00	; 0
    2e4c:	81 35       	cpi	r24, 0x51	; 81
    2e4e:	91 05       	cpc	r25, r1
    2e50:	0c f4       	brge	.+2      	; 0x2e54 <uip_process+0x4f0>
    2e52:	4e c0       	rjmp	.+156    	; 0x2ef0 <uip_process+0x58c>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2e54:	10 92 83 00 	sts	0x0083, r1
    2e58:	20 91 84 00 	lds	r18, 0x0084
    2e5c:	30 e0       	ldi	r19, 0x00	; 0
    2e5e:	34 c0       	rjmp	.+104    	; 0x2ec8 <uip_process+0x564>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2e60:	fd 01       	movw	r30, r26
    2e62:	e6 59       	subi	r30, 0x96	; 150
    2e64:	fc 4f       	sbci	r31, 0xFC	; 252
    2e66:	26 a9       	ldd	r18, Z+54	; 0x36
      if(opt == 0x00) {
    2e68:	22 23       	and	r18, r18
    2e6a:	19 f4       	brne	.+6      	; 0x2e72 <uip_process+0x50e>
    2e6c:	10 92 84 00 	sts	0x0084, r1
    2e70:	3d c0       	rjmp	.+122    	; 0x2eec <uip_process+0x588>
	/* End of options. */	
	break;
      } else if(opt == 0x01) {
    2e72:	21 30       	cpi	r18, 0x01	; 1
    2e74:	11 f4       	brne	.+4      	; 0x2e7a <uip_process+0x516>
	++c;
    2e76:	3f 5f       	subi	r19, 0xFF	; 255
    2e78:	27 c0       	rjmp	.+78     	; 0x2ec8 <uip_process+0x564>
	/* NOP option. */
      } else if(opt == 0x02 &&
    2e7a:	22 30       	cpi	r18, 0x02	; 2
    2e7c:	f1 f4       	brne	.+60     	; 0x2eba <uip_process+0x556>
    2e7e:	87 a9       	ldd	r24, Z+55	; 0x37
    2e80:	84 30       	cpi	r24, 0x04	; 4
    2e82:	d9 f4       	brne	.+54     	; 0x2eba <uip_process+0x556>
    2e84:	20 93 84 00 	sts	0x0084, r18
    2e88:	30 93 83 00 	sts	0x0083, r19
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0x04) {
	/* An MSS option with the right option length. */	
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2e8c:	20 ad       	ldd	r18, Z+56	; 0x38
    2e8e:	33 27       	eor	r19, r19
    2e90:	32 2f       	mov	r19, r18
    2e92:	22 27       	eor	r18, r18
    2e94:	81 ad       	ldd	r24, Z+57	; 0x39
    2e96:	99 27       	eor	r25, r25
    2e98:	28 2b       	or	r18, r24
    2e9a:	39 2b       	or	r19, r25
    2e9c:	30 93 86 00 	sts	0x0086, r19
    2ea0:	20 93 85 00 	sts	0x0085, r18
	  (u16_t)uip_buf[40 + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2ea4:	f2 e0       	ldi	r31, 0x02	; 2
    2ea6:	21 30       	cpi	r18, 0x01	; 1
    2ea8:	3f 07       	cpc	r19, r31
    2eaa:	10 f0       	brcs	.+4      	; 0x2eb0 <uip_process+0x54c>
    2eac:	20 e0       	ldi	r18, 0x00	; 0
    2eae:	32 e0       	ldi	r19, 0x02	; 2
    2eb0:	3b 8b       	std	Y+19, r19	; 0x13
    2eb2:	2a 8b       	std	Y+18, r18	; 0x12
    2eb4:	3d 8b       	std	Y+21, r19	; 0x15
    2eb6:	2c 8b       	std	Y+20, r18	; 0x14
    2eb8:	1b c0       	rjmp	.+54     	; 0x2ef0 <uip_process+0x58c>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2eba:	a6 59       	subi	r26, 0x96	; 150
    2ebc:	bc 4f       	sbci	r27, 0xFC	; 252
    2ebe:	d7 96       	adiw	r26, 0x37	; 55
    2ec0:	8c 91       	ld	r24, X
    2ec2:	88 23       	and	r24, r24
    2ec4:	89 f0       	breq	.+34     	; 0x2ee8 <uip_process+0x584>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2ec6:	38 0f       	add	r19, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2ec8:	a3 2f       	mov	r26, r19
    2eca:	bb 27       	eor	r27, r27
    2ecc:	80 91 98 03 	lds	r24, 0x0398
    2ed0:	82 95       	swap	r24
    2ed2:	8f 70       	andi	r24, 0x0F	; 15
    2ed4:	99 27       	eor	r25, r25
    2ed6:	05 97       	sbiw	r24, 0x05	; 5
    2ed8:	88 0f       	add	r24, r24
    2eda:	99 1f       	adc	r25, r25
    2edc:	88 0f       	add	r24, r24
    2ede:	99 1f       	adc	r25, r25
    2ee0:	a8 17       	cp	r26, r24
    2ee2:	b9 07       	cpc	r27, r25
    2ee4:	0c f4       	brge	.+2      	; 0x2ee8 <uip_process+0x584>
    2ee6:	bc cf       	rjmp	.-136    	; 0x2e60 <uip_process+0x4fc>
    2ee8:	20 93 84 00 	sts	0x0084, r18
    2eec:	30 93 83 00 	sts	0x0083, r19
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;    
    2ef0:	80 e1       	ldi	r24, 0x10	; 16
    2ef2:	80 93 99 03 	sts	0x0399, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;    
    2ef6:	80 91 99 03 	lds	r24, 0x0399
    2efa:	82 60       	ori	r24, 0x02	; 2
    2efc:	80 93 99 03 	sts	0x0399, r24
  BUF->flags = TCP_SYN | TCP_ACK;    
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = 2;
    2f00:	92 e0       	ldi	r25, 0x02	; 2
    2f02:	90 93 a0 03 	sts	0x03A0, r25
  BUF->optdata[1] = 4;
    2f06:	84 e0       	ldi	r24, 0x04	; 4
    2f08:	80 93 a1 03 	sts	0x03A1, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2f0c:	90 93 a2 03 	sts	0x03A2, r25
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2f10:	10 92 a3 03 	sts	0x03A3, r1
  uip_len = 44;
    2f14:	8c e2       	ldi	r24, 0x2C	; 44
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	90 93 eb 02 	sts	0x02EB, r25
    2f1c:	80 93 ea 02 	sts	0x02EA, r24
  BUF->tcpoffset = 6 << 4;
    2f20:	80 e6       	ldi	r24, 0x60	; 96
    2f22:	b4 c2       	rjmp	.+1384   	; 0x348c <uip_process+0xb28>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    2f24:	d0 93 f6 02 	sts	0x02F6, r29
    2f28:	c0 93 f5 02 	sts	0x02F5, r28
  uip_flags = 0;
    2f2c:	10 92 f2 02 	sts	0x02F2, r1

  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2f30:	80 91 99 03 	lds	r24, 0x0399
    2f34:	48 2f       	mov	r20, r24
    2f36:	55 27       	eor	r21, r21
    2f38:	42 ff       	sbrs	r20, 2
    2f3a:	03 c0       	rjmp	.+6      	; 0x2f42 <uip_process+0x5de>
    uip_connr->tcpstateflags = CLOSED;
    2f3c:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2f3e:	80 e2       	ldi	r24, 0x20	; 32
    2f40:	44 c2       	rjmp	.+1160   	; 0x33ca <uip_process+0xa66>
    UIP_APPCALL();
    goto drop;
  }      
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2f42:	80 91 98 03 	lds	r24, 0x0398
    2f46:	82 95       	swap	r24
    2f48:	8f 70       	andi	r24, 0x0F	; 15
    2f4a:	88 0f       	add	r24, r24
    2f4c:	88 0f       	add	r24, r24
    2f4e:	80 93 83 00 	sts	0x0083, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - 20;
    2f52:	20 91 ea 02 	lds	r18, 0x02EA
    2f56:	30 91 eb 02 	lds	r19, 0x02EB
    2f5a:	28 1b       	sub	r18, r24
    2f5c:	31 09       	sbc	r19, r1
    2f5e:	24 51       	subi	r18, 0x14	; 20
    2f60:	30 40       	sbci	r19, 0x00	; 0
    2f62:	30 93 eb 02 	sts	0x02EB, r19
    2f66:	20 93 ea 02 	sts	0x02EA, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(uip_len > 0 &&
    2f6a:	80 91 ea 02 	lds	r24, 0x02EA
    2f6e:	90 91 eb 02 	lds	r25, 0x02EB
    2f72:	89 2b       	or	r24, r25
    2f74:	c1 f0       	breq	.+48     	; 0x2fa6 <uip_process+0x642>
    2f76:	90 91 90 03 	lds	r25, 0x0390
    2f7a:	88 85       	ldd	r24, Y+8	; 0x08
    2f7c:	98 17       	cp	r25, r24
    2f7e:	09 f0       	breq	.+2      	; 0x2f82 <uip_process+0x61e>
    2f80:	7b c2       	rjmp	.+1270   	; 0x3478 <uip_process+0xb14>
    2f82:	90 91 91 03 	lds	r25, 0x0391
    2f86:	89 85       	ldd	r24, Y+9	; 0x09
    2f88:	98 17       	cp	r25, r24
    2f8a:	09 f0       	breq	.+2      	; 0x2f8e <uip_process+0x62a>
    2f8c:	75 c2       	rjmp	.+1258   	; 0x3478 <uip_process+0xb14>
    2f8e:	90 91 92 03 	lds	r25, 0x0392
    2f92:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f94:	98 17       	cp	r25, r24
    2f96:	09 f0       	breq	.+2      	; 0x2f9a <uip_process+0x636>
    2f98:	6f c2       	rjmp	.+1246   	; 0x3478 <uip_process+0xb14>
    2f9a:	90 91 93 03 	lds	r25, 0x0393
    2f9e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2fa0:	98 17       	cp	r25, r24
    2fa2:	09 f0       	breq	.+2      	; 0x2fa6 <uip_process+0x642>
    2fa4:	69 c2       	rjmp	.+1234   	; 0x3478 <uip_process+0xb14>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    2fa6:	44 ff       	sbrs	r20, 4
    2fa8:	51 c0       	rjmp	.+162    	; 0x304c <uip_process+0x6e8>
    2faa:	68 89       	ldd	r22, Y+16	; 0x10
    2fac:	79 89       	ldd	r23, Y+17	; 0x11
    2fae:	61 15       	cp	r22, r1
    2fb0:	71 05       	cpc	r23, r1
    2fb2:	09 f4       	brne	.+2      	; 0x2fb6 <uip_process+0x652>
    2fb4:	4b c0       	rjmp	.+150    	; 0x304c <uip_process+0x6e8>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    2fb6:	ce 01       	movw	r24, r28
    2fb8:	0c 96       	adiw	r24, 0x0c	; 12
    2fba:	0e 94 7d 1d 	call	0x3afa	; 0x3afa <uip_add32>
    if(BUF->ackno[0] == uip_acc32[0] &&
    2fbe:	90 91 94 03 	lds	r25, 0x0394
    2fc2:	80 91 ee 02 	lds	r24, 0x02EE
    2fc6:	98 17       	cp	r25, r24
    2fc8:	09 f0       	breq	.+2      	; 0x2fcc <uip_process+0x668>
    2fca:	40 c0       	rjmp	.+128    	; 0x304c <uip_process+0x6e8>
    2fcc:	90 91 95 03 	lds	r25, 0x0395
    2fd0:	80 91 ef 02 	lds	r24, 0x02EF
    2fd4:	98 17       	cp	r25, r24
    2fd6:	d1 f5       	brne	.+116    	; 0x304c <uip_process+0x6e8>
    2fd8:	90 91 96 03 	lds	r25, 0x0396
    2fdc:	80 91 f0 02 	lds	r24, 0x02F0
    2fe0:	98 17       	cp	r25, r24
    2fe2:	a1 f5       	brne	.+104    	; 0x304c <uip_process+0x6e8>
    2fe4:	90 91 97 03 	lds	r25, 0x0397
    2fe8:	80 91 f1 02 	lds	r24, 0x02F1
    2fec:	98 17       	cp	r25, r24
    2fee:	71 f5       	brne	.+92     	; 0x304c <uip_process+0x6e8>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2ff0:	80 91 ee 02 	lds	r24, 0x02EE
    2ff4:	8c 87       	std	Y+12, r24	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2ff6:	80 91 ef 02 	lds	r24, 0x02EF
    2ffa:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2ffc:	80 91 f0 02 	lds	r24, 0x02F0
    3000:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    3002:	80 91 f1 02 	lds	r24, 0x02F1
    3006:	8f 87       	std	Y+15, r24	; 0x0f
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    3008:	8b 8d       	ldd	r24, Y+27	; 0x1b
    300a:	88 23       	and	r24, r24
    300c:	d1 f4       	brne	.+52     	; 0x3042 <uip_process+0x6de>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    300e:	2e 89       	ldd	r18, Y+22	; 0x16
    3010:	98 8d       	ldd	r25, Y+24	; 0x18
    3012:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3014:	98 1b       	sub	r25, r24
    3016:	82 2f       	mov	r24, r18
    3018:	86 95       	lsr	r24
    301a:	86 95       	lsr	r24
    301c:	86 95       	lsr	r24
    301e:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    3020:	39 2f       	mov	r19, r25
    3022:	32 0f       	add	r19, r18
    3024:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    3026:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    3028:	28 2f       	mov	r18, r24
    302a:	26 95       	lsr	r18
    302c:	26 95       	lsr	r18
    302e:	82 1b       	sub	r24, r18
    3030:	97 fd       	sbrc	r25, 7
    3032:	91 95       	neg	r25
    3034:	89 0f       	add	r24, r25
    3036:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    3038:	36 95       	lsr	r19
    303a:	36 95       	lsr	r19
    303c:	36 95       	lsr	r19
    303e:	83 0f       	add	r24, r19
    3040:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    3042:	81 e0       	ldi	r24, 0x01	; 1
    3044:	80 93 f2 02 	sts	0x02F2, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    3048:	88 8d       	ldd	r24, Y+24	; 0x18
    304a:	8a 8f       	std	Y+26, r24	; 0x1a
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & TS_MASK) {
    304c:	89 8d       	ldd	r24, Y+25	; 0x19
    304e:	48 2f       	mov	r20, r24
    3050:	55 27       	eor	r21, r21
    3052:	ca 01       	movw	r24, r20
    3054:	8f 70       	andi	r24, 0x0F	; 15
    3056:	90 70       	andi	r25, 0x00	; 0
    3058:	84 30       	cpi	r24, 0x04	; 4
    305a:	91 05       	cpc	r25, r1
    305c:	09 f4       	brne	.+2      	; 0x3060 <uip_process+0x6fc>
    305e:	ba c1       	rjmp	.+884    	; 0x33d4 <uip_process+0xa70>
    3060:	85 30       	cpi	r24, 0x05	; 5
    3062:	91 05       	cpc	r25, r1
    3064:	5c f4       	brge	.+22     	; 0x307c <uip_process+0x718>
    3066:	82 30       	cpi	r24, 0x02	; 2
    3068:	91 05       	cpc	r25, r1
    306a:	b1 f1       	breq	.+108    	; 0x30d8 <uip_process+0x774>
    306c:	83 30       	cpi	r24, 0x03	; 3
    306e:	91 05       	cpc	r25, r1
    3070:	0c f0       	brlt	.+2      	; 0x3074 <uip_process+0x710>
    3072:	ae c0       	rjmp	.+348    	; 0x31d0 <uip_process+0x86c>
    3074:	01 97       	sbiw	r24, 0x01	; 1
    3076:	09 f0       	breq	.+2      	; 0x307a <uip_process+0x716>
    3078:	99 c2       	rjmp	.+1330   	; 0x35ac <uip_process+0xc48>
    307a:	10 c0       	rjmp	.+32     	; 0x309c <uip_process+0x738>
    307c:	86 30       	cpi	r24, 0x06	; 6
    307e:	91 05       	cpc	r25, r1
    3080:	09 f4       	brne	.+2      	; 0x3084 <uip_process+0x720>
    3082:	f2 c1       	rjmp	.+996    	; 0x3468 <uip_process+0xb04>
    3084:	86 30       	cpi	r24, 0x06	; 6
    3086:	91 05       	cpc	r25, r1
    3088:	0c f4       	brge	.+2      	; 0x308c <uip_process+0x728>
    308a:	ca c1       	rjmp	.+916    	; 0x3420 <uip_process+0xabc>
    308c:	87 30       	cpi	r24, 0x07	; 7
    308e:	91 05       	cpc	r25, r1
    3090:	09 f4       	brne	.+2      	; 0x3094 <uip_process+0x730>
    3092:	f2 c1       	rjmp	.+996    	; 0x3478 <uip_process+0xb14>
    3094:	08 97       	sbiw	r24, 0x08	; 8
    3096:	09 f0       	breq	.+2      	; 0x309a <uip_process+0x736>
    3098:	89 c2       	rjmp	.+1298   	; 0x35ac <uip_process+0xc48>
    309a:	91 c1       	rjmp	.+802    	; 0x33be <uip_process+0xa5a>
  case SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    309c:	80 91 f2 02 	lds	r24, 0x02F2
    30a0:	80 ff       	sbrs	r24, 0
    30a2:	84 c2       	rjmp	.+1288   	; 0x35ac <uip_process+0xc48>
      uip_connr->tcpstateflags = ESTABLISHED;
    30a4:	83 e0       	ldi	r24, 0x03	; 3
    30a6:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    30a8:	80 e4       	ldi	r24, 0x40	; 64
    30aa:	80 93 f2 02 	sts	0x02F2, r24
      uip_connr->len = 0;
    30ae:	19 8a       	std	Y+17, r1	; 0x11
    30b0:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    30b2:	80 91 ea 02 	lds	r24, 0x02EA
    30b6:	90 91 eb 02 	lds	r25, 0x02EB
    30ba:	89 2b       	or	r24, r25
    30bc:	09 f4       	brne	.+2      	; 0x30c0 <uip_process+0x75c>
    30be:	0d c1       	rjmp	.+538    	; 0x32da <uip_process+0x976>
        uip_flags |= UIP_NEWDATA;
    30c0:	80 91 f2 02 	lds	r24, 0x02F2
    30c4:	82 60       	ori	r24, 0x02	; 2
    30c6:	80 93 f2 02 	sts	0x02F2, r24
        uip_add_rcv_nxt(uip_len);
    30ca:	80 91 ea 02 	lds	r24, 0x02EA
    30ce:	90 91 eb 02 	lds	r25, 0x02EB
    30d2:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
    30d6:	01 c1       	rjmp	.+514    	; 0x32da <uip_process+0x976>
  case SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    30d8:	80 91 f2 02 	lds	r24, 0x02F2
    30dc:	80 ff       	sbrs	r24, 0
    30de:	d5 cd       	rjmp	.-1110   	; 0x2c8a <uip_process+0x326>
    30e0:	80 91 99 03 	lds	r24, 0x0399
    30e4:	82 31       	cpi	r24, 0x12	; 18
    30e6:	09 f0       	breq	.+2      	; 0x30ea <uip_process+0x786>
    30e8:	d0 cd       	rjmp	.-1120   	; 0x2c8a <uip_process+0x326>
       BUF->flags == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    30ea:	80 91 98 03 	lds	r24, 0x0398
    30ee:	99 27       	eor	r25, r25
    30f0:	80 7f       	andi	r24, 0xF0	; 240
    30f2:	90 70       	andi	r25, 0x00	; 0
    30f4:	81 35       	cpi	r24, 0x51	; 81
    30f6:	91 05       	cpc	r25, r1
    30f8:	0c f4       	brge	.+2      	; 0x30fc <uip_process+0x798>
    30fa:	4e c0       	rjmp	.+156    	; 0x3198 <uip_process+0x834>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    30fc:	10 92 83 00 	sts	0x0083, r1
    3100:	20 91 84 00 	lds	r18, 0x0084
    3104:	30 e0       	ldi	r19, 0x00	; 0
    3106:	34 c0       	rjmp	.+104    	; 0x3170 <uip_process+0x80c>
	  opt = uip_buf[40 + UIP_LLH_LEN + c];
    3108:	fd 01       	movw	r30, r26
    310a:	e6 59       	subi	r30, 0x96	; 150
    310c:	fc 4f       	sbci	r31, 0xFC	; 252
    310e:	26 a9       	ldd	r18, Z+54	; 0x36
	  if(opt == 0x00) {
    3110:	22 23       	and	r18, r18
    3112:	19 f4       	brne	.+6      	; 0x311a <uip_process+0x7b6>
    3114:	10 92 84 00 	sts	0x0084, r1
    3118:	3d c0       	rjmp	.+122    	; 0x3194 <uip_process+0x830>
	    /* End of options. */	
	    break;
	  } else if(opt == 0x01) {
    311a:	21 30       	cpi	r18, 0x01	; 1
    311c:	11 f4       	brne	.+4      	; 0x3122 <uip_process+0x7be>
	    ++c;
    311e:	3f 5f       	subi	r19, 0xFF	; 255
    3120:	27 c0       	rjmp	.+78     	; 0x3170 <uip_process+0x80c>
	    /* NOP option. */
	  } else if(opt == 0x02 &&
    3122:	22 30       	cpi	r18, 0x02	; 2
    3124:	f1 f4       	brne	.+60     	; 0x3162 <uip_process+0x7fe>
    3126:	87 a9       	ldd	r24, Z+55	; 0x37
    3128:	84 30       	cpi	r24, 0x04	; 4
    312a:	d9 f4       	brne	.+54     	; 0x3162 <uip_process+0x7fe>
    312c:	20 93 84 00 	sts	0x0084, r18
    3130:	30 93 83 00 	sts	0x0083, r19
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0x04) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    3134:	20 ad       	ldd	r18, Z+56	; 0x38
    3136:	33 27       	eor	r19, r19
    3138:	32 2f       	mov	r19, r18
    313a:	22 27       	eor	r18, r18
    313c:	81 ad       	ldd	r24, Z+57	; 0x39
    313e:	99 27       	eor	r25, r25
    3140:	28 2b       	or	r18, r24
    3142:	39 2b       	or	r19, r25
    3144:	30 93 86 00 	sts	0x0086, r19
    3148:	20 93 85 00 	sts	0x0085, r18
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    314c:	82 e0       	ldi	r24, 0x02	; 2
    314e:	21 30       	cpi	r18, 0x01	; 1
    3150:	38 07       	cpc	r19, r24
    3152:	10 f0       	brcs	.+4      	; 0x3158 <uip_process+0x7f4>
    3154:	20 e0       	ldi	r18, 0x00	; 0
    3156:	32 e0       	ldi	r19, 0x02	; 2
    3158:	3b 8b       	std	Y+19, r19	; 0x13
    315a:	2a 8b       	std	Y+18, r18	; 0x12
    315c:	3d 8b       	std	Y+21, r19	; 0x15
    315e:	2c 8b       	std	Y+20, r18	; 0x14
    3160:	1b c0       	rjmp	.+54     	; 0x3198 <uip_process+0x834>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    3162:	a6 59       	subi	r26, 0x96	; 150
    3164:	bc 4f       	sbci	r27, 0xFC	; 252
    3166:	d7 96       	adiw	r26, 0x37	; 55
    3168:	8c 91       	ld	r24, X
    316a:	88 23       	and	r24, r24
    316c:	89 f0       	breq	.+34     	; 0x3190 <uip_process+0x82c>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    316e:	38 0f       	add	r19, r24
    if((uip_flags & UIP_ACKDATA) &&
       BUF->flags == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    3170:	a3 2f       	mov	r26, r19
    3172:	bb 27       	eor	r27, r27
    3174:	80 91 98 03 	lds	r24, 0x0398
    3178:	82 95       	swap	r24
    317a:	8f 70       	andi	r24, 0x0F	; 15
    317c:	99 27       	eor	r25, r25
    317e:	05 97       	sbiw	r24, 0x05	; 5
    3180:	88 0f       	add	r24, r24
    3182:	99 1f       	adc	r25, r25
    3184:	88 0f       	add	r24, r24
    3186:	99 1f       	adc	r25, r25
    3188:	a8 17       	cp	r26, r24
    318a:	b9 07       	cpc	r27, r25
    318c:	0c f4       	brge	.+2      	; 0x3190 <uip_process+0x82c>
    318e:	bc cf       	rjmp	.-136    	; 0x3108 <uip_process+0x7a4>
    3190:	20 93 84 00 	sts	0x0084, r18
    3194:	30 93 83 00 	sts	0x0083, r19
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }      
	}
      }
      uip_connr->tcpstateflags = ESTABLISHED;      
    3198:	83 e0       	ldi	r24, 0x03	; 3
    319a:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    319c:	80 91 90 03 	lds	r24, 0x0390
    31a0:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    31a2:	80 91 91 03 	lds	r24, 0x0391
    31a6:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    31a8:	80 91 92 03 	lds	r24, 0x0392
    31ac:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    31ae:	80 91 93 03 	lds	r24, 0x0393
    31b2:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    31b4:	81 e0       	ldi	r24, 0x01	; 1
    31b6:	90 e0       	ldi	r25, 0x00	; 0
    31b8:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    31bc:	82 e4       	ldi	r24, 0x42	; 66
    31be:	80 93 f2 02 	sts	0x02F2, r24
      uip_connr->len = 0;
    31c2:	19 8a       	std	Y+17, r1	; 0x11
    31c4:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    31c6:	10 92 eb 02 	sts	0x02EB, r1
    31ca:	10 92 ea 02 	sts	0x02EA, r1
    31ce:	85 c0       	rjmp	.+266    	; 0x32da <uip_process+0x976>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN) {
    31d0:	80 91 99 03 	lds	r24, 0x0399
    31d4:	99 27       	eor	r25, r25
    31d6:	80 ff       	sbrs	r24, 0
    31d8:	27 c0       	rjmp	.+78     	; 0x3228 <uip_process+0x8c4>
      if(uip_outstanding(uip_connr)) {
    31da:	88 89       	ldd	r24, Y+16	; 0x10
    31dc:	99 89       	ldd	r25, Y+17	; 0x11
    31de:	89 2b       	or	r24, r25
    31e0:	09 f0       	breq	.+2      	; 0x31e4 <uip_process+0x880>
    31e2:	e4 c1       	rjmp	.+968    	; 0x35ac <uip_process+0xc48>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);      
    31e4:	80 91 ea 02 	lds	r24, 0x02EA
    31e8:	90 91 eb 02 	lds	r25, 0x02EB
    31ec:	01 96       	adiw	r24, 0x01	; 1
    31ee:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    31f2:	80 e1       	ldi	r24, 0x10	; 16
    31f4:	80 93 f2 02 	sts	0x02F2, r24
      if(uip_len > 0) {
    31f8:	80 91 ea 02 	lds	r24, 0x02EA
    31fc:	90 91 eb 02 	lds	r25, 0x02EB
    3200:	89 2b       	or	r24, r25
    3202:	29 f0       	breq	.+10     	; 0x320e <uip_process+0x8aa>
	uip_flags |= UIP_NEWDATA;
    3204:	80 91 f2 02 	lds	r24, 0x02F2
    3208:	82 60       	ori	r24, 0x02	; 2
    320a:	80 93 f2 02 	sts	0x02F2, r24
      }
      UIP_APPCALL();
    320e:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>
      uip_connr->len = 1;
    3212:	81 e0       	ldi	r24, 0x01	; 1
    3214:	90 e0       	ldi	r25, 0x00	; 0
    3216:	99 8b       	std	Y+17, r25	; 0x11
    3218:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = LAST_ACK;
    321a:	88 e0       	ldi	r24, 0x08	; 8
    321c:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    321e:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;      
    3220:	81 e1       	ldi	r24, 0x11	; 17
    3222:	80 93 99 03 	sts	0x0399, r24
    3226:	2b c1       	rjmp	.+598    	; 0x347e <uip_process+0xb1a>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if(BUF->flags & TCP_URG) {
    3228:	85 ff       	sbrs	r24, 5
    322a:	1e c0       	rjmp	.+60     	; 0x3268 <uip_process+0x904>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#endif /* UIP_URGDATA > 0 */
      uip_appdata += (BUF->urgp[0] << 8) | BUF->urgp[1];
    322c:	20 91 9e 03 	lds	r18, 0x039E
    3230:	80 91 9f 03 	lds	r24, 0x039F
    3234:	33 27       	eor	r19, r19
    3236:	32 2f       	mov	r19, r18
    3238:	22 27       	eor	r18, r18
    323a:	99 27       	eor	r25, r25
    323c:	28 2b       	or	r18, r24
    323e:	39 2b       	or	r19, r25
    3240:	80 91 f3 02 	lds	r24, 0x02F3
    3244:	90 91 f4 02 	lds	r25, 0x02F4
    3248:	82 0f       	add	r24, r18
    324a:	93 1f       	adc	r25, r19
    324c:	90 93 f4 02 	sts	0x02F4, r25
    3250:	80 93 f3 02 	sts	0x02F3, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    3254:	80 91 ea 02 	lds	r24, 0x02EA
    3258:	90 91 eb 02 	lds	r25, 0x02EB
    325c:	82 1b       	sub	r24, r18
    325e:	93 0b       	sbc	r25, r19
    3260:	90 93 eb 02 	sts	0x02EB, r25
    3264:	80 93 ea 02 	sts	0x02EA, r24
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    3268:	80 91 ea 02 	lds	r24, 0x02EA
    326c:	90 91 eb 02 	lds	r25, 0x02EB
    3270:	89 2b       	or	r24, r25
    3272:	69 f0       	breq	.+26     	; 0x328e <uip_process+0x92a>
    3274:	44 fd       	sbrc	r20, 4
    3276:	0b c0       	rjmp	.+22     	; 0x328e <uip_process+0x92a>
      uip_flags |= UIP_NEWDATA;
    3278:	80 91 f2 02 	lds	r24, 0x02F2
    327c:	82 60       	ori	r24, 0x02	; 2
    327e:	80 93 f2 02 	sts	0x02F2, r24
      uip_add_rcv_nxt(uip_len);
    3282:	80 91 ea 02 	lds	r24, 0x02EA
    3286:	90 91 eb 02 	lds	r25, 0x02EB
    328a:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    328e:	80 91 9a 03 	lds	r24, 0x039A
    3292:	20 91 9b 03 	lds	r18, 0x039B
    3296:	99 27       	eor	r25, r25
    3298:	98 2f       	mov	r25, r24
    329a:	88 27       	eor	r24, r24
    329c:	82 0f       	add	r24, r18
    329e:	91 1d       	adc	r25, r1
    32a0:	90 93 86 00 	sts	0x0086, r25
    32a4:	80 93 85 00 	sts	0x0085, r24
    if(tmp16 > uip_connr->initialmss ||
    32a8:	2c 89       	ldd	r18, Y+20	; 0x14
    32aa:	3d 89       	ldd	r19, Y+21	; 0x15
    32ac:	28 17       	cp	r18, r24
    32ae:	39 07       	cpc	r19, r25
    32b0:	10 f0       	brcs	.+4      	; 0x32b6 <uip_process+0x952>
    32b2:	89 2b       	or	r24, r25
    32b4:	21 f4       	brne	.+8      	; 0x32be <uip_process+0x95a>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    32b6:	30 93 86 00 	sts	0x0086, r19
    32ba:	20 93 85 00 	sts	0x0085, r18
    }
    uip_connr->mss = tmp16;
    32be:	80 91 85 00 	lds	r24, 0x0085
    32c2:	90 91 86 00 	lds	r25, 0x0086
    32c6:	9b 8b       	std	Y+19, r25	; 0x13
    32c8:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    32ca:	80 91 f2 02 	lds	r24, 0x02F2
    32ce:	99 27       	eor	r25, r25
    32d0:	83 70       	andi	r24, 0x03	; 3
    32d2:	90 70       	andi	r25, 0x00	; 0
    32d4:	89 2b       	or	r24, r25
    32d6:	09 f4       	brne	.+2      	; 0x32da <uip_process+0x976>
    32d8:	69 c1       	rjmp	.+722    	; 0x35ac <uip_process+0xc48>
      uip_slen = 0;
    32da:	10 92 a3 05 	sts	0x05A3, r1
    32de:	10 92 a2 05 	sts	0x05A2, r1
      UIP_APPCALL();
    32e2:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    32e6:	80 91 f2 02 	lds	r24, 0x02F2
    32ea:	85 ff       	sbrs	r24, 5
    32ec:	07 c0       	rjmp	.+14     	; 0x32fc <uip_process+0x998>
	uip_slen = 0;
    32ee:	10 92 a3 05 	sts	0x05A3, r1
    32f2:	10 92 a2 05 	sts	0x05A2, r1
	uip_connr->tcpstateflags = CLOSED;
    32f6:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    32f8:	84 e1       	ldi	r24, 0x14	; 20
    32fa:	93 cf       	rjmp	.-218    	; 0x3222 <uip_process+0x8be>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    32fc:	80 91 f2 02 	lds	r24, 0x02F2
    3300:	84 ff       	sbrs	r24, 4
    3302:	0a c0       	rjmp	.+20     	; 0x3318 <uip_process+0x9b4>
	uip_slen = 0;
    3304:	10 92 a3 05 	sts	0x05A3, r1
    3308:	10 92 a2 05 	sts	0x05A2, r1
	uip_connr->len = 1;
    330c:	81 e0       	ldi	r24, 0x01	; 1
    330e:	90 e0       	ldi	r25, 0x00	; 0
    3310:	99 8b       	std	Y+17, r25	; 0x11
    3312:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = FIN_WAIT_1;
    3314:	84 e0       	ldi	r24, 0x04	; 4
    3316:	82 cf       	rjmp	.-252    	; 0x321c <uip_process+0x8b8>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;	
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    3318:	80 91 a2 05 	lds	r24, 0x05A2
    331c:	90 91 a3 05 	lds	r25, 0x05A3
    3320:	89 2b       	or	r24, r25
    3322:	19 f1       	breq	.+70     	; 0x336a <uip_process+0xa06>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */ 
	if((uip_flags & UIP_ACKDATA) != 0) {
    3324:	80 91 f2 02 	lds	r24, 0x02F2
    3328:	80 ff       	sbrs	r24, 0
    332a:	02 c0       	rjmp	.+4      	; 0x3330 <uip_process+0x9cc>
	  uip_connr->len = 0;
    332c:	19 8a       	std	Y+17, r1	; 0x11
    332e:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    3330:	88 89       	ldd	r24, Y+16	; 0x10
    3332:	99 89       	ldd	r25, Y+17	; 0x11
    3334:	00 97       	sbiw	r24, 0x00	; 0
    3336:	a1 f4       	brne	.+40     	; 0x3360 <uip_process+0x9fc>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    3338:	80 91 a2 05 	lds	r24, 0x05A2
    333c:	90 91 a3 05 	lds	r25, 0x05A3
    3340:	2a 89       	ldd	r18, Y+18	; 0x12
    3342:	3b 89       	ldd	r19, Y+19	; 0x13
    3344:	28 17       	cp	r18, r24
    3346:	39 07       	cpc	r19, r25
    3348:	20 f4       	brcc	.+8      	; 0x3352 <uip_process+0x9ee>
	    uip_slen = uip_connr->mss;
    334a:	30 93 a3 05 	sts	0x05A3, r19
    334e:	20 93 a2 05 	sts	0x05A2, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    3352:	80 91 a2 05 	lds	r24, 0x05A2
    3356:	90 91 a3 05 	lds	r25, 0x05A3
    335a:	99 8b       	std	Y+17, r25	; 0x11
    335c:	88 8b       	std	Y+16, r24	; 0x10
    335e:	07 c0       	rjmp	.+14     	; 0x336e <uip_process+0xa0a>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    3360:	90 93 a3 05 	sts	0x05A3, r25
    3364:	80 93 a2 05 	sts	0x05A2, r24
    3368:	02 c0       	rjmp	.+4      	; 0x336e <uip_process+0xa0a>
	}
      } else {
	uip_connr->len = 0;
    336a:	19 8a       	std	Y+17, r1	; 0x11
    336c:	18 8a       	std	Y+16, r1	; 0x10
      }
      uip_connr->nrtx = 0;
    336e:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    3370:	80 91 ec 02 	lds	r24, 0x02EC
    3374:	90 91 ed 02 	lds	r25, 0x02ED
    3378:	90 93 f4 02 	sts	0x02F4, r25
    337c:	80 93 f3 02 	sts	0x02F3, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    3380:	80 91 a2 05 	lds	r24, 0x05A2
    3384:	90 91 a3 05 	lds	r25, 0x05A3
    3388:	89 2b       	or	r24, r25
    338a:	59 f0       	breq	.+22     	; 0x33a2 <uip_process+0xa3e>
    338c:	88 89       	ldd	r24, Y+16	; 0x10
    338e:	99 89       	ldd	r25, Y+17	; 0x11
    3390:	00 97       	sbiw	r24, 0x00	; 0
    3392:	39 f0       	breq	.+14     	; 0x33a2 <uip_process+0xa3e>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    3394:	88 96       	adiw	r24, 0x28	; 40
    3396:	90 93 eb 02 	sts	0x02EB, r25
    339a:	80 93 ea 02 	sts	0x02EA, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    339e:	88 e1       	ldi	r24, 0x18	; 24
    33a0:	0b c0       	rjmp	.+22     	; 0x33b8 <uip_process+0xa54>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    33a2:	80 91 f2 02 	lds	r24, 0x02F2
    33a6:	81 ff       	sbrs	r24, 1
    33a8:	01 c1       	rjmp	.+514    	; 0x35ac <uip_process+0xc48>
	uip_len = UIP_TCPIP_HLEN;
    33aa:	88 e2       	ldi	r24, 0x28	; 40
    33ac:	90 e0       	ldi	r25, 0x00	; 0
    33ae:	90 93 eb 02 	sts	0x02EB, r25
    33b2:	80 93 ea 02 	sts	0x02EA, r24
	BUF->flags = TCP_ACK;
    33b6:	80 e1       	ldi	r24, 0x10	; 16
    33b8:	80 93 99 03 	sts	0x0399, r24
    33bc:	66 c0       	rjmp	.+204    	; 0x348a <uip_process+0xb26>
    }
    goto drop;
  case LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */     
    if(uip_flags & UIP_ACKDATA) {
    33be:	80 91 f2 02 	lds	r24, 0x02F2
    33c2:	80 ff       	sbrs	r24, 0
    33c4:	f3 c0       	rjmp	.+486    	; 0x35ac <uip_process+0xc48>
      uip_connr->tcpstateflags = CLOSED;
    33c6:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    33c8:	80 e1       	ldi	r24, 0x10	; 16
    33ca:	80 93 f2 02 	sts	0x02F2, r24
      UIP_APPCALL();
    33ce:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>
    33d2:	ec c0       	rjmp	.+472    	; 0x35ac <uip_process+0xc48>
    
  case FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    33d4:	80 91 ea 02 	lds	r24, 0x02EA
    33d8:	90 91 eb 02 	lds	r25, 0x02EB
    33dc:	89 2b       	or	r24, r25
    33de:	31 f0       	breq	.+12     	; 0x33ec <uip_process+0xa88>
      uip_add_rcv_nxt(uip_len);
    33e0:	80 91 ea 02 	lds	r24, 0x02EA
    33e4:	90 91 eb 02 	lds	r25, 0x02EB
    33e8:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    33ec:	80 91 99 03 	lds	r24, 0x0399
    33f0:	80 ff       	sbrs	r24, 0
    33f2:	0d c0       	rjmp	.+26     	; 0x340e <uip_process+0xaaa>
      if(uip_flags & UIP_ACKDATA) {
    33f4:	80 91 f2 02 	lds	r24, 0x02F2
    33f8:	80 ff       	sbrs	r24, 0
    33fa:	06 c0       	rjmp	.+12     	; 0x3408 <uip_process+0xaa4>
	uip_connr->tcpstateflags = TIME_WAIT;
    33fc:	87 e0       	ldi	r24, 0x07	; 7
    33fe:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    3400:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    3402:	19 8a       	std	Y+17, r1	; 0x11
    3404:	18 8a       	std	Y+16, r1	; 0x10
    3406:	1f c0       	rjmp	.+62     	; 0x3446 <uip_process+0xae2>
      } else {
	uip_connr->tcpstateflags = CLOSING;
    3408:	86 e0       	ldi	r24, 0x06	; 6
    340a:	89 8f       	std	Y+25, r24	; 0x19
    340c:	1c c0       	rjmp	.+56     	; 0x3446 <uip_process+0xae2>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    340e:	80 91 f2 02 	lds	r24, 0x02F2
    3412:	80 ff       	sbrs	r24, 0
    3414:	22 c0       	rjmp	.+68     	; 0x345a <uip_process+0xaf6>
      uip_connr->tcpstateflags = FIN_WAIT_2;
    3416:	85 e0       	ldi	r24, 0x05	; 5
    3418:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    341a:	19 8a       	std	Y+17, r1	; 0x11
    341c:	18 8a       	std	Y+16, r1	; 0x10
    341e:	c6 c0       	rjmp	.+396    	; 0x35ac <uip_process+0xc48>
      goto tcp_send_ack;
    }
    goto drop;
      
  case FIN_WAIT_2:
    if(uip_len > 0) {
    3420:	80 91 ea 02 	lds	r24, 0x02EA
    3424:	90 91 eb 02 	lds	r25, 0x02EB
    3428:	89 2b       	or	r24, r25
    342a:	31 f0       	breq	.+12     	; 0x3438 <uip_process+0xad4>
      uip_add_rcv_nxt(uip_len);
    342c:	80 91 ea 02 	lds	r24, 0x02EA
    3430:	90 91 eb 02 	lds	r25, 0x02EB
    3434:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    3438:	80 91 99 03 	lds	r24, 0x0399
    343c:	80 ff       	sbrs	r24, 0
    343e:	0d c0       	rjmp	.+26     	; 0x345a <uip_process+0xaf6>
      uip_connr->tcpstateflags = TIME_WAIT;
    3440:	87 e0       	ldi	r24, 0x07	; 7
    3442:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3444:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    3446:	81 e0       	ldi	r24, 0x01	; 1
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	0e 94 8d 14 	call	0x291a	; 0x291a <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    344e:	80 e1       	ldi	r24, 0x10	; 16
    3450:	80 93 f2 02 	sts	0x02F2, r24
      UIP_APPCALL();
    3454:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <services_main>
    3458:	0f c0       	rjmp	.+30     	; 0x3478 <uip_process+0xb14>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    345a:	80 91 ea 02 	lds	r24, 0x02EA
    345e:	90 91 eb 02 	lds	r25, 0x02EB
    3462:	89 2b       	or	r24, r25
    3464:	49 f4       	brne	.+18     	; 0x3478 <uip_process+0xb14>
    3466:	a2 c0       	rjmp	.+324    	; 0x35ac <uip_process+0xc48>

  case TIME_WAIT:
    goto tcp_send_ack;
    
  case CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    3468:	80 91 f2 02 	lds	r24, 0x02F2
    346c:	80 ff       	sbrs	r24, 0
    346e:	9e c0       	rjmp	.+316    	; 0x35ac <uip_process+0xc48>
      uip_connr->tcpstateflags = TIME_WAIT;
    3470:	87 e0       	ldi	r24, 0x07	; 7
    3472:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3474:	1a 8e       	std	Y+26, r1	; 0x1a
    3476:	9a c0       	rjmp	.+308    	; 0x35ac <uip_process+0xc48>
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    3478:	80 e1       	ldi	r24, 0x10	; 16
    347a:	f8 01       	movw	r30, r16
    347c:	81 a3       	std	Z+33, r24	; 0x21
 tcp_send_nodata:
  uip_len = 40;
    347e:	88 e2       	ldi	r24, 0x28	; 40
    3480:	90 e0       	ldi	r25, 0x00	; 0
    3482:	90 93 eb 02 	sts	0x02EB, r25
    3486:	80 93 ea 02 	sts	0x02EA, r24
 tcp_send_noopts:
  BUF->tcpoffset = 5 << 4;
    348a:	80 e5       	ldi	r24, 0x50	; 80
    348c:	80 93 98 03 	sts	0x0398, r24
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    3490:	88 85       	ldd	r24, Y+8	; 0x08
    3492:	80 93 94 03 	sts	0x0394, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    3496:	89 85       	ldd	r24, Y+9	; 0x09
    3498:	80 93 95 03 	sts	0x0395, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    349c:	8a 85       	ldd	r24, Y+10	; 0x0a
    349e:	80 93 96 03 	sts	0x0396, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    34a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    34a4:	80 93 97 03 	sts	0x0397, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    34a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    34aa:	80 93 90 03 	sts	0x0390, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    34ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    34b0:	80 93 91 03 	sts	0x0391, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    34b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    34b6:	80 93 92 03 	sts	0x0392, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    34ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    34bc:	80 93 93 03 	sts	0x0393, r24

  BUF->proto = UIP_PROTO_TCP;
    34c0:	86 e0       	ldi	r24, 0x06	; 6
    34c2:	80 93 81 03 	sts	0x0381, r24
  
  BUF->srcport  = uip_connr->lport;
    34c6:	8c 81       	ldd	r24, Y+4	; 0x04
    34c8:	9d 81       	ldd	r25, Y+5	; 0x05
    34ca:	90 93 8d 03 	sts	0x038D, r25
    34ce:	80 93 8c 03 	sts	0x038C, r24
  BUF->destport = uip_connr->rport;
    34d2:	8e 81       	ldd	r24, Y+6	; 0x06
    34d4:	9f 81       	ldd	r25, Y+7	; 0x07
    34d6:	90 93 8f 03 	sts	0x038F, r25
    34da:	80 93 8e 03 	sts	0x038E, r24

  BUF->srcipaddr[0] = uip_hostaddr[0];
    34de:	8e e0       	ldi	r24, 0x0E	; 14
    34e0:	97 e2       	ldi	r25, 0x27	; 39
    34e2:	90 93 85 03 	sts	0x0385, r25
    34e6:	80 93 84 03 	sts	0x0384, r24
  BUF->srcipaddr[1] = uip_hostaddr[1];
    34ea:	8f e7       	ldi	r24, 0x7F	; 127
    34ec:	90 e2       	ldi	r25, 0x20	; 32
    34ee:	90 93 87 03 	sts	0x0387, r25
    34f2:	80 93 86 03 	sts	0x0386, r24
  BUF->destipaddr[0] = uip_connr->ripaddr[0];
    34f6:	88 81       	ld	r24, Y
    34f8:	99 81       	ldd	r25, Y+1	; 0x01
    34fa:	90 93 89 03 	sts	0x0389, r25
    34fe:	80 93 88 03 	sts	0x0388, r24
  BUF->destipaddr[1] = uip_connr->ripaddr[1];
    3502:	8a 81       	ldd	r24, Y+2	; 0x02
    3504:	9b 81       	ldd	r25, Y+3	; 0x03
    3506:	90 93 8b 03 	sts	0x038B, r25
    350a:	80 93 8a 03 	sts	0x038A, r24
 

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    350e:	89 8d       	ldd	r24, Y+25	; 0x19
    3510:	84 ff       	sbrs	r24, 4
    3512:	05 c0       	rjmp	.+10     	; 0x351e <uip_process+0xbba>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    3514:	10 92 9b 03 	sts	0x039B, r1
    3518:	10 92 9a 03 	sts	0x039A, r1
    351c:	05 c0       	rjmp	.+10     	; 0x3528 <uip_process+0xbc4>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    351e:	80 e8       	ldi	r24, 0x80	; 128
    3520:	80 93 9a 03 	sts	0x039A, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff); 
    3524:	10 92 9b 03 	sts	0x039B, r1
  }

 tcp_send_noconn:

  BUF->len[0] = (uip_len >> 8);
    3528:	80 91 ea 02 	lds	r24, 0x02EA
    352c:	90 91 eb 02 	lds	r25, 0x02EB
    3530:	89 2f       	mov	r24, r25
    3532:	99 27       	eor	r25, r25
    3534:	80 93 7a 03 	sts	0x037A, r24
  BUF->len[1] = (uip_len & 0xff);
    3538:	80 91 ea 02 	lds	r24, 0x02EA
    353c:	90 91 eb 02 	lds	r25, 0x02EB
    3540:	80 93 7b 03 	sts	0x037B, r24

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3544:	10 92 9d 03 	sts	0x039D, r1
    3548:	10 92 9c 03 	sts	0x039C, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    354c:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <uip_tcpchksum>
    3550:	80 95       	com	r24
    3552:	90 95       	com	r25
    3554:	90 93 9d 03 	sts	0x039D, r25
    3558:	80 93 9c 03 	sts	0x039C, r24
  
 ip_send_nolen:

  BUF->vhl = 0x45;
    355c:	85 e4       	ldi	r24, 0x45	; 69
    355e:	80 93 78 03 	sts	0x0378, r24
  BUF->tos = 0;
    3562:	10 92 79 03 	sts	0x0379, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    3566:	10 92 7f 03 	sts	0x037F, r1
    356a:	10 92 7e 03 	sts	0x037E, r1
  BUF->ttl  = UIP_TTL;
    356e:	8f ef       	ldi	r24, 0xFF	; 255
    3570:	80 93 80 03 	sts	0x0380, r24
  ++ipid;
    3574:	80 91 7b 00 	lds	r24, 0x007B
    3578:	90 91 7c 00 	lds	r25, 0x007C
    357c:	01 96       	adiw	r24, 0x01	; 1
    357e:	90 93 7c 00 	sts	0x007C, r25
    3582:	80 93 7b 00 	sts	0x007B, r24
  BUF->ipid[0] = ipid >> 8;
    3586:	29 2f       	mov	r18, r25
    3588:	33 27       	eor	r19, r19
    358a:	20 93 7c 03 	sts	0x037C, r18
  BUF->ipid[1] = ipid & 0xff;
    358e:	80 93 7d 03 	sts	0x037D, r24
  
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    3592:	10 92 83 03 	sts	0x0383, r1
    3596:	10 92 82 03 	sts	0x0382, r1
  BUF->ipchksum = ~(uip_ipchksum());
    359a:	0e 94 a7 1d 	call	0x3b4e	; 0x3b4e <uip_ipchksum>
    359e:	80 95       	com	r24
    35a0:	90 95       	com	r25
    35a2:	90 93 83 03 	sts	0x0383, r25
    35a6:	80 93 82 03 	sts	0x0382, r24
    35aa:	04 c0       	rjmp	.+8      	; 0x35b4 <uip_process+0xc50>
 send:
  UIP_STAT(++uip_stat.ip.sent);
  /* Return and let the caller do the actual transmission. */
  return;
 drop:
  uip_len = 0;
    35ac:	10 92 eb 02 	sts	0x02EB, r1
    35b0:	10 92 ea 02 	sts	0x02EA, r1
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	1f 91       	pop	r17
    35ba:	0f 91       	pop	r16
    35bc:	08 95       	ret

000035be <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
    35be:	80 91 e5 00 	lds	r24, 0x00E5
    35c2:	8f 5f       	subi	r24, 0xFF	; 255
    35c4:	80 93 e5 00 	sts	0x00E5, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    35c8:	10 92 e3 00 	sts	0x00E3, r1
    35cc:	20 c0       	rjmp	.+64     	; 0x360e <uip_arp_timer+0x50>
    tabptr = &arp_table[i];
    35ce:	8b e0       	ldi	r24, 0x0B	; 11
    35d0:	28 9f       	mul	r18, r24
    35d2:	f0 01       	movw	r30, r0
    35d4:	11 24       	eor	r1, r1
    35d6:	e9 57       	subi	r30, 0x79	; 121
    35d8:	ff 4f       	sbci	r31, 0xFF	; 255
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
    35da:	82 81       	ldd	r24, Z+2	; 0x02
    35dc:	93 81       	ldd	r25, Z+3	; 0x03
    35de:	20 81       	ld	r18, Z
    35e0:	31 81       	ldd	r19, Z+1	; 0x01
    35e2:	82 2b       	or	r24, r18
    35e4:	93 2b       	or	r25, r19
    35e6:	89 2b       	or	r24, r25
    35e8:	69 f0       	breq	.+26     	; 0x3604 <uip_arp_timer+0x46>
    35ea:	80 91 e5 00 	lds	r24, 0x00E5
    35ee:	99 27       	eor	r25, r25
    35f0:	22 85       	ldd	r18, Z+10	; 0x0a
    35f2:	82 1b       	sub	r24, r18
    35f4:	91 09       	sbc	r25, r1
    35f6:	88 37       	cpi	r24, 0x78	; 120
    35f8:	91 05       	cpc	r25, r1
    35fa:	24 f0       	brlt	.+8      	; 0x3604 <uip_arp_timer+0x46>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    35fc:	10 82       	st	Z, r1
    35fe:	11 82       	std	Z+1, r1	; 0x01
    3600:	12 82       	std	Z+2, r1	; 0x02
    3602:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3604:	80 91 e3 00 	lds	r24, 0x00E3
    3608:	8f 5f       	subi	r24, 0xFF	; 255
    360a:	80 93 e3 00 	sts	0x00E3, r24
    360e:	20 91 e3 00 	lds	r18, 0x00E3
    3612:	28 30       	cpi	r18, 0x08	; 8
    3614:	e0 f2       	brcs	.-72     	; 0x35ce <uip_arp_timer+0x10>
    3616:	08 95       	ret

00003618 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3618:	10 92 e3 00 	sts	0x00E3, r1
    361c:	0d c0       	rjmp	.+26     	; 0x3638 <uip_arp_init+0x20>
    memset(arp_table[i].ipaddr, 0, 4);
    361e:	eb e0       	ldi	r30, 0x0B	; 11
    3620:	8e 9f       	mul	r24, r30
    3622:	f0 01       	movw	r30, r0
    3624:	11 24       	eor	r1, r1
    3626:	e9 57       	subi	r30, 0x79	; 121
    3628:	ff 4f       	sbci	r31, 0xFF	; 255
    362a:	10 82       	st	Z, r1
    362c:	11 82       	std	Z+1, r1	; 0x01
    362e:	12 82       	std	Z+2, r1	; 0x02
    3630:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3632:	8f 5f       	subi	r24, 0xFF	; 255
    3634:	80 93 e3 00 	sts	0x00E3, r24
    3638:	80 91 e3 00 	lds	r24, 0x00E3
    363c:	88 30       	cpi	r24, 0x08	; 8
    363e:	78 f3       	brcs	.-34     	; 0x361e <uip_arp_init+0x6>
    3640:	08 95       	ret

00003642 <uip_arp_out>:
 * uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
    3642:	cf 93       	push	r28
    3644:	df 93       	push	r29

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* Check if the destination address is on the local network. */
  if((IPBUF->destipaddr[0] & uip_arp_netmask[0]) !=
    3646:	e0 91 88 03 	lds	r30, 0x0388
    364a:	f0 91 89 03 	lds	r31, 0x0389
    364e:	80 91 69 00 	lds	r24, 0x0069
    3652:	90 91 6a 00 	lds	r25, 0x006A
    3656:	c0 91 61 00 	lds	r28, 0x0061
    365a:	d0 91 62 00 	lds	r29, 0x0062
    365e:	9c 01       	movw	r18, r24
    3660:	2e 23       	and	r18, r30
    3662:	3f 23       	and	r19, r31
    3664:	8c 23       	and	r24, r28
    3666:	9d 23       	and	r25, r29
    3668:	28 17       	cp	r18, r24
    366a:	39 07       	cpc	r19, r25
    366c:	a1 f4       	brne	.+40     	; 0x3696 <uip_arp_out+0x54>
    366e:	60 91 8a 03 	lds	r22, 0x038A
    3672:	70 91 8b 03 	lds	r23, 0x038B
    3676:	80 91 6b 00 	lds	r24, 0x006B
    367a:	90 91 6c 00 	lds	r25, 0x006C
    367e:	ac 01       	movw	r20, r24
    3680:	46 23       	and	r20, r22
    3682:	57 23       	and	r21, r23
    3684:	20 91 63 00 	lds	r18, 0x0063
    3688:	30 91 64 00 	lds	r19, 0x0064
    368c:	82 23       	and	r24, r18
    368e:	93 23       	and	r25, r19
    3690:	48 17       	cp	r20, r24
    3692:	59 07       	cpc	r21, r25
    3694:	89 f0       	breq	.+34     	; 0x36b8 <uip_arp_out+0x76>
     (IPBUF->destipaddr[1] & uip_arp_netmask[1]) !=
     (uip_hostaddr[1] & uip_arp_netmask[1])) {
    /* Destination address was not on the local network, so we need to
       use the default router's IP address instead of the destination
       address when determining the MAC address. */
    ipaddr[0] = uip_arp_draddr[0];
    3696:	80 91 65 00 	lds	r24, 0x0065
    369a:	90 91 66 00 	lds	r25, 0x0066
    369e:	90 93 e0 00 	sts	0x00E0, r25
    36a2:	80 93 df 00 	sts	0x00DF, r24
    ipaddr[1] = uip_arp_draddr[1];
    36a6:	80 91 67 00 	lds	r24, 0x0067
    36aa:	90 91 68 00 	lds	r25, 0x0068
    36ae:	90 93 e2 00 	sts	0x00E2, r25
    36b2:	80 93 e1 00 	sts	0x00E1, r24
    36b6:	08 c0       	rjmp	.+16     	; 0x36c8 <uip_arp_out+0x86>
  } else {
    /* Else, we use the destination IP address. */
    ipaddr[0] = IPBUF->destipaddr[0];
    36b8:	f0 93 e0 00 	sts	0x00E0, r31
    36bc:	e0 93 df 00 	sts	0x00DF, r30
    ipaddr[1] = IPBUF->destipaddr[1];
    36c0:	70 93 e2 00 	sts	0x00E2, r23
    36c4:	60 93 e1 00 	sts	0x00E1, r22
  }
      
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36c8:	10 92 e3 00 	sts	0x00E3, r1
    tabptr = &arp_table[i];
    if(ipaddr[0] == tabptr->ipaddr[0] &&
    36cc:	60 91 df 00 	lds	r22, 0x00DF
    36d0:	70 91 e0 00 	lds	r23, 0x00E0
    36d4:	40 91 e1 00 	lds	r20, 0x00E1
    36d8:	50 91 e2 00 	lds	r21, 0x00E2
    36dc:	20 e0       	ldi	r18, 0x00	; 0
    36de:	14 c0       	rjmp	.+40     	; 0x3708 <uip_arp_out+0xc6>
    ipaddr[0] = IPBUF->destipaddr[0];
    ipaddr[1] = IPBUF->destipaddr[1];
  }
      
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    36e0:	8b e0       	ldi	r24, 0x0B	; 11
    36e2:	28 9f       	mul	r18, r24
    36e4:	f0 01       	movw	r30, r0
    36e6:	11 24       	eor	r1, r1
    36e8:	e9 57       	subi	r30, 0x79	; 121
    36ea:	ff 4f       	sbci	r31, 0xFF	; 255
    if(ipaddr[0] == tabptr->ipaddr[0] &&
    36ec:	80 81       	ld	r24, Z
    36ee:	91 81       	ldd	r25, Z+1	; 0x01
    36f0:	68 17       	cp	r22, r24
    36f2:	79 07       	cpc	r23, r25
    36f4:	41 f4       	brne	.+16     	; 0x3706 <uip_arp_out+0xc4>
    36f6:	82 81       	ldd	r24, Z+2	; 0x02
    36f8:	93 81       	ldd	r25, Z+3	; 0x03
    36fa:	48 17       	cp	r20, r24
    36fc:	59 07       	cpc	r21, r25
    36fe:	19 f4       	brne	.+6      	; 0x3706 <uip_arp_out+0xc4>
    3700:	20 93 e3 00 	sts	0x00E3, r18
    3704:	69 c0       	rjmp	.+210    	; 0x37d8 <uip_arp_out+0x196>
    3706:	2f 5f       	subi	r18, 0xFF	; 255
    /* Else, we use the destination IP address. */
    ipaddr[0] = IPBUF->destipaddr[0];
    ipaddr[1] = IPBUF->destipaddr[1];
  }
      
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3708:	28 30       	cpi	r18, 0x08	; 8
    370a:	50 f3       	brcs	.-44     	; 0x36e0 <uip_arp_out+0x9e>
    370c:	20 93 e3 00 	sts	0x00E3, r18
    if(ipaddr[0] == tabptr->ipaddr[0] &&
       ipaddr[1] == tabptr->ipaddr[1])
      break;
  }

  if(i == UIP_ARPTAB_SIZE) {
    3710:	28 30       	cpi	r18, 0x08	; 8
    3712:	09 f0       	breq	.+2      	; 0x3716 <uip_arp_out+0xd4>
    3714:	61 c0       	rjmp	.+194    	; 0x37d8 <uip_arp_out+0x196>
    /* The destination address was not in our ARP table, so we
       overwrite the IP packet with an ARP request. */

    memset(BUF->ethhdr.dest.addr, 0xff, 6);
    3716:	46 e0       	ldi	r20, 0x06	; 6
    3718:	50 e0       	ldi	r21, 0x00	; 0
    371a:	6f ef       	ldi	r22, 0xFF	; 255
    371c:	70 e0       	ldi	r23, 0x00	; 0
    371e:	8a e6       	ldi	r24, 0x6A	; 106
    3720:	93 e0       	ldi	r25, 0x03	; 3
    3722:	0e 94 72 1e 	call	0x3ce4	; 0x3ce4 <memset>
    memset(BUF->dhwaddr.addr, 0x00, 6);
    3726:	ea e8       	ldi	r30, 0x8A	; 138
    3728:	f3 e0       	ldi	r31, 0x03	; 3
    372a:	86 e0       	ldi	r24, 0x06	; 6
    372c:	df 01       	movw	r26, r30
    372e:	1d 92       	st	X+, r1
    3730:	8a 95       	dec	r24
    3732:	e9 f7       	brne	.-6      	; 0x372e <uip_arp_out+0xec>
    memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3734:	7a 97       	sbiw	r30, 0x1a	; 26
    3736:	ad e6       	ldi	r26, 0x6D	; 109
    3738:	b0 e0       	ldi	r27, 0x00	; 0
    373a:	86 e0       	ldi	r24, 0x06	; 6
    373c:	0d 90       	ld	r0, X+
    373e:	01 92       	st	Z+, r0
    3740:	81 50       	subi	r24, 0x01	; 1
    3742:	e1 f7       	brne	.-8      	; 0x373c <uip_arp_out+0xfa>
    memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    3744:	a0 e8       	ldi	r26, 0x80	; 128
    3746:	b3 e0       	ldi	r27, 0x03	; 3
    3748:	ed e6       	ldi	r30, 0x6D	; 109
    374a:	f0 e0       	ldi	r31, 0x00	; 0
    374c:	86 e0       	ldi	r24, 0x06	; 6
    374e:	01 90       	ld	r0, Z+
    3750:	0d 92       	st	X+, r0
    3752:	81 50       	subi	r24, 0x01	; 1
    3754:	e1 f7       	brne	.-8      	; 0x374e <uip_arp_out+0x10c>
    
    BUF->dipaddr[0] = ipaddr[0];
    3756:	80 91 df 00 	lds	r24, 0x00DF
    375a:	90 91 e0 00 	lds	r25, 0x00E0
    375e:	90 93 91 03 	sts	0x0391, r25
    3762:	80 93 90 03 	sts	0x0390, r24
    BUF->dipaddr[1] = ipaddr[1];
    3766:	80 91 e1 00 	lds	r24, 0x00E1
    376a:	90 91 e2 00 	lds	r25, 0x00E2
    376e:	90 93 93 03 	sts	0x0393, r25
    3772:	80 93 92 03 	sts	0x0392, r24
    BUF->sipaddr[0] = uip_hostaddr[0];
    3776:	d0 93 87 03 	sts	0x0387, r29
    377a:	c0 93 86 03 	sts	0x0386, r28
    BUF->sipaddr[1] = uip_hostaddr[1];
    377e:	80 91 63 00 	lds	r24, 0x0063
    3782:	90 91 64 00 	lds	r25, 0x0064
    3786:	90 93 89 03 	sts	0x0389, r25
    378a:	80 93 88 03 	sts	0x0388, r24
    BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    378e:	80 e0       	ldi	r24, 0x00	; 0
    3790:	91 e0       	ldi	r25, 0x01	; 1
    3792:	90 93 7f 03 	sts	0x037F, r25
    3796:	80 93 7e 03 	sts	0x037E, r24
    BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    379a:	90 93 79 03 	sts	0x0379, r25
    379e:	80 93 78 03 	sts	0x0378, r24
    BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    37a2:	88 e0       	ldi	r24, 0x08	; 8
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	90 93 7b 03 	sts	0x037B, r25
    37aa:	80 93 7a 03 	sts	0x037A, r24
    BUF->hwlen = 6;
    37ae:	86 e0       	ldi	r24, 0x06	; 6
    37b0:	80 93 7c 03 	sts	0x037C, r24
    BUF->protolen = 4;
    37b4:	84 e0       	ldi	r24, 0x04	; 4
    37b6:	80 93 7d 03 	sts	0x037D, r24
    BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    37ba:	88 e0       	ldi	r24, 0x08	; 8
    37bc:	96 e0       	ldi	r25, 0x06	; 6
    37be:	90 93 77 03 	sts	0x0377, r25
    37c2:	80 93 76 03 	sts	0x0376, r24

    uip_appdata = &uip_buf[40 + UIP_LLH_LEN];
    37c6:	80 ea       	ldi	r24, 0xA0	; 160
    37c8:	93 e0       	ldi	r25, 0x03	; 3
    37ca:	90 93 f4 02 	sts	0x02F4, r25
    37ce:	80 93 f3 02 	sts	0x02F3, r24
    
    uip_len = sizeof(struct arp_hdr);
    37d2:	8a e2       	ldi	r24, 0x2A	; 42
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	1c c0       	rjmp	.+56     	; 0x3810 <uip_arp_out+0x1ce>
    return;
  }

  /* Build an ethernet header. */
  memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    37d8:	aa e6       	ldi	r26, 0x6A	; 106
    37da:	b3 e0       	ldi	r27, 0x03	; 3
    37dc:	34 96       	adiw	r30, 0x04	; 4
    37de:	86 e0       	ldi	r24, 0x06	; 6
    37e0:	01 90       	ld	r0, Z+
    37e2:	0d 92       	st	X+, r0
    37e4:	81 50       	subi	r24, 0x01	; 1
    37e6:	e1 f7       	brne	.-8      	; 0x37e0 <uip_arp_out+0x19e>
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    37e8:	a0 e7       	ldi	r26, 0x70	; 112
    37ea:	b3 e0       	ldi	r27, 0x03	; 3
    37ec:	ed e6       	ldi	r30, 0x6D	; 109
    37ee:	f0 e0       	ldi	r31, 0x00	; 0
    37f0:	86 e0       	ldi	r24, 0x06	; 6
    37f2:	01 90       	ld	r0, Z+
    37f4:	0d 92       	st	X+, r0
    37f6:	81 50       	subi	r24, 0x01	; 1
    37f8:	e1 f7       	brne	.-8      	; 0x37f2 <uip_arp_out+0x1b0>
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    37fa:	88 e0       	ldi	r24, 0x08	; 8
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	ea e6       	ldi	r30, 0x6A	; 106
    3800:	f3 e0       	ldi	r31, 0x03	; 3
    3802:	95 87       	std	Z+13, r25	; 0x0d
    3804:	84 87       	std	Z+12, r24	; 0x0c

  uip_len += sizeof(struct uip_eth_hdr);
    3806:	80 91 ea 02 	lds	r24, 0x02EA
    380a:	90 91 eb 02 	lds	r25, 0x02EB
    380e:	0e 96       	adiw	r24, 0x0e	; 14
    3810:	90 93 eb 02 	sts	0x02EB, r25
    3814:	80 93 ea 02 	sts	0x02EA, r24
    3818:	df 91       	pop	r29
    381a:	cf 91       	pop	r28
    381c:	08 95       	ret

0000381e <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    381e:	ef 92       	push	r14
    3820:	ff 92       	push	r15
    3822:	1f 93       	push	r17
    3824:	cf 93       	push	r28
    3826:	df 93       	push	r29
    3828:	dc 01       	movw	r26, r24
    382a:	7b 01       	movw	r14, r22
  register struct arp_entry *tabptr;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    382c:	10 92 e3 00 	sts	0x00E3, r1
    3830:	e0 e0       	ldi	r30, 0x00	; 0
    3832:	29 c0       	rjmp	.+82     	; 0x3886 <uip_arp_update+0x68>

    tabptr = &arp_table[i];
    3834:	8b e0       	ldi	r24, 0x0B	; 11
    3836:	e8 9f       	mul	r30, r24
    3838:	e0 01       	movw	r28, r0
    383a:	11 24       	eor	r1, r1
    383c:	c9 57       	subi	r28, 0x79	; 121
    383e:	df 4f       	sbci	r29, 0xFF	; 255
    /* Only check those entries that are actually in use. */
    if(tabptr->ipaddr[0] != 0 &&
    3840:	48 81       	ld	r20, Y
    3842:	59 81       	ldd	r21, Y+1	; 0x01
    3844:	41 15       	cp	r20, r1
    3846:	51 05       	cpc	r21, r1
    3848:	e9 f0       	breq	.+58     	; 0x3884 <uip_arp_update+0x66>
    384a:	2a 81       	ldd	r18, Y+2	; 0x02
    384c:	3b 81       	ldd	r19, Y+3	; 0x03
    384e:	21 15       	cp	r18, r1
    3850:	31 05       	cpc	r19, r1
    3852:	c1 f0       	breq	.+48     	; 0x3884 <uip_arp_update+0x66>
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
    3854:	8d 91       	ld	r24, X+
    3856:	9c 91       	ld	r25, X
    3858:	11 97       	sbiw	r26, 0x01	; 1
    385a:	84 17       	cp	r24, r20
    385c:	95 07       	cpc	r25, r21
    385e:	91 f4       	brne	.+36     	; 0x3884 <uip_arp_update+0x66>
    3860:	12 96       	adiw	r26, 0x02	; 2
    3862:	8d 91       	ld	r24, X+
    3864:	9c 91       	ld	r25, X
    3866:	13 97       	sbiw	r26, 0x03	; 3
    3868:	82 17       	cp	r24, r18
    386a:	93 07       	cpc	r25, r19
    386c:	59 f4       	brne	.+22     	; 0x3884 <uip_arp_update+0x66>
    386e:	e0 93 e3 00 	sts	0x00E3, r30
	 ipaddr[1] == tabptr->ipaddr[1]) {
	 
	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3872:	de 01       	movw	r26, r28
    3874:	14 96       	adiw	r26, 0x04	; 4
    3876:	f7 01       	movw	r30, r14
    3878:	86 e0       	ldi	r24, 0x06	; 6
    387a:	01 90       	ld	r0, Z+
    387c:	0d 92       	st	X+, r0
    387e:	81 50       	subi	r24, 0x01	; 1
    3880:	e1 f7       	brne	.-8      	; 0x387a <uip_arp_update+0x5c>
    3882:	56 c0       	rjmp	.+172    	; 0x3930 <uip_arp_update+0x112>
	tabptr->time = arptime;

	return;
    3884:	ef 5f       	subi	r30, 0xFF	; 255
{
  register struct arp_entry *tabptr;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3886:	e8 30       	cpi	r30, 0x08	; 8
    3888:	a8 f2       	brcs	.-86     	; 0x3834 <uip_arp_update+0x16>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    388a:	10 92 e3 00 	sts	0x00E3, r1
    388e:	20 e0       	ldi	r18, 0x00	; 0
    3890:	12 c0       	rjmp	.+36     	; 0x38b6 <uip_arp_update+0x98>
    tabptr = &arp_table[i];
    3892:	8b e0       	ldi	r24, 0x0B	; 11
    3894:	28 9f       	mul	r18, r24
    3896:	e0 01       	movw	r28, r0
    3898:	11 24       	eor	r1, r1
    389a:	c9 57       	subi	r28, 0x79	; 121
    389c:	df 4f       	sbci	r29, 0xFF	; 255
    if(tabptr->ipaddr[0] == 0 &&
    389e:	88 81       	ld	r24, Y
    38a0:	99 81       	ldd	r25, Y+1	; 0x01
    38a2:	89 2b       	or	r24, r25
    38a4:	39 f4       	brne	.+14     	; 0x38b4 <uip_arp_update+0x96>
    38a6:	8a 81       	ldd	r24, Y+2	; 0x02
    38a8:	9b 81       	ldd	r25, Y+3	; 0x03
    38aa:	89 2b       	or	r24, r25
    38ac:	19 f4       	brne	.+6      	; 0x38b4 <uip_arp_update+0x96>
    38ae:	20 93 e3 00 	sts	0x00E3, r18
    38b2:	2e c0       	rjmp	.+92     	; 0x3910 <uip_arp_update+0xf2>
    38b4:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    38b6:	28 30       	cpi	r18, 0x08	; 8
    38b8:	60 f3       	brcs	.-40     	; 0x3892 <uip_arp_update+0x74>
    38ba:	20 93 e3 00 	sts	0x00E3, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    38be:	28 30       	cpi	r18, 0x08	; 8
    38c0:	39 f5       	brne	.+78     	; 0x3910 <uip_arp_update+0xf2>
    tmpage = 0;
    38c2:	10 92 e6 00 	sts	0x00E6, r1
    c = 0;
    38c6:	10 92 e4 00 	sts	0x00E4, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    38ca:	10 91 e5 00 	lds	r17, 0x00E5
    38ce:	61 2f       	mov	r22, r17
    38d0:	77 27       	eor	r23, r23
    38d2:	f0 e0       	ldi	r31, 0x00	; 0
    38d4:	e0 e0       	ldi	r30, 0x00	; 0
    38d6:	50 e0       	ldi	r21, 0x00	; 0
    38d8:	13 c0       	rjmp	.+38     	; 0x3900 <uip_arp_update+0xe2>
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    38da:	8b e0       	ldi	r24, 0x0B	; 11
    38dc:	58 9f       	mul	r21, r24
    38de:	e0 01       	movw	r28, r0
    38e0:	11 24       	eor	r1, r1
    38e2:	c9 57       	subi	r28, 0x79	; 121
    38e4:	df 4f       	sbci	r29, 0xFF	; 255
      if(arptime - tabptr->time > tmpage) {
    38e6:	4a 85       	ldd	r20, Y+10	; 0x0a
    38e8:	9b 01       	movw	r18, r22
    38ea:	24 1b       	sub	r18, r20
    38ec:	31 09       	sbc	r19, r1
    38ee:	8e 2f       	mov	r24, r30
    38f0:	99 27       	eor	r25, r25
    38f2:	82 17       	cp	r24, r18
    38f4:	93 07       	cpc	r25, r19
    38f6:	1c f4       	brge	.+6      	; 0x38fe <uip_arp_update+0xe0>
	tmpage = arptime - tabptr->time;
    38f8:	e1 2f       	mov	r30, r17
    38fa:	e4 1b       	sub	r30, r20
    38fc:	f5 2f       	mov	r31, r21
    38fe:	5f 5f       	subi	r21, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3900:	58 30       	cpi	r21, 0x08	; 8
    3902:	58 f3       	brcs	.-42     	; 0x38da <uip_arp_update+0xbc>
    3904:	f0 93 e4 00 	sts	0x00E4, r31
    3908:	e0 93 e6 00 	sts	0x00E6, r30
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    390c:	f0 93 e3 00 	sts	0x00E3, r31
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
    3910:	8d 91       	ld	r24, X+
    3912:	9d 91       	ld	r25, X+
    3914:	0d 90       	ld	r0, X+
    3916:	bc 91       	ld	r27, X
    3918:	a0 2d       	mov	r26, r0
    391a:	fe 01       	movw	r30, r28
    391c:	81 93       	st	Z+, r24
    391e:	91 93       	st	Z+, r25
    3920:	a1 93       	st	Z+, r26
    3922:	b1 93       	st	Z+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3924:	d7 01       	movw	r26, r14
    3926:	86 e0       	ldi	r24, 0x06	; 6
    3928:	0d 90       	ld	r0, X+
    392a:	01 92       	st	Z+, r0
    392c:	81 50       	subi	r24, 0x01	; 1
    392e:	e1 f7       	brne	.-8      	; 0x3928 <uip_arp_update+0x10a>
  tabptr->time = arptime;
    3930:	80 91 e5 00 	lds	r24, 0x00E5
    3934:	8a 87       	std	Y+10, r24	; 0x0a
    3936:	df 91       	pop	r29
    3938:	cf 91       	pop	r28
    393a:	1f 91       	pop	r17
    393c:	ff 90       	pop	r15
    393e:	ef 90       	pop	r14
    3940:	08 95       	ret

00003942 <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    3942:	cf 93       	push	r28
    3944:	df 93       	push	r29

  if(uip_len < sizeof(struct arp_hdr)) {
    3946:	80 91 ea 02 	lds	r24, 0x02EA
    394a:	90 91 eb 02 	lds	r25, 0x02EB
    394e:	8a 97       	sbiw	r24, 0x2a	; 42
    3950:	28 f4       	brcc	.+10     	; 0x395c <uip_arp_arpin+0x1a>
    uip_len = 0;
    3952:	10 92 eb 02 	sts	0x02EB, r1
    3956:	10 92 ea 02 	sts	0x02EA, r1
    395a:	96 c0       	rjmp	.+300    	; 0x3a88 <uip_arp_arpin+0x146>
    return;
  }

  uip_len = 0;
    395c:	10 92 eb 02 	sts	0x02EB, r1
    3960:	10 92 ea 02 	sts	0x02EA, r1
  
  switch(BUF->opcode) {
    3964:	aa e6       	ldi	r26, 0x6A	; 106
    3966:	b3 e0       	ldi	r27, 0x03	; 3
    3968:	80 91 7e 03 	lds	r24, 0x037E
    396c:	90 91 7f 03 	lds	r25, 0x037F
    3970:	21 e0       	ldi	r18, 0x01	; 1
    3972:	80 30       	cpi	r24, 0x00	; 0
    3974:	92 07       	cpc	r25, r18
    3976:	29 f0       	breq	.+10     	; 0x3982 <uip_arp_arpin+0x40>
    3978:	80 50       	subi	r24, 0x00	; 0
    397a:	92 40       	sbci	r25, 0x02	; 2
    397c:	09 f0       	breq	.+2      	; 0x3980 <uip_arp_arpin+0x3e>
    397e:	84 c0       	rjmp	.+264    	; 0x3a88 <uip_arp_arpin+0x146>
    3980:	67 c0       	rjmp	.+206    	; 0x3a50 <uip_arp_arpin+0x10e>
  case HTONS(ARP_REQUEST):
    /* ARP request. If it asked for our address, we send out a
       reply. */
    if(BUF->dipaddr[0] == uip_hostaddr[0] &&
    3982:	40 91 90 03 	lds	r20, 0x0390
    3986:	50 91 91 03 	lds	r21, 0x0391
    398a:	80 91 61 00 	lds	r24, 0x0061
    398e:	90 91 62 00 	lds	r25, 0x0062
    3992:	48 17       	cp	r20, r24
    3994:	59 07       	cpc	r21, r25
    3996:	09 f0       	breq	.+2      	; 0x399a <uip_arp_arpin+0x58>
    3998:	77 c0       	rjmp	.+238    	; 0x3a88 <uip_arp_arpin+0x146>
    399a:	20 91 92 03 	lds	r18, 0x0392
    399e:	30 91 93 03 	lds	r19, 0x0393
    39a2:	80 91 63 00 	lds	r24, 0x0063
    39a6:	90 91 64 00 	lds	r25, 0x0064
    39aa:	28 17       	cp	r18, r24
    39ac:	39 07       	cpc	r19, r25
    39ae:	09 f0       	breq	.+2      	; 0x39b2 <uip_arp_arpin+0x70>
    39b0:	6b c0       	rjmp	.+214    	; 0x3a88 <uip_arp_arpin+0x146>
       BUF->dipaddr[1] == uip_hostaddr[1]) {
      /* The reply opcode is 2. */
      BUF->opcode = HTONS(2);
    39b2:	80 e0       	ldi	r24, 0x00	; 0
    39b4:	92 e0       	ldi	r25, 0x02	; 2
    39b6:	90 93 7f 03 	sts	0x037F, r25
    39ba:	80 93 7e 03 	sts	0x037E, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    39be:	ed 01       	movw	r28, r26
    39c0:	a0 96       	adiw	r28, 0x20	; 32
    39c2:	fd 01       	movw	r30, r26
    39c4:	76 96       	adiw	r30, 0x16	; 22
    39c6:	86 e0       	ldi	r24, 0x06	; 6
    39c8:	01 90       	ld	r0, Z+
    39ca:	09 92       	st	Y+, r0
    39cc:	81 50       	subi	r24, 0x01	; 1
    39ce:	e1 f7       	brne	.-8      	; 0x39c8 <uip_arp_arpin+0x86>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    39d0:	c0 e8       	ldi	r28, 0x80	; 128
    39d2:	d3 e0       	ldi	r29, 0x03	; 3
    39d4:	ed e6       	ldi	r30, 0x6D	; 109
    39d6:	f0 e0       	ldi	r31, 0x00	; 0
    39d8:	86 e0       	ldi	r24, 0x06	; 6
    39da:	01 90       	ld	r0, Z+
    39dc:	09 92       	st	Y+, r0
    39de:	81 50       	subi	r24, 0x01	; 1
    39e0:	e1 f7       	brne	.-8      	; 0x39da <uip_arp_arpin+0x98>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    39e2:	c0 e7       	ldi	r28, 0x70	; 112
    39e4:	d3 e0       	ldi	r29, 0x03	; 3
    39e6:	ed e6       	ldi	r30, 0x6D	; 109
    39e8:	f0 e0       	ldi	r31, 0x00	; 0
    39ea:	86 e0       	ldi	r24, 0x06	; 6
    39ec:	01 90       	ld	r0, Z+
    39ee:	09 92       	st	Y+, r0
    39f0:	81 50       	subi	r24, 0x01	; 1
    39f2:	e1 f7       	brne	.-8      	; 0x39ec <uip_arp_arpin+0xaa>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    39f4:	ea e6       	ldi	r30, 0x6A	; 106
    39f6:	f3 e0       	ldi	r31, 0x03	; 3
    39f8:	ef 01       	movw	r28, r30
    39fa:	a0 96       	adiw	r28, 0x20	; 32
    39fc:	86 e0       	ldi	r24, 0x06	; 6
    39fe:	09 90       	ld	r0, Y+
    3a00:	01 92       	st	Z+, r0
    3a02:	81 50       	subi	r24, 0x01	; 1
    3a04:	e1 f7       	brne	.-8      	; 0x39fe <uip_arp_arpin+0xbc>
      
      BUF->dipaddr[0] = BUF->sipaddr[0];
    3a06:	80 91 86 03 	lds	r24, 0x0386
    3a0a:	90 91 87 03 	lds	r25, 0x0387
    3a0e:	97 96       	adiw	r26, 0x27	; 39
    3a10:	9c 93       	st	X, r25
    3a12:	8e 93       	st	-X, r24
    3a14:	96 97       	sbiw	r26, 0x26	; 38
      BUF->dipaddr[1] = BUF->sipaddr[1];
    3a16:	80 91 88 03 	lds	r24, 0x0388
    3a1a:	90 91 89 03 	lds	r25, 0x0389
    3a1e:	99 96       	adiw	r26, 0x29	; 41
    3a20:	9c 93       	st	X, r25
    3a22:	8e 93       	st	-X, r24
    3a24:	98 97       	sbiw	r26, 0x28	; 40
      BUF->sipaddr[0] = uip_hostaddr[0];
    3a26:	5d 96       	adiw	r26, 0x1d	; 29
    3a28:	5c 93       	st	X, r21
    3a2a:	4e 93       	st	-X, r20
    3a2c:	5c 97       	sbiw	r26, 0x1c	; 28
      BUF->sipaddr[1] = uip_hostaddr[1];
    3a2e:	5f 96       	adiw	r26, 0x1f	; 31
    3a30:	3c 93       	st	X, r19
    3a32:	2e 93       	st	-X, r18
    3a34:	5e 97       	sbiw	r26, 0x1e	; 30

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);      
    3a36:	88 e0       	ldi	r24, 0x08	; 8
    3a38:	96 e0       	ldi	r25, 0x06	; 6
    3a3a:	1d 96       	adiw	r26, 0x0d	; 13
    3a3c:	9c 93       	st	X, r25
    3a3e:	8e 93       	st	-X, r24
    3a40:	1c 97       	sbiw	r26, 0x0c	; 12
      uip_len = sizeof(struct arp_hdr);
    3a42:	8a e2       	ldi	r24, 0x2A	; 42
    3a44:	90 e0       	ldi	r25, 0x00	; 0
    3a46:	90 93 eb 02 	sts	0x02EB, r25
    3a4a:	80 93 ea 02 	sts	0x02EA, r24
    3a4e:	1c c0       	rjmp	.+56     	; 0x3a88 <uip_arp_arpin+0x146>
    }      
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(BUF->dipaddr[0] == uip_hostaddr[0] &&
    3a50:	20 91 90 03 	lds	r18, 0x0390
    3a54:	30 91 91 03 	lds	r19, 0x0391
    3a58:	80 91 61 00 	lds	r24, 0x0061
    3a5c:	90 91 62 00 	lds	r25, 0x0062
    3a60:	28 17       	cp	r18, r24
    3a62:	39 07       	cpc	r19, r25
    3a64:	89 f4       	brne	.+34     	; 0x3a88 <uip_arp_arpin+0x146>
    3a66:	20 91 92 03 	lds	r18, 0x0392
    3a6a:	30 91 93 03 	lds	r19, 0x0393
    3a6e:	80 91 63 00 	lds	r24, 0x0063
    3a72:	90 91 64 00 	lds	r25, 0x0064
    3a76:	28 17       	cp	r18, r24
    3a78:	39 07       	cpc	r19, r25
    3a7a:	31 f4       	brne	.+12     	; 0x3a88 <uip_arp_arpin+0x146>
       BUF->dipaddr[1] == uip_hostaddr[1]) {

      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    3a7c:	60 e8       	ldi	r22, 0x80	; 128
    3a7e:	73 e0       	ldi	r23, 0x03	; 3
    3a80:	86 e8       	ldi	r24, 0x86	; 134
    3a82:	93 e0       	ldi	r25, 0x03	; 3
    3a84:	0e 94 0f 1c 	call	0x381e	; 0x381e <uip_arp_update>
    3a88:	df 91       	pop	r29
    3a8a:	cf 91       	pop	r28
    3a8c:	08 95       	ret

00003a8e <uip_arp_ipin>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_ipin(void)
{
  uip_len -= sizeof(struct uip_eth_hdr);
    3a8e:	80 91 ea 02 	lds	r24, 0x02EA
    3a92:	90 91 eb 02 	lds	r25, 0x02EB
    3a96:	0e 97       	sbiw	r24, 0x0e	; 14
    3a98:	90 93 eb 02 	sts	0x02EB, r25
    3a9c:	80 93 ea 02 	sts	0x02EA, r24
	
  /* Only insert/update an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  if((IPBUF->srcipaddr[0] & uip_arp_netmask[0]) !=
    3aa0:	80 91 69 00 	lds	r24, 0x0069
    3aa4:	90 91 6a 00 	lds	r25, 0x006A
    3aa8:	20 91 84 03 	lds	r18, 0x0384
    3aac:	30 91 85 03 	lds	r19, 0x0385
    3ab0:	28 23       	and	r18, r24
    3ab2:	39 23       	and	r19, r25
    3ab4:	40 91 61 00 	lds	r20, 0x0061
    3ab8:	50 91 62 00 	lds	r21, 0x0062
    3abc:	84 23       	and	r24, r20
    3abe:	95 23       	and	r25, r21
    3ac0:	28 17       	cp	r18, r24
    3ac2:	39 07       	cpc	r19, r25
    3ac4:	c9 f4       	brne	.+50     	; 0x3af8 <uip_arp_ipin+0x6a>
     (uip_hostaddr[0] & uip_arp_netmask[0])) {
    return;
  }
  if((IPBUF->srcipaddr[1] & uip_arp_netmask[1]) !=
    3ac6:	80 91 6b 00 	lds	r24, 0x006B
    3aca:	90 91 6c 00 	lds	r25, 0x006C
    3ace:	20 91 86 03 	lds	r18, 0x0386
    3ad2:	30 91 87 03 	lds	r19, 0x0387
    3ad6:	28 23       	and	r18, r24
    3ad8:	39 23       	and	r19, r25
    3ada:	40 91 63 00 	lds	r20, 0x0063
    3ade:	50 91 64 00 	lds	r21, 0x0064
    3ae2:	84 23       	and	r24, r20
    3ae4:	95 23       	and	r25, r21
    3ae6:	28 17       	cp	r18, r24
    3ae8:	39 07       	cpc	r19, r25
    3aea:	31 f4       	brne	.+12     	; 0x3af8 <uip_arp_ipin+0x6a>
     (uip_hostaddr[1] & uip_arp_netmask[1])) {
    return;
  }
  uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
    3aec:	60 e7       	ldi	r22, 0x70	; 112
    3aee:	73 e0       	ldi	r23, 0x03	; 3
    3af0:	84 e8       	ldi	r24, 0x84	; 132
    3af2:	93 e0       	ldi	r25, 0x03	; 3
    3af4:	0e 94 0f 1c 	call	0x381e	; 0x381e <uip_arp_update>
    3af8:	08 95       	ret

00003afa <uip_add32>:

.global uip_add32
.func uip_add32

uip_add32:
 movw ZL , r24
    3afa:	fc 01       	movw	r30, r24
 ldd  r24, Z+3
    3afc:	83 81       	ldd	r24, Z+3	; 0x03
 ldd  r25, Z+2
    3afe:	92 81       	ldd	r25, Z+2	; 0x02
 ldd  r26, Z+1
    3b00:	a1 81       	ldd	r26, Z+1	; 0x01
 ld   r27, Z
    3b02:	b0 81       	ld	r27, Z
 add  r24, r22
    3b04:	86 0f       	add	r24, r22
 adc  r25, r23
    3b06:	97 1f       	adc	r25, r23
 adc  r26, ZERO
    3b08:	a1 1d       	adc	r26, r1
 adc  r27, ZERO
    3b0a:	b1 1d       	adc	r27, r1
 sts  uip_acc32+3, r24
    3b0c:	80 93 f1 02 	sts	0x02F1, r24
 sts  uip_acc32+2, r25
    3b10:	90 93 f0 02 	sts	0x02F0, r25
 sts  uip_acc32+1, r26
    3b14:	a0 93 ef 02 	sts	0x02EF, r26
 sts  uip_acc32,   r27 
    3b18:	b0 93 ee 02 	sts	0x02EE, r27
 ret
    3b1c:	08 95       	ret

00003b1e <uip_chksum>:

.global uip_chksum
.func uip_chksum

uip_chksum:
 movw ZL , r24
    3b1e:	fc 01       	movw	r30, r24
 clr  r24
    3b20:	88 27       	eor	r24, r24
 clr  r25
    3b22:	99 27       	eor	r25, r25
 cpi  r22, 2
    3b24:	62 30       	cpi	r22, 0x02	; 2
 cpc  r23, ZERO
    3b26:	71 05       	cpc	r23, r1
 brcs uip_chksum_2
    3b28:	50 f0       	brcs	.+20     	; 0x3b3e <uip_chksum_2>
 movw r26, r22
    3b2a:	db 01       	movw	r26, r22
 andi r26, 254
    3b2c:	ae 7f       	andi	r26, 0xFE	; 254

00003b2e <uip_chksum_1>:
uip_chksum_1:
 ld   r23, Z+
    3b2e:	71 91       	ld	r23, Z+
 add  r24, r23
    3b30:	87 0f       	add	r24, r23
 ld   r23, Z+
    3b32:	71 91       	ld	r23, Z+
 adc  r25, r23
    3b34:	97 1f       	adc	r25, r23
 adc  r24, ZERO
    3b36:	81 1d       	adc	r24, r1
 adc  r25, ZERO
    3b38:	91 1d       	adc	r25, r1
 sbiw r26, 2
    3b3a:	12 97       	sbiw	r26, 0x02	; 2
 brne uip_chksum_1
    3b3c:	c1 f7       	brne	.-16     	; 0x3b2e <uip_chksum_1>

00003b3e <uip_chksum_2>:
uip_chksum_2:
 sbrs r22, 0
    3b3e:	60 ff       	sbrs	r22, 0
 ret
    3b40:	08 95       	ret
 ld   r23, Z
    3b42:	70 81       	ld	r23, Z
 add  r24, r23
    3b44:	87 0f       	add	r24, r23
 adc  r25, ZERO
    3b46:	91 1d       	adc	r25, r1
 adc  r24, ZERO
    3b48:	81 1d       	adc	r24, r1
 adc  r25, ZERO
    3b4a:	91 1d       	adc	r25, r1
 ret
    3b4c:	08 95       	ret

00003b4e <uip_ipchksum>:

.global uip_ipchksum
.func uip_ipchksum

uip_ipchksum:
 ldi  r22, 20
    3b4e:	64 e1       	ldi	r22, 0x14	; 20
 ldi  r23, 0
    3b50:	70 e0       	ldi	r23, 0x00	; 0
 ldi  r24, lo8(BUF)
    3b52:	88 e7       	ldi	r24, 0x78	; 120
 ldi  r25, hi8(BUF)
    3b54:	93 e0       	ldi	r25, 0x03	; 3
 rjmp uip_chksum
    3b56:	e3 cf       	rjmp	.-58     	; 0x3b1e <uip_chksum>

00003b58 <uip_tcpchksum>:

.global uip_tcpchksum
.func uip_tcpchksum

uip_tcpchksum:
 ldi  r22, 20
    3b58:	64 e1       	ldi	r22, 0x14	; 20
 ldi  r23, 0
    3b5a:	70 e0       	ldi	r23, 0x00	; 0
 ldi  r24, lo8(BUF+20)
    3b5c:	8c e8       	ldi	r24, 0x8C	; 140
 ldi  r25, hi8(BUF+20)
    3b5e:	93 e0       	ldi	r25, 0x03	; 3
 rcall uip_chksum
    3b60:	de df       	rcall	.-68     	; 0x3b1e <uip_chksum>
 movw r18, r24		// -> hsum
    3b62:	9c 01       	movw	r18, r24
 lds  r24, BUF+3	// len[1]
    3b64:	80 91 7b 03 	lds	r24, 0x037B
 lds  r25, BUF+2	// len[0]
    3b68:	90 91 7a 03 	lds	r25, 0x037A
 sbiw r24, 20
    3b6c:	44 97       	sbiw	r24, 0x14	; 20
 movw r20, r24
    3b6e:	ac 01       	movw	r20, r24
 sbiw r24, 20
    3b70:	44 97       	sbiw	r24, 0x14	; 20
 movw r22, r24
    3b72:	bc 01       	movw	r22, r24
 lds  r24, uip_appdata
    3b74:	80 91 f3 02 	lds	r24, 0x02F3
 lds  r25, uip_appdata+1
    3b78:	90 91 f4 02 	lds	r25, 0x02F4
 rcall uip_chksum
    3b7c:	d0 df       	rcall	.-96     	; 0x3b1e <uip_chksum>
 add  r24, r18
    3b7e:	82 0f       	add	r24, r18
 adc  r25, r19
    3b80:	93 1f       	adc	r25, r19
 lds  r22, BUF+12
    3b82:	60 91 84 03 	lds	r22, 0x0384
 lds  r23, BUF+13	// srcipaddr[0]
    3b86:	70 91 85 03 	lds	r23, 0x0385
 adc  r24, r22
    3b8a:	86 1f       	adc	r24, r22
 adc  r25, r23
    3b8c:	97 1f       	adc	r25, r23
 lds  r22, BUF+14
    3b8e:	60 91 86 03 	lds	r22, 0x0386
 lds  r23, BUF+15	// srcipaddr[1]
    3b92:	70 91 87 03 	lds	r23, 0x0387
 adc  r24, r22
    3b96:	86 1f       	adc	r24, r22
 adc  r25, r23
    3b98:	97 1f       	adc	r25, r23
 lds  r22, BUF+16
    3b9a:	60 91 88 03 	lds	r22, 0x0388
 lds  r23, BUF+17	// destipaddr[0]
    3b9e:	70 91 89 03 	lds	r23, 0x0389
 adc  r24, r22
    3ba2:	86 1f       	adc	r24, r22
 adc  r25, r23
    3ba4:	97 1f       	adc	r25, r23
 lds  r22, BUF+18
    3ba6:	60 91 8a 03 	lds	r22, 0x038A
 lds  r23, BUF+19	// destipaddr[1]
    3baa:	70 91 8b 03 	lds	r23, 0x038B
 adc  r24, r22
    3bae:	86 1f       	adc	r24, r22
 adc  r25, r23
    3bb0:	97 1f       	adc	r25, r23
 ldi  r23, IP_PROTO_TCP
    3bb2:	76 e0       	ldi	r23, 0x06	; 6
 adc  r24, ZERO
    3bb4:	81 1d       	adc	r24, r1
 adc  r25, r23
    3bb6:	97 1f       	adc	r25, r23
 adc  r24, r21
    3bb8:	85 1f       	adc	r24, r21
 adc  r25, r20
    3bba:	94 1f       	adc	r25, r20
 adc  r24, ZERO
    3bbc:	81 1d       	adc	r24, r1
 adc  r25, ZERO
    3bbe:	91 1d       	adc	r25, r1
 ret
    3bc0:	08 95       	ret

00003bc2 <__mulsi3>:
    3bc2:	62 9f       	mul	r22, r18
    3bc4:	d0 01       	movw	r26, r0
    3bc6:	73 9f       	mul	r23, r19
    3bc8:	f0 01       	movw	r30, r0
    3bca:	82 9f       	mul	r24, r18
    3bcc:	e0 0d       	add	r30, r0
    3bce:	f1 1d       	adc	r31, r1
    3bd0:	64 9f       	mul	r22, r20
    3bd2:	e0 0d       	add	r30, r0
    3bd4:	f1 1d       	adc	r31, r1
    3bd6:	92 9f       	mul	r25, r18
    3bd8:	f0 0d       	add	r31, r0
    3bda:	83 9f       	mul	r24, r19
    3bdc:	f0 0d       	add	r31, r0
    3bde:	74 9f       	mul	r23, r20
    3be0:	f0 0d       	add	r31, r0
    3be2:	65 9f       	mul	r22, r21
    3be4:	f0 0d       	add	r31, r0
    3be6:	99 27       	eor	r25, r25
    3be8:	72 9f       	mul	r23, r18
    3bea:	b0 0d       	add	r27, r0
    3bec:	e1 1d       	adc	r30, r1
    3bee:	f9 1f       	adc	r31, r25
    3bf0:	63 9f       	mul	r22, r19
    3bf2:	b0 0d       	add	r27, r0
    3bf4:	e1 1d       	adc	r30, r1
    3bf6:	f9 1f       	adc	r31, r25
    3bf8:	bd 01       	movw	r22, r26
    3bfa:	cf 01       	movw	r24, r30
    3bfc:	11 24       	eor	r1, r1
    3bfe:	08 95       	ret

00003c00 <__divmodsi4>:
    3c00:	97 fb       	bst	r25, 7
    3c02:	09 2e       	mov	r0, r25
    3c04:	05 26       	eor	r0, r21
    3c06:	0e d0       	rcall	.+28     	; 0x3c24 <__divmodsi4_neg1>
    3c08:	57 fd       	sbrc	r21, 7
    3c0a:	04 d0       	rcall	.+8      	; 0x3c14 <__divmodsi4_neg2>
    3c0c:	14 d0       	rcall	.+40     	; 0x3c36 <__udivmodsi4>
    3c0e:	0a d0       	rcall	.+20     	; 0x3c24 <__divmodsi4_neg1>
    3c10:	00 1c       	adc	r0, r0
    3c12:	38 f4       	brcc	.+14     	; 0x3c22 <__divmodsi4_exit>

00003c14 <__divmodsi4_neg2>:
    3c14:	50 95       	com	r21
    3c16:	40 95       	com	r20
    3c18:	30 95       	com	r19
    3c1a:	21 95       	neg	r18
    3c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c1e:	4f 4f       	sbci	r20, 0xFF	; 255
    3c20:	5f 4f       	sbci	r21, 0xFF	; 255

00003c22 <__divmodsi4_exit>:
    3c22:	08 95       	ret

00003c24 <__divmodsi4_neg1>:
    3c24:	f6 f7       	brtc	.-4      	; 0x3c22 <__divmodsi4_exit>
    3c26:	90 95       	com	r25
    3c28:	80 95       	com	r24
    3c2a:	70 95       	com	r23
    3c2c:	61 95       	neg	r22
    3c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    3c30:	8f 4f       	sbci	r24, 0xFF	; 255
    3c32:	9f 4f       	sbci	r25, 0xFF	; 255
    3c34:	08 95       	ret

00003c36 <__udivmodsi4>:
    3c36:	a1 e2       	ldi	r26, 0x21	; 33
    3c38:	1a 2e       	mov	r1, r26
    3c3a:	aa 1b       	sub	r26, r26
    3c3c:	bb 1b       	sub	r27, r27
    3c3e:	fd 01       	movw	r30, r26
    3c40:	0d c0       	rjmp	.+26     	; 0x3c5c <__udivmodsi4_ep>

00003c42 <__udivmodsi4_loop>:
    3c42:	aa 1f       	adc	r26, r26
    3c44:	bb 1f       	adc	r27, r27
    3c46:	ee 1f       	adc	r30, r30
    3c48:	ff 1f       	adc	r31, r31
    3c4a:	a2 17       	cp	r26, r18
    3c4c:	b3 07       	cpc	r27, r19
    3c4e:	e4 07       	cpc	r30, r20
    3c50:	f5 07       	cpc	r31, r21
    3c52:	20 f0       	brcs	.+8      	; 0x3c5c <__udivmodsi4_ep>
    3c54:	a2 1b       	sub	r26, r18
    3c56:	b3 0b       	sbc	r27, r19
    3c58:	e4 0b       	sbc	r30, r20
    3c5a:	f5 0b       	sbc	r31, r21

00003c5c <__udivmodsi4_ep>:
    3c5c:	66 1f       	adc	r22, r22
    3c5e:	77 1f       	adc	r23, r23
    3c60:	88 1f       	adc	r24, r24
    3c62:	99 1f       	adc	r25, r25
    3c64:	1a 94       	dec	r1
    3c66:	69 f7       	brne	.-38     	; 0x3c42 <__udivmodsi4_loop>
    3c68:	60 95       	com	r22
    3c6a:	70 95       	com	r23
    3c6c:	80 95       	com	r24
    3c6e:	90 95       	com	r25
    3c70:	9b 01       	movw	r18, r22
    3c72:	ac 01       	movw	r20, r24
    3c74:	bd 01       	movw	r22, r26
    3c76:	cf 01       	movw	r24, r30
    3c78:	08 95       	ret

00003c7a <atoi>:
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	88 27       	eor	r24, r24
    3c7e:	99 27       	eor	r25, r25
    3c80:	e8 94       	clt
    3c82:	21 91       	ld	r18, Z+
    3c84:	20 32       	cpi	r18, 0x20	; 32
    3c86:	e9 f3       	breq	.-6      	; 0x3c82 <atoi+0x8>
    3c88:	29 30       	cpi	r18, 0x09	; 9
    3c8a:	10 f0       	brcs	.+4      	; 0x3c90 <atoi+0x16>
    3c8c:	2e 30       	cpi	r18, 0x0E	; 14
    3c8e:	c8 f3       	brcs	.-14     	; 0x3c82 <atoi+0x8>
    3c90:	2b 32       	cpi	r18, 0x2B	; 43
    3c92:	41 f0       	breq	.+16     	; 0x3ca4 <atoi+0x2a>
    3c94:	2d 32       	cpi	r18, 0x2D	; 45
    3c96:	39 f4       	brne	.+14     	; 0x3ca6 <atoi+0x2c>
    3c98:	68 94       	set
    3c9a:	04 c0       	rjmp	.+8      	; 0x3ca4 <atoi+0x2a>
    3c9c:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__mulhi_const_10>
    3ca0:	82 0f       	add	r24, r18
    3ca2:	91 1d       	adc	r25, r1
    3ca4:	21 91       	ld	r18, Z+
    3ca6:	20 53       	subi	r18, 0x30	; 48
    3ca8:	2a 30       	cpi	r18, 0x0A	; 10
    3caa:	c0 f3       	brcs	.-16     	; 0x3c9c <atoi+0x22>
    3cac:	1e f4       	brtc	.+6      	; 0x3cb4 <atoi+0x3a>
    3cae:	90 95       	com	r25
    3cb0:	81 95       	neg	r24
    3cb2:	9f 4f       	sbci	r25, 0xFF	; 255
    3cb4:	08 95       	ret

00003cb6 <memcpy_P>:
    3cb6:	fb 01       	movw	r30, r22
    3cb8:	dc 01       	movw	r26, r24
    3cba:	02 c0       	rjmp	.+4      	; 0x3cc0 <memcpy_P+0xa>
    3cbc:	05 90       	lpm	r0, Z+
    3cbe:	0d 92       	st	X+, r0
    3cc0:	41 50       	subi	r20, 0x01	; 1
    3cc2:	50 40       	sbci	r21, 0x00	; 0
    3cc4:	d8 f7       	brcc	.-10     	; 0x3cbc <memcpy_P+0x6>
    3cc6:	08 95       	ret

00003cc8 <strncmp_P>:
    3cc8:	fb 01       	movw	r30, r22
    3cca:	dc 01       	movw	r26, r24
    3ccc:	41 50       	subi	r20, 0x01	; 1
    3cce:	50 40       	sbci	r21, 0x00	; 0
    3cd0:	30 f0       	brcs	.+12     	; 0x3cde <strncmp_P+0x16>
    3cd2:	8d 91       	ld	r24, X+
    3cd4:	05 90       	lpm	r0, Z+
    3cd6:	80 19       	sub	r24, r0
    3cd8:	19 f4       	brne	.+6      	; 0x3ce0 <strncmp_P+0x18>
    3cda:	00 20       	and	r0, r0
    3cdc:	b9 f7       	brne	.-18     	; 0x3ccc <strncmp_P+0x4>
    3cde:	88 1b       	sub	r24, r24
    3ce0:	99 0b       	sbc	r25, r25
    3ce2:	08 95       	ret

00003ce4 <memset>:
    3ce4:	dc 01       	movw	r26, r24
    3ce6:	01 c0       	rjmp	.+2      	; 0x3cea <memset+0x6>
    3ce8:	6d 93       	st	X+, r22
    3cea:	41 50       	subi	r20, 0x01	; 1
    3cec:	50 40       	sbci	r21, 0x00	; 0
    3cee:	e0 f7       	brcc	.-8      	; 0x3ce8 <memset+0x4>
    3cf0:	08 95       	ret

00003cf2 <__mulhi_const_10>:
    3cf2:	7a e0       	ldi	r23, 0x0A	; 10
    3cf4:	97 9f       	mul	r25, r23
    3cf6:	90 2d       	mov	r25, r0
    3cf8:	87 9f       	mul	r24, r23
    3cfa:	80 2d       	mov	r24, r0
    3cfc:	91 0d       	add	r25, r1
    3cfe:	11 24       	eor	r1, r1
    3d00:	08 95       	ret

00003d02 <_exit>:
    3d02:	ff cf       	rjmp	.-2      	; 0x3d02 <_exit>
